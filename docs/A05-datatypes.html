<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>A05-datatypes.knit</title>

<script src="site_libs/header-attrs-2.9/header-attrs.js"></script>
<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Reproducible Data Analysis in R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">




</div>


<hr />
<hr />
<div id="data-structures" class="section level1">
<h1>Data structures</h1>
<ul>
<li><strong>Atomic vectors</strong> are arrays that contain a single data type (logical, real, complex, character). Each of the following is a one-dimensional atomic vector:</li>
</ul>
<pre class="r"><code>passed &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE) # random sequence
class(passed)</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<pre class="r"><code>ages &lt;- c(53, 51, 25, 67, 66, 41, 62, 42) # random numbers
class(ages)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>namez &lt;- c(&quot;Marina&quot;, &quot;Allar&quot;, &quot;Siim&quot;, &quot;Mart&quot;, &quot;Mailis&quot;, &quot;Eiki&quot;, &quot;Urmas&quot;) # random names, names is R function!
class(namez)  </code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<p>A scalar is an atomic vector with a single element. So <code>k &lt;- 2</code> is a shortcut for <code>k &lt;- c(2)</code>.</p>
<ul>
<li>A <strong>matrix</strong> is an atomic vector that has a dimension attribute, <code>dim()</code>, containing two elements (<code>nrow</code>, number of rows and <code>ncol</code>, number of columns)</li>
</ul>
<pre class="r"><code>matrix(ages, nrow = 2)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]   53   25   66   62
## [2,]   51   67   41   42</code></pre>
<ul>
<li><strong>Lists</strong> are collections of atomic vectors and/or other lists.</li>
</ul>
<pre class="r"><code>mylist &lt;- list(passed, ages, namez)
mylist</code></pre>
<pre><code>## [[1]]
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## [[2]]
## [1] 53 51 25 67 66 41 62 42
## 
## [[3]]
## [1] &quot;Marina&quot; &quot;Allar&quot;  &quot;Siim&quot;   &quot;Mart&quot;   &quot;Mailis&quot; &quot;Eiki&quot;   &quot;Urmas&quot;</code></pre>
<p>We can assign names to list objects:</p>
<pre class="r"><code>names(mylist) &lt;- c(&quot;passed&quot;, &quot;ages&quot;, &quot;namez&quot;)
mylist</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## $ages
## [1] 53 51 25 67 66 41 62 42
## 
## $namez
## [1] &quot;Marina&quot; &quot;Allar&quot;  &quot;Siim&quot;   &quot;Mart&quot;   &quot;Mailis&quot; &quot;Eiki&quot;   &quot;Urmas&quot;</code></pre>
<ul>
<li><strong>Data frames</strong> are a special type of list, where each atomic vector in the collection has the same length. Each vector represents a column (variable) in the data frame.</li>
</ul>
<pre class="r"><code>exam &lt;- data.frame(name = namez, passed = passed)
exam</code></pre>
<pre><code>##     name passed
## 1 Marina   TRUE
## 2  Allar  FALSE
## 3   Siim  FALSE
## 4   Mart  FALSE
## 5 Mailis   TRUE
## 6   Eiki   TRUE
## 7  Urmas   TRUE</code></pre>
<div class="figure">
<img src="https://raw.githubusercontent.com/Anonymous-Y/BlogImage/master/r-intro-3.jpg" alt="" />
<p class="caption">Illustration of R data types. Image: <a href="http://yzc.me/2015/12/11/r-intro-1/">http://yzc.me/2015/12/11/r-intro-1/</a></p>
</div>
</div>
<div id="selecting-by-index" class="section level1">
<h1>Selecting by index</h1>
<p>Index gives the address that specifies the elements of vector/matrix/list or data.frame, which are then automatically selected.</p>
<ul>
<li>Indexing begins at 1 (not 0) in R</li>
<li>Indexing operators in R are square brackets – ‘[’, <code>[[</code> and dollar sign <code>$</code><br />
</li>
<li><code>[</code> allows selecting more than one element, whereas <code>[[</code> and <code>$</code> select only one element.</li>
<li>Empty index [,] means “select all” – <code>a[,1]</code> means “select all rows and 1st column from <code>a</code>”.</li>
</ul>
<!-- ```{r} -->
<!-- '['(c(1,2,3), 1) == c(1,2,3)[1] # as you can see these are both identical -->
<!-- ``` -->
<!-- + you can select values, rows or columns by index -->
<!-- + `-` (minus) before index means "not this element" -->
<!-- + ! means "not" -->
<!-- + != means "not equal" -->
<!-- + == means "equal" -->
<p>During initial data exploration it is often necessary to have a look how the head of your table looks like, for this you can use convenience methods <code>head</code> and <code>tail</code> which are returning first and last elements of a object, respectively:</p>
<pre class="r"><code>head(mtcars) # Prints first 6 elements (rows) as default</code></pre>
<pre><code>##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1</code></pre>
<pre class="r"><code>tail(mtcars, n = 3) # Prints last 3 elements (rows)</code></pre>
<pre><code>##                mpg cyl disp  hp drat   wt qsec vs am gear carb
## Ferrari Dino  19.7   6  145 175 3.62 2.77 15.5  0  1    5    6
## Maserati Bora 15.0   8  301 335 3.54 3.57 14.6  0  1    5    8
## Volvo 142E    21.4   4  121 109 4.11 2.78 18.6  1  1    4    2</code></pre>
<p>Tip: you can use <code>tail</code> to return the very last element of a object with unknown length.</p>
<pre class="r"><code>tail(LETTERS, n = 1)</code></pre>
<pre><code>## [1] &quot;Z&quot;</code></pre>
</div>
<div id="vectors" class="section level1">
<h1>Vectors</h1>
<p>The combine function <code>c()</code> is used to form the vector.</p>
<pre class="r"><code>a &lt;- c(1, 2, 5, -3, 6, -2, 4)
b &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
d &lt;- c(TRUE,TRUE,TRUE,FALSE,TRUE,FALSE) # We use d instead of c as vector name. Why?</code></pre>
<p><code>a</code> is a numeric vector, <code>b</code> is a character vector, and <code>d</code> is a logical vector. The data in a vector can be only one type (numeric, character, or logical).</p>
<p>You can refer to elements of a vector:</p>
<pre class="r"><code>a[c(2, 4)] # Refers to the second and fourth elements of vector a.</code></pre>
<pre><code>## [1]  2 -3</code></pre>
<pre class="r"><code>&#39;[&#39;(a, c(2,4)) # [ is a function! This is very handy in case of piping, as we see in the upcoming lessons.</code></pre>
<pre><code>## [1]  2 -3</code></pre>
<p>We can sort/order vector:</p>
<pre class="r"><code>sort(a, decreasing = FALSE) # sorts vector in ascending order</code></pre>
<pre><code>## [1] -3 -2  1  2  4  5  6</code></pre>
<p>We can extract uniqe elements of a vector:</p>
<pre class="r"><code>d</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE</code></pre>
<pre class="r"><code>unique(d) # Returns a vector, data frame or array like d but with duplicate elements removed.</code></pre>
<pre><code>## [1]  TRUE FALSE</code></pre>
<p>Create sequence:</p>
<pre class="r"><code>seq(2, 5, by = 0.5)</code></pre>
<pre><code>## [1] 2.0 2.5 3.0 3.5 4.0 4.5 5.0</code></pre>
<p>A complex sequence:</p>
<pre class="r"><code>rep(1:4, times = 2)</code></pre>
<pre><code>## [1] 1 2 3 4 1 2 3 4</code></pre>
<p>Repeat each element of a vector:</p>
<pre class="r"><code>rep(1:2, each = 3)</code></pre>
<pre><code>## [1] 1 1 1 2 2 2</code></pre>
<p>Repeat elements of a vector:</p>
<pre class="r"><code>rep(c(&quot;poodle&quot;,&quot;sheltie&quot;), each = 3, times = 2)</code></pre>
<pre><code>##  [1] &quot;poodle&quot;  &quot;poodle&quot;  &quot;poodle&quot;  &quot;sheltie&quot; &quot;sheltie&quot; &quot;sheltie&quot; &quot;poodle&quot; 
##  [8] &quot;poodle&quot;  &quot;poodle&quot;  &quot;sheltie&quot; &quot;sheltie&quot; &quot;sheltie&quot;</code></pre>
</div>
<div id="data-frame" class="section level1">
<h1>Data frame</h1>
<ul>
<li><p><code>data frame</code>: a collection of vectors where different columns can contain different modes of data (numeric, character, and so on). Each vector contains only 1 mode of data (<code>vector1 &lt;- c("a", 2, 3.4)</code> is automatically coerced to <code>chr</code>, but can be manually coerced to numeric or factor). The data frame columns are variables, and the rows are observations. Vectors are bound into matrix/data.frame vertically, with the direction from top to bottom. Column = vector. <code>as.matrix()</code> has default argument <code>byrow = FALSE</code>, change this to fill matrix by rows.</p></li>
<li><p><code>tibble::data_frame()</code> is a more modern version of data.frame (slight differences for the better) <code>as_data_frame()</code> converts to it. <code>data_frame()</code> does less than <code>data.frame()</code>:</p>
<ul>
<li>it never changes the type of the inputs (e.g. it never converts strings to factors!),</li>
<li>it never changes the names of variables, and it never creates <code>row.names()</code>.</li>
</ul></li>
</ul>
<p><strong>Tibbles</strong> have a print method that shows only the first 10 rows, and all the columns that fit on screen. This makes it much easier to work with large data. <!-- In addition to its name, each column reports its type.  --> <!-- Tibbles clearly delineate `[` and `[[`: `[` always returns another tibble, `[[` always returns a vector.  --> <!-- Some older functions don't work with tibbles because they expect `df[, 1]` to return a vector, not a data frame.  --> <!-- If you encounter one of these functions, use `as.data.frame()` to coerce a tibble back to a data frame: --></p>
<div class="figure">
<img src="http://articles.concreteinteractive.com/wp-content/uploads/2015/03/irises.png" alt="" />
<p class="caption">Iris dataset contains sepal and petal measurements of three iris species.</p>
</div>
<pre class="r"><code>library(dplyr) # tbl_df 
tbl_df(iris)</code></pre>
<pre><code>## Warning: `tbl_df()` was deprecated in dplyr 1.0.0.
## Please use `tibble::as_tibble()` instead.</code></pre>
<pre><code>## # A tibble: 150 x 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
##  1          5.1         3.5          1.4         0.2 setosa 
##  2          4.9         3            1.4         0.2 setosa 
##  3          4.7         3.2          1.3         0.2 setosa 
##  4          4.6         3.1          1.5         0.2 setosa 
##  5          5           3.6          1.4         0.2 setosa 
##  6          5.4         3.9          1.7         0.4 setosa 
##  7          4.6         3.4          1.4         0.3 setosa 
##  8          5           3.4          1.5         0.2 setosa 
##  9          4.4         2.9          1.4         0.2 setosa 
## 10          4.9         3.1          1.5         0.1 setosa 
## # … with 140 more rows</code></pre>
<pre class="r"><code>class(as.data.frame(tbl_df(iris)))</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<pre class="r"><code>library(tibble)
height &lt;- c(187, 190, 156)
name &lt;- c(&quot;Jim&quot;, &quot;Joe&quot;, &quot;Jill&quot;)
my_tab &lt;- data_frame(name, height) # object names are used as column names</code></pre>
<pre><code>## Warning: `data_frame()` was deprecated in tibble 1.1.0.
## Please use `tibble()` instead.</code></pre>
<pre class="r"><code>my_tab</code></pre>
<pre><code>## # A tibble: 3 x 2
##   name  height
##   &lt;chr&gt;  &lt;dbl&gt;
## 1 Jim      187
## 2 Joe      190
## 3 Jill     156</code></pre>
<pre class="r"><code>summary(my_tab) # Prints a summary of data</code></pre>
<pre><code>##      name               height     
##  Length:3           Min.   :156.0  
##  Class :character   1st Qu.:171.5  
##  Mode  :character   Median :187.0  
##                     Mean   :177.7  
##                     3rd Qu.:188.5  
##                     Max.   :190.0</code></pre>
<pre class="r"><code>names(my_tab) # Prints column names</code></pre>
<pre><code>## [1] &quot;name&quot;   &quot;height&quot;</code></pre>
<pre class="r"><code>nrow(my_tab) # number of rows</code></pre>
<pre><code>## [1] 3</code></pre>
<pre class="r"><code>ncol(my_tab)</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code>dim(my_tab)</code></pre>
<pre><code>## [1] 3 2</code></pre>
<div id="indexing-data.frames" class="section level2">
<h2>Indexing data.frames</h2>
<!-- Data frames can be indexed in several modes. When [ and [[ are used with a single vector index (x[i] or x[[i]]), they index the data frame as if it were a list. -->
<p>We use R <code>mtcars</code> dataset to illustrate indexing of a data.frame:</p>
<pre class="r"><code>class(mtcars)</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<pre class="r"><code>dim(mtcars) # what&#39;s the size of the data.frame</code></pre>
<pre><code>## [1] 32 11</code></pre>
<pre class="r"><code>mtc &lt;- mtcars[sample(1:nrow(mtcars), 6), ] # select a manageable subset
mtc</code></pre>
<pre><code>##                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## Merc 450SE     16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
## Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
## Merc 450SLC    15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
## Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
## Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
## Mazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4</code></pre>
<p>Here we select columns:</p>
<pre class="r"><code>mtc[,2] # selects 2nd column and returns vector</code></pre>
<pre><code>## [1] 8 4 8 4 4 6</code></pre>
<pre class="r"><code>mtc[3] # selects 3nd column and returns data.frame</code></pre>
<pre><code>##                 disp
## Merc 450SE     275.8
## Merc 230       140.8
## Merc 450SLC    275.8
## Toyota Corolla  71.1
## Datsun 710     108.0
## Mazda RX4      160.0</code></pre>
<pre class="r"><code>mtc[, &quot;hp&quot;] # selects column named &quot;hp&quot;</code></pre>
<pre><code>## [1] 180  95 180  65  93 110</code></pre>
<pre class="r"><code>mtc$cyl # selects column named &quot;cyl&quot;</code></pre>
<pre><code>## [1] 8 4 8 4 4 6</code></pre>
<pre class="r"><code>df &lt;- data.frame(M = c(2, 3, 6, 3, 34), N = c(34, 3, 8, 3, 3), L = c(TRUE, FALSE, TRUE, FALSE, TRUE))
df</code></pre>
<pre><code>##    M  N     L
## 1  2 34  TRUE
## 2  3  3 FALSE
## 3  6  8  TRUE
## 4  3  3 FALSE
## 5 34  3  TRUE</code></pre>
<pre class="r"><code>df[df$M == 34,] # selects rows from A that have value == 34</code></pre>
<pre><code>##    M N    L
## 5 34 3 TRUE</code></pre>
<pre class="r"><code>df[1:2, &quot;N&quot;] # selects rows 1 through 2 from column &quot;A&quot;</code></pre>
<pre><code>## [1] 34  3</code></pre>
<pre class="r"><code>rownames(df) &lt;- letters[1:5] # letters vector gives us lower case letters
df[rownames(df) == &quot;c&quot;,] # selects row named &quot;c&quot;</code></pre>
<pre><code>##   M N    L
## c 6 8 TRUE</code></pre>
<pre class="r"><code>df[-(2:4),] # drops rows 2 to 4 (incl)</code></pre>
<pre><code>##    M  N    L
## a  2 34 TRUE
## e 34  3 TRUE</code></pre>
<pre class="r"><code>df[, -2] # drops col 2, outputs vector! </code></pre>
<pre><code>##    M     L
## a  2  TRUE
## b  3 FALSE
## c  6  TRUE
## d  3 FALSE
## e 34  TRUE</code></pre>
<pre class="r"><code>df[df$M == 6,] # selects all rows that contain 6 in column named M</code></pre>
<pre><code>##   M N    L
## c 6 8 TRUE</code></pre>
<pre class="r"><code>df[df$M != 6,] # selects all rows that do not contain 6 in column named M</code></pre>
<pre><code>##    M  N     L
## a  2 34  TRUE
## b  3  3 FALSE
## d  3  3 FALSE
## e 34  3  TRUE</code></pre>
<pre class="r"><code>df[df$L==T,] # selects all rows where L is TRUE (T)</code></pre>
<pre><code>##    M  N    L
## a  2 34 TRUE
## c  6  8 TRUE
## e 34  3 TRUE</code></pre>
<p>What if we have duplicated rows or elements in our data frame or vector (and we want to get rid of them)?</p>
<pre class="r"><code>?duplicated #  determines which elements of a vector or data frame are duplicates of elements with smaller subscripts</code></pre>
<pre class="r"><code>df[!duplicated(df),] # removes second one of the duplicated rows from df, we have to use ! to negate logical evaluation</code></pre>
<pre><code>##    M  N     L
## a  2 34  TRUE
## b  3  3 FALSE
## c  6  8  TRUE
## e 34  3  TRUE</code></pre>
<pre class="r"><code>df[df$M &gt; median(df$N) &amp; df$M &lt; 25,] # selects rows where df$M value is &gt; median df$N AND df$M value &lt; 25</code></pre>
<pre><code>##   M N    L
## c 6 8 TRUE</code></pre>
<pre class="r"><code>df[df$M &gt; median(df$N) | df$M == 34,] # selects rows where df$M value is &gt; median df$N OR df$M value == 34</code></pre>
<pre><code>##    M N    L
## c  6 8 TRUE
## e 34 3 TRUE</code></pre>
<pre class="r"><code>sum(df$M[df$L==T]) # sums column df$M at rows where column &#39;L&#39; is TRUE (T)</code></pre>
<pre><code>## [1] 42</code></pre>
<p>A vector can be extracted by <code>$</code> and worked on:</p>
<pre class="r"><code>Mean.height &lt;- mean(my_tab$height)
Mean.height # Prints the answer</code></pre>
<pre><code>## [1] 177.6667</code></pre>
<p>New vectors can be bound into a data.frame:</p>
<pre class="r"><code>my_tab$weight &lt;- c(87, 96, 69) # Now there are 3 columns in my_tab
my_tab</code></pre>
<pre><code>## # A tibble: 3 x 3
##   name  height weight
##   &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1 Jim      187     87
## 2 Joe      190     96
## 3 Jill     156     69</code></pre>
<pre class="r"><code>my_tab$experiment &lt;- factor(&quot;A&quot;) # the 4th col contains a factor with a single level &quot;A&quot;
levels(my_tab$experiment) # prints the unique levels in a factor vector</code></pre>
<pre><code>## [1] &quot;A&quot;</code></pre>
</div>
</div>
<div id="matrix" class="section level1">
<h1>Matrix</h1>
<p>Matrix: a collection of data elements, which are all numeric, character, or logical.</p>
<p>Why use matrix? The choice between matrix and data.frame comes up only if you have data of the same type.</p>
<ul>
<li><p>The answer depends on what you are going to do with the data in data.frame/matrix. If it is going to be passed to other functions then the expected type of the arguments of these functions determine the choice.</p></li>
<li><p>Matrices are more memory efficient:</p></li>
</ul>
<pre class="r"><code>m &lt;- matrix(1:4, 2, 2)
d &lt;- as.data.frame(m)
object.size(m)</code></pre>
<pre><code>## 232 bytes</code></pre>
<pre class="r"><code>object.size(d)</code></pre>
<pre><code>## 864 bytes</code></pre>
<ul>
<li>Matrices are a necessity if you plan to do any linear algebra-type of operations.</li>
<li>Data frames are more convenient if you frequently refer to its columns by name (via the <code>$</code> operator).</li>
<li>Data frames are also better for reporting tabular data as you can apply formatting to each column separately.</li>
</ul>
<pre class="r"><code>n &lt;- matrix(rnorm(30), ncol = 5) 
dim(n)</code></pre>
<pre><code>## [1] 6 5</code></pre>
<pre class="r"><code>n</code></pre>
<pre><code>##            [,1]        [,2]        [,3]        [,4]       [,5]
## [1,] -1.2160675  0.84740534  1.20842344 -0.34168390  1.1998900
## [2,]  0.6039900 -0.06674691 -0.19685069 -0.04563796 -0.5418769
## [3,]  0.5640602 -1.00649154 -0.44335171  2.12457241 -1.5393276
## [4,] -1.0984260 -0.42315185 -0.02531080  1.90637023  0.7445494
## [5,]  1.6531665 -0.46435801  0.48469857 -1.03777245 -1.1902241
## [6,]  0.6047130  0.01709727 -0.05435574 -1.04590650 -0.9150436</code></pre>
<pre class="r"><code>exam # we created previously data.frame exam</code></pre>
<pre><code>##     name passed
## 1 Marina   TRUE
## 2  Allar  FALSE
## 3   Siim  FALSE
## 4   Mart  FALSE
## 5 Mailis   TRUE
## 6   Eiki   TRUE
## 7  Urmas   TRUE</code></pre>
<pre class="r"><code>class(exam)</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<pre class="r"><code>m &lt;- as.matrix(exam) # coerce data.frame with n,m dimension to a matrix with n,m dimension 
m</code></pre>
<pre><code>##      name     passed 
## [1,] &quot;Marina&quot; &quot;TRUE&quot; 
## [2,] &quot;Allar&quot;  &quot;FALSE&quot;
## [3,] &quot;Siim&quot;   &quot;FALSE&quot;
## [4,] &quot;Mart&quot;   &quot;FALSE&quot;
## [5,] &quot;Mailis&quot; &quot;TRUE&quot; 
## [6,] &quot;Eiki&quot;   &quot;TRUE&quot; 
## [7,] &quot;Urmas&quot;  &quot;TRUE&quot;</code></pre>
<pre class="r"><code>t(m) # transposes a matrix</code></pre>
<pre><code>##        [,1]     [,2]    [,3]    [,4]    [,5]     [,6]   [,7]   
## name   &quot;Marina&quot; &quot;Allar&quot; &quot;Siim&quot;  &quot;Mart&quot;  &quot;Mailis&quot; &quot;Eiki&quot; &quot;Urmas&quot;
## passed &quot;TRUE&quot;   &quot;FALSE&quot; &quot;FALSE&quot; &quot;FALSE&quot; &quot;TRUE&quot;   &quot;TRUE&quot; &quot;TRUE&quot;</code></pre>
<!-- Transpose a data frame with 1st column as factor -->
<!-- ```{r} -->
<!-- n <- exam$name -->
<!-- df <- as.data.frame(t(exam[,-1])) -->
<!-- colnames(df) <- n -->
<!-- df -->
<!-- ``` -->
<!-- ### Indexing matrices -->
<!-- Matrices are vectors with a dimension attribute and so all the vector forms of indexing can be used with a single index.  -->
<!-- ```{r} -->
<!-- m <- matrix(1:12, nrow = 3, dimnames = list(c("a","b","d"), LETTERS[1:4])) -->
<!-- m -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[1,]                 # the first row of matrix m -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[1, , drop = FALSE]  # is a 1-row matrix -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[, c(TRUE, FALSE, FALSE, TRUE)] # logical indexing -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[cbind(c(1,2,1), 3:1)] # matrix numeric index -->
<!-- ``` -->
<!-- ```{r} -->
<!-- ci <- cbind(c("a", "b", "a"), c("A", "C", "B")) -->
<!-- m[ci]                 # matrix character index -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[,-1]           # delete the first column of m -->
<!-- ``` -->
</div>
<div id="list" class="section level1">
<h1>List</h1>
<p>A list is an ordered collection of objects. Basically, in R you can shove any data structure into list. E.g. list may contain a combination of vectors, matrices, data frames, and even other lists, (poodles?). You can specify elements of the list by:</p>
<pre class="r"><code>mylist[[2]]</code></pre>
<pre><code>## [1] 53 51 25 67 66 41 62 42</code></pre>
<pre class="r"><code>mylist[[&quot;ages&quot;]]</code></pre>
<pre><code>## [1] 53 51 25 67 66 41 62 42</code></pre>
<pre class="r"><code>mylist$ages</code></pre>
<pre><code>## [1] 53 51 25 67 66 41 62 42</code></pre>
<p>As you can see all these above expressions give identical result</p>
<pre class="r"><code>all.equal(mylist[[2]], mylist[[&quot;ages&quot;]], mylist$ages)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<div id="indexing-lists" class="section level2">
<h2>Indexing lists</h2>
<p>Indexing by <code>[</code> is similar to atomic vectors and selects a list of the specified element(s). Both <code>[[</code> and <code>$</code> select a single element of the list (e.g. a single vector or data frame).</p>
<pre class="r"><code>mylist # here we go back to our mylist object</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## $ages
## [1] 53 51 25 67 66 41 62 42
## 
## $namez
## [1] &quot;Marina&quot; &quot;Allar&quot;  &quot;Siim&quot;   &quot;Mart&quot;   &quot;Mailis&quot; &quot;Eiki&quot;   &quot;Urmas&quot;</code></pre>
<pre class="r"><code>mylist[[1]]               # the first element of list mylist</code></pre>
<pre><code>## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>mylist[c(1, 3)]           # a list containing elements 1 and 3 of mylist</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## $namez
## [1] &quot;Marina&quot; &quot;Allar&quot;  &quot;Siim&quot;   &quot;Mart&quot;   &quot;Mailis&quot; &quot;Eiki&quot;   &quot;Urmas&quot;</code></pre>
<pre class="r"><code>mylist$ages               # the element of mylist named ages</code></pre>
<pre><code>## [1] 53 51 25 67 66 41 62 42</code></pre>
<p>Difference between using <code>[</code> and <code>[[</code> for subsetting a list: Square brackets <code>[</code> return subset of list as list:</p>
<pre class="r"><code>mylist[1]</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>class(mylist[1]) # returns list with one object</code></pre>
<pre><code>## [1] &quot;list&quot;</code></pre>
<pre class="r"><code>mylist[c(1,2)]</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## $ages
## [1] 53 51 25 67 66 41 62 42</code></pre>
<pre class="r"><code>class(mylist[c(1,2)]) # returns list with two objects</code></pre>
<pre><code>## [1] &quot;list&quot;</code></pre>
<p>Double square brackets <code>[[</code> return single list object/value:</p>
<pre class="r"><code>mylist[[1]] # returns list object </code></pre>
<pre><code>## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>class(mylist[[1]]) # logical vector in this case</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<p><strong>Warning</strong>: if you use double square brackets <code>[[</code> instead of <code>[</code> with index vector e.g. c(3,2) we get 2nd element from 3rd list object:</p>
<pre class="r"><code>mylist[[c(3,2)]]</code></pre>
<pre><code>## [1] &quot;Allar&quot;</code></pre>
<p>Be careful, if you won’t get <code>Error in ... : subscript out of bounds</code>, your script proceeds with this value and returns error in some of the next lines or returns wrong result.</p>
<!-- ### Recursive indexing into lists -->
<!-- ```{r} -->
<!-- z <- list(a = list(x = 9, y = "chello"), b = 1:5) # we create list named 'a' inside list 'z' -->
<!-- z -->
<!-- ``` -->
<!-- ```{r} -->
<!-- unlist(z) # look what happens if we simplify this list into vector... -->
<!-- ``` -->
<!-- ```{r} -->
<!-- z$a$x # what's a$x in list z -->
<!-- ``` -->
<!-- ```{r} -->
<!-- z[[c(1, 2)]] # we get second element of 1st element of list z -->
<!-- ``` -->
<!-- ```{r} -->
<!-- z[[c("a", "x")]] <- "piano" # here we replace z$a$x with "piano" -->
<!-- z -->
<!-- ``` -->
<p>Query names of list objects:</p>
<pre class="r"><code>names(mylist)</code></pre>
<pre><code>## [1] &quot;passed&quot; &quot;ages&quot;   &quot;namez&quot;</code></pre>
<p>Set/change names of list objects:</p>
<pre class="r"><code>names(mylist) &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)
names(mylist)</code></pre>
<pre><code>## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre>
<p>New name for nth list object:</p>
<pre class="r"><code>names(mylist)[2] &lt;- c(&quot;poodles&quot;)
names(mylist)</code></pre>
<pre><code>## [1] &quot;a&quot;       &quot;poodles&quot; &quot;c&quot;</code></pre>
</div>
<div id="output-from-statistical-tests" class="section level2">
<h2>Output from statistical tests</h2>
<p>Output of statistical tests in R is usually a list. Here we perform t test to compare two vectors a and b.</p>
<pre class="r"><code>a &lt;- rnorm(10) # random normal vector with mean 0
b &lt;- rnorm(10,2) # random normal vector with mean 2
t.result &lt;- t.test(a, b) # t test
str(t.result) # str() displays the internal structure of an R object</code></pre>
<pre><code>## List of 10
##  $ statistic  : Named num -4.56
##   ..- attr(*, &quot;names&quot;)= chr &quot;t&quot;
##  $ parameter  : Named num 12.3
##   ..- attr(*, &quot;names&quot;)= chr &quot;df&quot;
##  $ p.value    : num 0.000605
##  $ conf.int   : num [1:2] -3.17 -1.12
##   ..- attr(*, &quot;conf.level&quot;)= num 0.95
##  $ estimate   : Named num [1:2] -0.00607 2.1392
##   ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;mean of x&quot; &quot;mean of y&quot;
##  $ null.value : Named num 0
##   ..- attr(*, &quot;names&quot;)= chr &quot;difference in means&quot;
##  $ stderr     : num 0.47
##  $ alternative: chr &quot;two.sided&quot;
##  $ method     : chr &quot;Welch Two Sample t-test&quot;
##  $ data.name  : chr &quot;a and b&quot;
##  - attr(*, &quot;class&quot;)= chr &quot;htest&quot;</code></pre>
<pre class="r"><code>t.result$conf.int # extracts an element from the list</code></pre>
<pre><code>## [1] -3.166165 -1.124371
## attr(,&quot;conf.level&quot;)
## [1] 0.95</code></pre>
<pre class="r"><code>t.result$p.value # p.value</code></pre>
<pre><code>## [1] 0.000604614</code></pre>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
