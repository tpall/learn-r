---

---

# Find character strings 

Character strings can be matched and manipulated in R by using `regular expressions` in functions `grep`, `grepl`, `sub`, `gsub` and some others.
A [regular expression](https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html) is a pattern that describes a set of strings.

+ The fundamental building blocks are the regular expressions that match a single character. 
+ Most characters, including all letters and digits, are regular expressions that match themselves. 
+ The metacharacters in regular expressions are `. \ | ( ) [ { ^ $ * + ?`, whether these have a special meaning depends on the context. 
+ When matching any metacharacter as a regular character, precede it with a double backslash `\\`.
+ The caret `^` and the dollar sign `$` are metacharacters that respectively match the empty string at the beginning and end of a line.

To get the length of a text string (i.e. the number of characters in the string):
```{r}
x <- "reformation"
nchar(x)
```

`regexpr` returns position of 1st match and its length in a string:
```{r}
regexpr("o", x)
```
We can see that "o" is the 4th character in a string, with length 1 chracter (useBytes=T).

Lets try vector of strings. We want to return matching strings after underscore:
```{r}
y <- c("AreaShape_Area", "AreaShape_Perimeter", "AreaShape_MajorAxisLength", "Intensity_MADIntensity")
m <- regexpr("[[:alnum:]]*$", y) # to return start and length of match
m # to have have a look
```

What the heck we do with this list? With the help of `regmatches` command, you can return matching strings from `regexpr` call:
```{r}
regmatches(y, m) # to return matching strings
```

Tidyverse verbs to this task are `str_locate` and `str_extract`:
```{r}
library(stringr)
str_locate(y, "[[:alnum:]]*$") # if we want only start and end positions
```
Note that, `str_locate` returns more conveniently a matrix (instead of a list as in regexpr).

```{r}
str_extract(y, "[[:alnum:]]*$") # if we want actual strings
```
Seems nice and tidy.

To return multiple matches from the string, not just the first one, use `gregexpr`, which returns start position and length of every match:
```{r}
regmatches(y, gregexpr("Area", y)) # to return start position and length of every match
```

Please try to return positions of all upper case letters from y:
```{r}
regmatches(y, gregexpr("[[:upper:]]", y))
```

Tidyverse alternatives to `gregexpr` is `str_locate_all` and `str_extract_all`:
```{r}
str_locate_all(y, "e") # to locate all start positions and lengths of letter "e"
```

```{r}
str_extract_all(y, "[[:upper:]]") # to extract all upper case letters
```

`grep(pattern, x)` finds a pattern in x. Pattern -- character string containing a regular expressions (or exact character string for fixed = TRUE).

What really happens when we use `grep` or `grepl` on a vector x.
By using `grep()` with default arguments gets us vector of the indices of the matching items in x:
```{r}
grep("M", fruit$Gender) %>% head()
```

Using `grep(value = TRUE)` we get character vector containing the selected elements of x:
```{r}
grep("M", fruit$Gender, value = TRUE) %>% head()
```

However, by using `grepl` we get logical vector showing match for each element:
```{r}
grepl("M", fruit$Gender) %>% head()
```

Neat thing with the `grepl` is that it's versatile: you can use its result for subsetting or to count matches (TRUE = 1 and FALSE = 0):
```{r}
grepl("M", fruit$Gender) %>% sum
```

We can use `grepl` in `dplyr::filter` to subset data frame:
```{r}
library(dplyr)
fruit %>% filter(grepl("M", Gender)) %>% tbl_df
```


<!-- # Regular expression  -->
<!-- A pattern that we use to search in strings can be strict (like a nucleotide string "ACAGC") or "fuzzy" ("ACNGY" where N is any nucleotide and Y is C or T). To create fuzzy search patterns we use a system called **regular expression**. As regular expression is both hugely flexible and insanely complicated, we can only scratch the surface here. -->

<!-- + By default, regular expressions will match any part of a string.  -->
<!-- + `^` anchors the regular expression to the start of the string. -->
<!-- + `$` anchors the the regular expression to end of the string. -->

<!-- ```{r} -->
<!-- x <- c("apple", "ananas", "banana") -->
<!-- #replaces all a-s at the beginning of strings with e-s -->
<!-- str_replace_all(x, "^a", "e")  -->
<!-- #only replaces at the first occurence -->
<!-- str_replace(x, "a$", "e")  -->
<!-- #replaces a and the following character at the end of string -->
<!-- str_replace(x, "a.$", "e") -->
<!-- #replaces a-s or s-s at the end of string with e-s -->
<!-- str_replace_all(x, "(a|s)$", "e") -->
<!-- #replaces a-s or s-s anywhere in the string with e-s -->
<!-- str_replace_all(x, "a|s", "e") -->
<!-- ``` -->


<!-- To force to only match a complete string: -->
<!-- ```{r} -->
<!-- str_view(x, "^apple$") -->
<!-- ``` -->

<!-- **patterns that match more than one character:** -->

<!-- + `.` (dot): any character apart from a newline. -->
<!-- + `\\d`: any digit. -->
<!-- + `\\s`: any whitespace (space, tab, newline). -->
<!-- + `\[abc]`: match a, b, or c. -->
<!-- + `\[!abc]`: match anything except a, b, or c. -->

<!-- To create a regular expression containing `\d` or `\s`, you'll need to escape the `\` for the string, so you'll type `\\\\d` or `\\\\s`. -->

<!-- + `abc|d..f` will match either 'abc', or 'deaf'.  -->

<!-- ```{r} -->
<!-- str_view(c("abc", "xyz"), "abc | xyz") -->
<!-- ``` -->

<!-- If precedence gets confusing, use parentheses to make it clear what you want: -->
<!-- ```{r} -->
<!-- str_detect(c("grey", "gray"), "gr(e|a)y") -->
<!-- str_detect(c("grey", "gray"), "gr(?:e|a)y") #unequivocal vers. of the above -->

<!-- ``` -->

<!-- This beauty removes all numbers from text strings. Can be very useful. -->
<!-- ```{r} -->
<!-- y <- c("as1", "2we3w", "3e") -->
<!-- str_replace_all(y, "\\d", "")  -->
<!-- ``` -->

<!-- Even better, this removes everything except numbers. Yes, you may send us thank-you letters! -->
<!-- ```{r} -->
<!-- y<-c("as1", "2we3w", "3e") -->
<!-- str_replace_all(y, "[A-Za-z_]", "")  -->
<!-- ``` -->

