
# Tidy data

To standardize data analysis, you must start by standardizing data structure.
Tidy data arranges values so that the relationships between variables in a data set will parallel the relationship between vectors in R's storage objects. 
R stores tabular data as a data frame, a list of atomic vectors arranged to look like a table. 
Each column in the table is a vector. 
In tidy data, each variable in the data set is assigned to its own column, i.e., its own vector in the data frame.
As a result, you can extract all the values of a variable in a tidy data set by extracting the column vector that contains the variable, i.e. table1$cases. 
Because R does vector calculations element by element, it is fastest when you compare vectors directly side-by-side.

+	value is the result of a single measurement (167 cm). = cell
+	variable is what you measure (length, height), or a factor (sex, treatment).  = column
+	observation or data point is a set of measurements that made under similar conditions (John's height and weight measured on 23.04.2012). = row
+	Observational unit (who or what was measured): subject no. 1, etc. = 1st column
+	Type of observational unit: humans, mice, cell lysates, etc. = table

Tidy data: each value is in its own "cell", each variable in its own column, each observation in its own row, and each type of observational unit in its own table - useful for grouping, summarizing, filtering, and plotting.
In a tidy table the order of columns is: 

1. Observational unit 
2. Factors & everything that was not measured (values fixed at experimental planning stage) 
3. Measured Vars. 

Keeping the data in this form allows multiple tools to be used in sequence. 
NB! There are always more possible Vars in your data than were measured – do weight and height and get BMI as a bonus.

## Melt data into long format

First we load a bunch of **tidyverse** backages:
```{r error = FALSE, message=FALSE}
library(tidyr)
library(tibble)
library(reshape2)
library(dplyr)
library(readr)
```

`reshape2::melt(df)` - treats the variables that contain factors or strings as 'id.vars', which remain fixed; and melts all numeric columns.

We start by making a mock table:
```{r }
subject <- c("Toomas", "Anne", "Mari")
sex <- c("M", "F", "F")
control <- c(23, 31, 30)
experiment_1 <- c(34, 38, 36)
experiment_2 <- c(40, 42, 44)
df <- tibble(subject, sex, control, experiment_1, experiment_2)
df
```

Next we melt it by providing the df as the only argument to `reshape2::melt`:
```{r}
melt(df) # this gives identical result.
```

We can also use pipe operator (`%>%`):
```{r}
df_melted <- melt(df) %>% tbl_df # we further convert dataframe to a tibble by tbl_df
df_melted
```

Here we are more explicit about arguments to `melt()`. 
If you provide only `id.vars` or `measure.vars`, `R` will assume that all other variables belong to the argument that was not provided:
```{r}
melt(df, id.vars = c("subject", "sex"),   # all the variables to keep, but not split apart 
                        measure.vars = c("control", "experiment_1", "experiment_2"),
                     variable.name = "experiment", # Name of the destination column for factors that are taken from names of melted columns
                     value.name = "nr.of.counts" # name of the newly made column which contains the values
) %>% tbl_df
```


Alternatively we can use `tidyr::gather` to melt tables:

+ 1st argument (here `key = experiment`) names the key factor or character column, whose values will be the names of the columns, which are melted into a single column. 
+ The 2nd argument (here `value = value`) is the name of the resultant single column, which contains the values. 
+ The third argument (here `3:ncol(df)`) specifies the columns, which are melted into a single column; in the version `c(-subject, -sex)` every column except these 2 is melted. 

```{r}
gather(df, key = experiment, value = value, 3:ncol(df))
# df_melted3<-df %>% gather(experiment, value, 3:ncol(df)) works as well.
```


```{r}
gather(df, experiment, value, c(-subject, -sex))
```


## Cast melted table back into wide
While there is only one correct tidy long format, there exist several possible wide formats. 
Which one to choose depends on what you want to use the wide table for (i.e., on the specific statistical application)

```{r}
dcast(df_melted, subject + sex ~ value)
```
Uups!

```{r}
dcast(df_melted, subject + sex ~ variable)
```

`dcast()` starts with melted data and reshapes it into a wide format using a formula. 
The format is `newdata <- dcast(md, formula, FUN)` where md is the melted data. The formula takes the form:

+ `rowvar1 + rowvar2 + … ~ colvar1 + colvar2 + …`
+ `rowvar1 + rowvar2 + …` define the rows, and 
+ `colvar1 + colvar2 + …` define the columns.

> Important! the right-hand argument to the equation `~` is the column that contains the factor levels or character vectors that will be tranformed into column names of the wide table.

We can use `tidyr::spread()` as an alternative to `dcast()`.
Here **variable** is the factor or character column, whose values will be transformed into column names and **value** is the name of the column, which contains all the values that are spread into the new columns.

```{r}
spread(df_melted, key = variable, value = value)
```

## Separate 
Separate separates one column into many:

```{r}
df <- tibble(country = c("Albania"), disease.cases = c("80/1000"))
df
```

We want to separate `80/1000` at the slash. Default action of separate is to look at the any sequence of non-alphanumeric values:
```{r}
separate(df, disease.cases, into = c("cases", "thousand")) # works ok in this case!
```

We can supply regular expression, matching `/`:
```{r}
separate(df, disease.cases, into = c("cases", "thousand"), sep = "/") #match slash
separate(df, disease.cases, into = c("cases", "thousand"), sep = "\\W") # any non-alphanumeric
```


```{r}
separate(df, disease.cases, into=c("cases", "thousand"), sep = 2)
```

```{r}
separate(df, disease.cases, into=c("cases", "thousand"), sep = -6)
```

```{r}
df <- tibble(index = c(1, 2), taxon = c("Procaryota; Bacteria; Alpha-Proteobacteria; Escharichia", "Eukaryota; Chordata"))
separate(df, taxon, c('riik', 'hmk', "klass", "perekond"), sep = ';', extra = "merge", fill = "right")
```

Some special cases:
```{r}
df <- tibble(index = c(1, 2), taxon = c("Procaryota || Bacteria || Alpha-Proteobacteria || Escharichia", "Eukaryota || Chordata"))
separate(df, taxon, c("riik", "hmk", "klass", "perekond"), sep = "\\|\\|", extra = "merge", fill = "right")
```

```{r}
df <- tibble(index = c(1, 2), taxon = c("Procaryota.Bacteria.Alpha-Proteobacteria.Escharichia", "Eukaryota.Chordata"))
separate(df, taxon, c('riik', 'hmk', "klass", "perekond"), sep = '[.]', extra = "merge", fill = "right")
```


```{r}
df <- tibble(index = c(1, 2), taxon = c("Procaryota.Bacteria,Alpha-Proteobacteria.Escharichia", "Eukaryota.Chordata"))
separate(df, taxon, c('riik', 'hmk', "klass", "perekond"), sep = '[,\\.]', extra = "merge", fill = "right") 
# [,\\.] separates by dot or comma. Isn't that cool?
```


The companion FUN to separate is `unite()` - see help (if you should feel the need for it, which you probably won't).


## Five verbs of __dplyr__

NB! Check the data wrangling cheatsheet and help for further details

### `select()`
`select` selects, renames, and re-orders columns

To select columns from sex to value:
```{r}
df_melted
select(df_melted, sex:value)
```

To select just 2 columns and rename *subject* to *SUBJ*:
```{r}
select(df_melted, sex, value, SUBJ = subject)
```


To select all cols, except sex and value, and rename the *subject* col:
```{r}

select(df_melted, -sex, -value, SUBJ = subject)
```


### `mutate()`

Mutate adds new columns (and transmute creates new columns while losing the previous columns - see the cheatsheet and help)

Here we  firstly create a new column, which contains log-transformed values from the *value* column, and name it *log.value*. And secondly we create a new col *strange.value*, which contains the results of a really silly data transformation including taking a square root. 
```{r}
mutate(df_melted,
       log_value = log10(value), 
       strange_value = sqrt(value - log_value))
```

The same with transmute: note the dropping of some of the original cols, keeping the original *subject* col and renaming the *sex* column.
```{r}
transmute(df_melted, 
          subject, 
          gender = sex, 
          log_value = log10(value))
```


### `filter()`

Filter filters rows.

Keep rows that have sex level "M" and value >30.
```{r}
filter(df_melted, sex == "M" & value < 30)
filter(df_melted, sex == "M", value < 30)
```

Keep rows that have sex level not "M" (which in this case equals "F") or value > 30.
```{r}
filter(df_melted, sex != "M" | value <= 30)
```

Filtering with regular expression: we keep the rows where *subject* starts with the letter "T".
```{r}
library(stringr)
filter(df_melted, subject == str_subset(subject, "^T")) 
```

As you can see there are endless vistas here, open for a regular expression fanatic. I so wish I was one!

### `summarise()`

Summarise does just that.

Here we generate common summary statistics for our value variable. This is all right in a limited sort of way.
```{r}
summarise(df_melted, 
          MEAN = mean(value), 
          SD = sd(value),
          N = n())
```

To do something more exiting we must first group our observations by some facto(s) levels.

### `group_by()`

Groups values for summarising or mutating.

When we summarise by *sex* we will get two values for each summary statistic: for males and females. Ain't that sexy?!
```{r}
group_by(df_melted, sex) %>% 
  summarise(MEAN = mean(value), 
            SD = sd(value), 
            N = n())
```


Now we group first by *variable* and then inside each group again by *sex*. This is getting complicated ...
```{r}
group_by(df_melted, variable, sex) %>% 
  summarise(MEAN = mean(value), 
            SD = sd(value), 
            N = n())
```

Now we group first by sex and then by variable. Spot the difference!

```{r}
group_by(df_melted, sex, variable) %>% 
  summarise(MEAN = mean(value), 
            SD = sd(value),
            N= n())
```

Here we group and then mutate (meaning that the resulting table has as many rows -- but more column -- than the original table).
```{r}
group_by(df_melted, sex) %>% 
  mutate(norm_value = value/mean(value), 
         n2_value = value/sd(value))
```

Compare with a "straight" mutate to note the difference in values.
```{r}
mutate(df_melted, 
       norm_value = value/mean(value), 
       n2_val = value/sd(value))
```

