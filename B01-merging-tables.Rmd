---

---

# Merging tables

## Combine by rows and columns
Base R `rbind` and `cbind` **take in a sequence of vector, matrix or data-frame** and combine by rows or columns, respectively. Meaning that if you want to combine only data frames you have also option to use Hadleyverse's `dplyr::bind_rows` or `dplyr::bind_cols`. Otherwise, if playing around with vectors and/or matrices too, you have to stick with base R functions.  

Don't try to understand this excerpt from help: for `rbind` column names are taken from the first argument with appropriate names: colnames for a matrix, or names for a vector of length the number of columns of the result.

To illustrate combining two data.frames by rowwise we first subset `mtcars` dataset into two
mini dataframes:
```{r}
dim(mtcars)
df1 <- mtcars[1:2, c(1,4)]
df1
```

```{r}
df2 <- mtcars[11:13, c(1,4)]
df2
```

Combine by rows using base R `rbind`, **columns need to match**:
```{r}
rbind(df1, df2)
```

Hadleyverse's verb to perform this task is `bind_rows`, however note that `bind_rows` (`bind_cols`) **needs data frames** (NO vectors or matrices!): 
```{r}
library(dplyr)
bind_rows(df1, df2) 
```

Neat feature of the `bind_rows` function is that when you supply a column name with the `.id=` argument, a new column is created to link each row to its original data frame:
```{r}
bind_rows(df1 = df1, df2 = df2, .id = "id")
```

**Columns don't need to match** when row-binding using `bind_rows`, missing values are filled with `NA`-s:
```{r}
bind_rows(df1 = df1, 
          df2 = mtcars[11:13, c(1,4,6)], 
          df3 = mtcars[4:6, c(1,6)],
          .id = "id")
```

If you have **data frames or tibbles in a list**, then you can bind them rowwise into one data frame. 

Here we first create list with two dataframes:
```{r}
df_list <- list(df1, df2)
df_list
```

`do.call(rbind, my_list_of_dataframes)` is base R solution to this task, but you need data frames with same column names:
```{r}
do.call(rbind, df_list) # bind dataframes in list by rows
```

`bind_rows` argument can also be a **list of data frames**, and again, columns are matched by name, and any values that don't match will be filled with `NA`-s:
```{r}
df_list2 <- list(df1 = df1, 
          df2 = mtcars[11:13, c(1,4,6)], 
          df3 = mtcars[4:6, c(1,6)])
bind_rows(df_list2, .id = "id")
```

Combining two vectors of same length columnwise results in matrix (similar to rbind):
```{r}
cbind(letters[1:5], 1:5)
```

When combining vectors with different lengths, the shorter one is recycled:
```{r}
m <- cbind(1, 1:7) # the '1' (= shorter vector) is recycled
m
```

Columns can be inserted by specifing order of colums in the index:
```{r}
cbind(m, 8:14)[, c(1, 3, 2)] # insert a column
```

When the arguments consist of a mix of matrices and vectors the number of rows of the result is determined by the number of rows of the matrix arguments:
```{r}
cbind(1:7, matrix(11:16, nrow = 3)) # vector is subset -> warning
```

When column-binding, rows are matched by position, not value so all data frames must have the same number of rows.
```{r}
# bind_cols(1:4, 4:8)
```


## Joins
To illustrate merging, let's consider [following itinerary](http://www.ester.ee/record=b2697405*est). 
Here we have day of travel and city.
```{r}
itinerary <- data.frame(day = c(1:6), city = c("Teheran", "Qom", "Esfahan", "Persepolis", "Shiraz", "Bandar"))
head(itinerary)
```

Next table we have hotels with addresses for each city.
```{r}
lodging <- data.frame(city = c("Teheran", "Qom", "Esfahan", "Persepolis", "Shiraz", "Bandar"), hotel = c("Firouzeh Hotel", "Aria Hotel", "Amir Kabir Hotel", "Sita Aukh Guest House", "Anvari Hotel", "Bolivar Inn"), address = c("Dowlat Abad Alley", "Astane Square", "Chahar Bagh Abbasi Street", "Tume Junn Mohammad Street", "Anvari Street", "Abuzar Street"))
head(lodging)
```

<!-- #### base::merge -->
<!-- We use base R function `merge` to join these tables by explicitly specifying column/variable 'by = "city"' (e.g. in order to guarantee consistent behaviour when number of columns in our data frame can vary in our script). -->
<!-- By default, `merge` joins data frames on the columns with names they both have. -->

<!-- ```{r} -->
<!-- merge(itinerary, lodging, by = "city", sort = FALSE) # don't sort on 'by' column -->
<!-- ``` -->

<!-- If we choose only rows 1 through 3 from table `lodging`? -->
<!-- ```{r} -->
<!-- merge(itinerary, lodging[1:3,], by = "city", sort = FALSE)  -->
<!-- ``` -->

<!-- If we choose only rows 2 through 5 from table `itinerary`? -->
<!-- ```{r} -->
<!-- merge(itinerary[2:5,], lodging, by = "city", sort = FALSE)  -->
<!-- ``` -->

<!-- In our simple example we always have only matching rows in our results. -->

<!-- #### dplyr::inner_join and friends -->
We use `dplyr` `_join` functions to join these tables by explicitly specifying column/variable 'by = "city"' (e.g. in order to guarantee consistent behaviour when number of columns in our data frame can vary in our script).

```{r include=FALSE}
x <- as.character(bquote(itinerary))
y <- as.character(bquote(lodging))
```


Returns all rows from `r paste(x)` where there are matching values in `r paste(x)`, and all columns from `r paste(x)` and `r paste(y)`.
```{r}
library(dplyr)
inner_join(itinerary, lodging, by = "city")
```

```{r}
inner_join(itinerary[2:5,], lodging[1:3,], by = "city") 
```

Returns all rows from `r paste(x)`, and all columns from `r paste(x)` and `r paste(y)`. Rows in `r paste(x)` with no match in `r paste(y)` will have NA values in the new columns.
```{r}
left_join(itinerary[2:5,], lodging, by = "city") 
```

```{r}
left_join(itinerary, lodging[2:5,], by = "city") 
```

Returns all rows from `r paste(y)`, and all columns from `r paste(x)` and `r paste(y)`. Rows in `r paste(y)` with no match in `r paste(x)` will have NA values in the new columns. 
```{r}
right_join(itinerary, lodging[2:5,], by = "city") 
```

Returns all rows from `r paste(x)` where there are matching values in `r paste(y)`, keeping just columns from `r paste(x)`.
```{r}
semi_join(itinerary, lodging[2:4,], by = "city") # returns only cols from itinerary 
```

Return all rows from `r paste(x)` where there are not matching values in `r paste(y)`, keeping just columns from `r paste(x)`.
```{r}
anti_join(itinerary[1:3,], lodging[3:4,], by = "city") # returns cols fron itinerary where there are no matching values in lodging 
```

Return all rows and all columns from both `r paste(x)` and `r paste(y)`. Where there are not matching values, returns NA for the one missing.
```{r}
full_join(itinerary[1:3,], lodging[3:6,], by = "city") 
```
