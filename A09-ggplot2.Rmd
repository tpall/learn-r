---

---

# ggplot2
**ggplot2** is an R package for producing statistical graphics based on the grammar of graphics (hence the gg!).

+ **ggplot2 works iteratively** -- you start with a layer showing the raw data and then add layers of geoms, annotations, and statistical summaries.

To compose plots, you have to supply minimally:

+ **Data** that you want to visualise and **aes**thetic mappings -- what's on x-axis, what's on y-axis, and how to you want to group and color your data.
+ **Layers** made up of **geom**etric elements: points, lines, boxes, etc. 

You can further adjust your plot:

+ by adding **statistical summaries** of your raw data.
+ using **scale**s to redraw a legend or axes.
+ using **facet**ing to break up the data into subsets for display.
+ using **theme**s which control plot features like the font size 
  and background colour.

ggplot2 is different from base graphics:

+ Plots created by base graphics appear only on the screen and you cannot assign plot to an object for later use. Everything is created in place.
+ You can only draw on top of the plot, you cannot modify or delete existing content.

That was theory, you can read more from [ggplot2-book](https://github.com/hadley/ggplot2-book), this is where rubber meets the road:
```{r}
library(ggplot2) # load ggplot2 library
library(dplyr) # dplyr is necessary for piping operator and for some data munging
```

We use ggplot2 builtin dataset `mpg` with fuel economy data from 1999 and 2008 for 38 models of car:
```{r}
mpg
```
Key variables in `mpg` dataset are `displ` -- engine displacement (L), `cyl` -- number of cylinders, `cty` -- city miles per gallon, `hwy` -- highway miles per gallon.

Simple scatterplot to explore relationship between fuel consumption in city traffick (cty) and engine size (displ) is created like this:
```{r}s
ggplot(mpg, aes(displ, cty)) + geom_point()
```
**Notice that**: in ggplot first two unnamed arguments to `aes()` are `x` and `y`, so we can easily skip `x =` and `y =` to reduce typing.

To illustrate layerwise plot creation in ggplot:
```{r}
p <- ggplot(data = mpg) # first add data
p <- p + aes(x = cty, y = hwy) # add aesthetics
p <- p + geom_point() # add geom, specifying plot type 
p <- p + stat_smooth(method = "lm") # add statistical summary
p # display plot
```
The **point geom is used to create scatterplots**.

Of course, same result is easily achieved by this oneliner:
```{r, eval=FALSE}
ggplot(mpg, aes(cty, hwy)) + geom_point() + stat_smooth(method = "lm")
```

Differently from R base graphics, where histogram is drawn by special command, ggplot specifies the type of plot by geoms:
```{r}
df <- tibble(x = rnorm(10000)) # We create tibble with 10000 random numbers from normal distr.
ggplot(df, aes(x)) + # histograms 
  geom_histogram() # we specify geom histogram 
```

ggplot says: `stat_bin()` using `bins = 30`. Pick better value with `binwidth`, also help file notes that `the default is to use bins bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data`. OK, Messy Goes to Okido, lets try:
```{r}
ggplot(df, aes(x)) + geom_histogram(binwidth = 0.1)
```

Alternatively, you can specify the number of bins (and send some hidden messages along with your data):
```{r}
ggplot(df, aes(x)) + geom_histogram(bins = 5)
```

For some more practice, lets recreate Tartu Marathon 2013 histogram:
```{r}
library(lubridate)
load("data/Tartu_Maraton_2013.RData")
```

```{r}
tm_2013 %>% mutate(Aeg = unclass(as.duration(hms(Aeg)))/3600) %>% 
  ggplot(aes(Aeg)) + 
  geom_histogram(binwidth = 1/12) # binwidth ~5 minutes
```

These were histograms with counts on y-axis, but we may want to plot (kernel) density instead:
```{r}
ggplot(df, aes(x)) + geom_density()
```

```{r}
ggplot(df, aes(x, ..density..)) + geom_histogram()
```

Kernel density plot and histogram together: 
```{r}
ggplot(df, aes(x, ..density..)) + 
  geom_histogram(binwidth = 0.1) +
  geom_density()
```

```{r}
p <- ggplot(df, aes(x)) + 
  geom_histogram(aes(y = ..density..), # note that we specify density here, 
                 binwidth = 0.1, 
                 fill = "white", color = "black") +
  geom_density()
p # we disrected plot to object
```

We can add vertical line, denoting mean, to our histogram like this:
```{r}
p + geom_vline(aes(xintercept = mean(x)), color = "red", linetype = "dashed", size = 1) 
```

Colored/grouped density plots:
```{r}

```

