<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Ülo Maiväli1, Taavi Päll2,3" />


<title>Reproducible Data Analysis in R</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-1.1/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-1.1/highlight.js"></script>
<link href="site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Reproducible Data Analysis in R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
    Home
  </a>
</li>
<li>
  <a href="about.html">
    <span class="fa fa-info"></span>
     
    About
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Reproducible Data Analysis in R</h1>
<h4 class="author"><em>Ülo Maiväli<sup>1</sup>, Taavi Päll<sup>2,3</sup></em></h4>

</div>

<div id="TOC">
<ul>
<li><a href="#r-objects">R objects</a></li>
<li><a href="#data-structures">Data structures</a></li>
<li><a href="#selecting-by-index">Selecting by index</a></li>
<li><a href="#vectors">Vectors</a></li>
<li><a href="#data-frame">Data frame</a></li>
<li><a href="#matrix">Matrix</a></li>
<li><a href="#list">List</a></li>
<li><a href="#base-graphics">Base graphics</a></li>
<li><a href="#getting-data-in-and-out-of-r">Getting data in and out of R</a></li>
<li><a href="#tidy-data">Tidy data</a></li>
<li><a href="#ggplot2">ggplot2</a></li>
<li><a href="#merging-tables">Merging tables</a></li>
<li><a href="#find-character-strings">Find character strings</a></li>
<li><a href="#date-and-time-classes">Date and time classes</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#reports-with-rmarkdown">Reports with rmarkdown</a></li>
</ul>
</div>

<p><sup>1</sup><a href="http://www.tuit.ut.ee/en">Institute of Technology, University of Tartu</a>, <sup>2</sup><a href="http://www.tymri.ut.ee">Institute of Molecular and Cell Biology, University of Tartu</a>, <sup>3</sup><a href="http://www.ttu.ee/faculty-of-science/department-of-gene-technology/">Department of Chemistry and Biotechnology, Tallinn University of Technology</a></p>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>R is <a href="https://en.wikipedia.org/wiki/Functional_programming">functional programming language</a> and <a href="https://www.r-project.org/about.html">statistical environment</a>. R statistical language is based on <strong>S</strong> (R is <a href="https://en.wikipedia.org/wiki/GNU">GNU</a> S). S was developed by John Chambers (mainly), Rick Becker and Allan Wilks of Bell Laboratories. The first version of S saw light in 1976. The aim of the S language was “to turn ideas into software, quickly and faithfully”. R was initially written by Robert Gentleman and Ross Ihaka at the University of Auckland Statistics Department. The project is relatively new, conceived in 1992, with an initial version released in 1994 and a first stable beta version in 2000.</p>
<div id="r-pros" class="section level3">
<h3>R pros</h3>
<ul>
<li>Just about any type of data analysis can be done in R.</li>
</ul>
<div class="figure" style="text-align: center">
<img src="index_files/figure-html/plotcranpackages-1.png" alt="There are about eight packages supplied with the R distribution. The number of available CRAN packages grows exponentially, featuring 11396 available packages as of 2017-09-08 ." width="672" />
<p class="caption">
There are about eight packages supplied with the R distribution. The number of available CRAN packages grows exponentially, featuring 11396 available packages as of 2017-09-08 .
</p>
</div>
<ul>
<li>R contains advanced statistical routines not yet available in other packages @ref(fig:plotcranpackages).<br />
</li>
<li>R provides reproducibility in data analysis, and yet is very flexible (everyone can write their parallel solution to any problem).</li>
<li>R has the most comprehensive feature set available to visualize complex data.</li>
<li>The results of any analytic step can easily be saved, manipulated, and used as input for additional analyses.</li>
<li>R can import/export data from text files, pdf-s, database-management systems, statistical packages, and specialized data stores.</li>
<li>R can also access data directly from web pages, social media sites, and a wide range of online data services.<br />
</li>
<li>R provides a natural language for quickly programming recently published methods.<br />
</li>
<li>Most operations in R are much quicker than manipulating tables in MS Excel or LO Calc.</li>
<li>R has a large community of users – most questions can be quickly answered by googling.<br />
</li>
<li>For a non-programmer R is easier to learn than Python, etc. (Ülo: most users do not program in R, and don’t need to.)</li>
</ul>
<p>A key reason that R is a good thing is because it is a language. The power of language is abstraction. The way to make abstractions in R is to write functions <a href="http://www.burns-stat.com/pages/Tutor/R_inferno.pdf">(Burns, 2011)</a>.</p>
</div>
<div id="r-cons-none-is-the-deal-breaker" class="section level3">
<h3>R cons (none is the deal breaker):</h3>
<ul>
<li>With R you must know exactly, what you want to do – in terms of your immediate atomic goals in data massage, methods of statistical analysis, and the overall strategy of analysis.</li>
<li>It is <strong>like getting your own keys to daddy’s F-16 fighter plane</strong>. Get a setting wrong <strong>and boom!</strong></li>
</ul>
<div class="figure">
<img src="http://nkpzz1l56ai473pu632f0nui.wpengine.netdna-cdn.com/wp-content/uploads/2015/01/amazing-model-airplane-remote-control-replica-of-dutch-orange-f-16-fighter-jet-672x377.jpg" alt="Unlike your daddy’s F-16, it’s similarly annoying but safe to crash your R session. Image: The Brofessional" />
<p class="caption">Unlike your daddy’s F-16, it’s similarly annoying but safe to crash your R session. Image: <a href="http://www.thebrofessional.net/guy-builds-incredible-working-replica-dutch-f-16-military-fighter-jet-scratch/">The Brofessional</a></p>
</div>
<ul>
<li>R has uneven inbuilt help – but a lot of users who are willing to help you.</li>
</ul>
</div>
<div id="alternatives" class="section level3">
<h3>Alternatives</h3>
<p>You can prepend “Some say, ..” to these statements:</p>
<ul>
<li>MS Excel might be better for inputting data into tables.</li>
<li>Graphpad Prism is much more foolproof and easier to use as a statistical tool (but has limited functionality). There is a free web version of Graphpad – <a href="http://www.graphpad.com/quickcalcs/">check it out</a>.<br />
</li>
<li>Python is more widely spread as a general purpose programming language – it is also arguably better in working with external databases (which we won’t).</li>
</ul>
</div>
</div>
<div id="install-r" class="section level2">
<h2>Install R</h2>
<p>As you can guess, it’s very straightforward: download and install <strong>R</strong> for your operation system from <a href="https://cran.r-project.org/" class="uri">https://cran.r-project.org/</a>.</p>
</div>
<div id="install-rstudio" class="section level2">
<h2>Install RStudio</h2>
<blockquote>
<p>RStudio is a set of integrated tools designed to help you be more productive with R. It includes a console, syntax-highlighting editor that supports direct code execution, as well as tools for plotting, history, debugging and workspace management.</p>
</blockquote>
<p>Download and install <strong>RStudio</strong> from <a href="https://www.rstudio.com/" class="uri">https://www.rstudio.com/</a></p>
<div class="figure">
<img src="graphs/RStudio.png" alt="RStudio window layout. The panel in the upper right contains your workspace. Any plots that you generate will show up in the panel in the lower right corner. The panel on the upper left corner is your source file. The panel on the lower left corner is the console." />
<p class="caption">RStudio window layout. The panel in the upper right contains your workspace. Any plots that you generate will show up in the panel in the lower right corner. The panel on the upper left corner is your source file. The panel on the lower left corner is the console.</p>
</div>
<div id="setup-your-project" class="section level3">
<h3>Setup your project</h3>
<p>To get started using R via RStudio it is suggested to organise your work to projects. Each project has their own working directory, workspace, history, and source documents. In order to create a new project:</p>
<ol style="list-style-type: decimal">
<li>Open RStudio</li>
<li>Select <code>Project</code> menu from the <strong>upper right corner</strong> and either create <code>New Project</code> or <code>Open Project</code>. <a href="https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects">RStudio support page for using projects</a>.</li>
</ol>
<div class="figure">
<img src="graphs/RStudio_NewProject.png" alt="New Project menu" />
<p class="caption">New Project menu</p>
</div>
<p>When you open a project in RStudio several actions are taken:</p>
<ul>
<li>A fresh new R session is started</li>
<li>The current working directory is set to the project directory.</li>
<li>Previously edited source documents are restored into editor tabs.</li>
<li>The <code>.Rprofile</code> file in the project’s main directory (if any) is sourced by R, also the <code>.RData</code> and <code>.Rhistory</code> files in the project’s main directory are loaded.</li>
<li>Other RStudio settings (e.g. active tabs, splitter positions, etc.) are restored to where they were the last time the project was closed.</li>
</ul>
</div>
<div id="folder-structure-of-r-project" class="section level3">
<h3>Folder structure of R project</h3>
<ul>
<li>Create a directory structure to separate R code, data, reports, and output</li>
<li><strong>Treat data as read-only</strong>: do data-munging in R code, but always start with the source data</li>
<li><strong>Consider output figures and tables as disposable</strong>: the data plus the R script is the canonical source</li>
<li><strong>Keep function definitions and applications code separately</strong></li>
</ul>
<div class="figure">
<img src="graphs/RProject_folders.png" alt="Example folder structure in R project" />
<p class="caption">Example folder structure in R project</p>
</div>
<pre class="r"><code>MyProject/
  |-- src/ # contains R script
  |-- data/ # contains raw data, read only
  |-- lib/ # contains R functions (R scipts defining functions)
  |-- graphs/ # output graphs</code></pre>
<p>Where are we?</p>
<pre class="r"><code>getwd() # Prints the current working directory</code></pre>
<pre><code>## [1] &quot;/Users/taavi/Dropbox/R course/LearnR&quot;</code></pre>
<p>But if you want set working directory by your self:</p>
<pre class="r"><code># Sets working directory, into which things are saved by default and from which stuff is imported
setwd(&quot;/Users/ulomaivali/Dropbox/&quot;) # mac
setwd(&quot;C:/Users/ulomaivali/Dropbox/&quot;) # windows
setwd(&quot;~/Dropbox/R course/&quot;) # linux, ~/ references to user home directory</code></pre>
</div>
<div id="getting-help" class="section level3">
<h3>Getting help</h3>
<p>You can get help for individual functions from R Documentation at the program’s command prompt by preceding R command with ?.</p>
<pre class="r"><code>?getwd()</code></pre>
<p>Package documentation with list of all included functions can be accessed like this:</p>
<pre class="r"><code>library(help = &quot;readxl&quot;)</code></pre>
<p>In RStudio if you type the name of the function without parentheses eg. <code>scale</code> and hit the <code>F1</code> key, the help page of the function is shown in the lower right panel.</p>
</div>
<div id="tips-and-tricks" class="section level3">
<h3>Tips and tricks</h3>
<ul>
<li>RStudio: <code>Help</code> menu contains section <code>Cheatsheets</code>.</li>
<li><code>Ctrl + Enter</code> (<code>Cmd + Enter</code> on a Mac) in RStudio: sends the current line (or current selection) from the editor to the console and runs it.</li>
<li><code>Alt + -</code> in RStudio: gives assignment operator <code>&lt;-</code>.</li>
<li><code>Ctrl + Shift + M</code> (Shift + Cmd + M on a Mac) in RStudio: gives piping operator <code>%&gt;%</code>.</li>
<li><code>Ctrl + Shift + C</code> (Ctrl + Cmd + C on a Mac) in RStudio: comment/uncomment lines.</li>
<li><a href="https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf">RStudio cheat sheet with more tips</a>.</li>
<li>R is case-sensitive.</li>
<li>Enter commands one at a time at the console or run a set of commands from the editor.</li>
<li>Object names and column names cannot begin with a number.</li>
<li>No spaces in object names! (use <code>.</code> or <code>_</code> or <code>-</code>).</li>
<li>Using the backslash <code>\</code> in a pathname on Windows – R sees the <code>\</code> as an escape character. <code>setwd(&quot;C:\mydata&quot;)</code> generates an error. Use <code>setwd(&quot;C:/mydata&quot;)</code> or <code>setwd(&quot;C:\\mydata&quot;)</code> instead.</li>
</ul>
</div>
</div>
<div id="installing-packages" class="section level2">
<h2>Installing packages</h2>
<p>To install package, run following command in your R console:</p>
<pre class="r"><code>install.packages(&quot;packagename&quot;) # eg use &quot;ggplot2&quot; as packagename</code></pre>
<p>RStudio offers also point-and-click style package install option: <img src="graphs/RStudio_package.install.png" alt="Install packages via RStudio GUI" /></p>
<p>You will not be able to use a package until you load it with the <code>library()</code> function. After you have installed the packages, you can load any of the packages into your current R session with the <code>library()</code> command, e.g.</p>
<pre class="r"><code># Load library/package tidyr
library(tidyr)</code></pre>
<p>The <code>library(tidyr)</code> command makes available all the funtions in the tidyr package.</p>
<blockquote>
<p>R packages are collections of one or more functions with clearly specifed task.</p>
</blockquote>
<p>For example, the tidyr package contains following 41 functions:</p>
<pre class="r"><code>library(tidyr)
ls(&quot;package:tidyr&quot;)</code></pre>
<pre><code>##  [1] &quot;%&gt;%&quot;             &quot;complete&quot;        &quot;complete_&quot;      
##  [4] &quot;crossing&quot;        &quot;crossing_&quot;       &quot;drop_na&quot;        
##  [7] &quot;drop_na_&quot;        &quot;expand&quot;          &quot;expand_&quot;        
## [10] &quot;extract&quot;         &quot;extract_&quot;        &quot;extract_numeric&quot;
## [13] &quot;fill&quot;            &quot;fill_&quot;           &quot;full_seq&quot;       
## [16] &quot;gather&quot;          &quot;gather_&quot;         &quot;nest&quot;           
## [19] &quot;nest_&quot;           &quot;nesting&quot;         &quot;nesting_&quot;       
## [22] &quot;population&quot;      &quot;replace_na&quot;      &quot;separate&quot;       
## [25] &quot;separate_&quot;       &quot;separate_rows&quot;   &quot;separate_rows_&quot; 
## [28] &quot;smiths&quot;          &quot;spread&quot;          &quot;spread_&quot;        
## [31] &quot;table1&quot;          &quot;table2&quot;          &quot;table3&quot;         
## [34] &quot;table4a&quot;         &quot;table4b&quot;         &quot;table5&quot;         
## [37] &quot;unite&quot;           &quot;unite_&quot;          &quot;unnest&quot;         
## [40] &quot;unnest_&quot;         &quot;who&quot;</code></pre>
</div>
<div id="r-repositories" class="section level2">
<h2>R repositories</h2>
<p>R packages are available from 3 major repositories:</p>
<ol style="list-style-type: decimal">
<li><strong>CRAN</strong></li>
</ol>
<pre class="r"><code>install.packages(&quot;ggplot2&quot;)</code></pre>
<ol start="2" style="list-style-type: decimal">
<li><strong>Bioconductor</strong> <a href="https://www.bioconductor.org/" class="uri">https://www.bioconductor.org/</a></li>
</ol>
<pre class="r"><code># First run biocLite script fron bioconductor.org
source(&quot;https://bioconductor.org/biocLite.R&quot;)  
# use &#39;http&#39; in url if &#39;https&#39; is unavailable. 
biocLite(&quot;GenomicRanges&quot;, suppressUpdates=TRUE)</code></pre>
<ol start="3" style="list-style-type: decimal">
<li><strong>GitHub</strong> <a href="https://github.com/" class="uri">https://github.com/</a></li>
</ol>
<pre class="r"><code>library(devtools)
install_github(&quot;ramnathv/slidify&quot;) # ramnathv is the user, slidify the package.
# or alternatively, should we want only to install the missing package while avoiding any side effects that might result from loading the entire package, we use: 
devtools::install_github(&quot;ramnathv/slidify&quot;)</code></pre>
<p>or</p>
<pre class="r"><code>install.packages(&quot;githubinstall&quot;)
library(githubinstall)
githubinstall(&quot;AnomalyDetection&quot;)</code></pre>
<p>also</p>
<ol start="4" style="list-style-type: decimal">
<li><code>library(remotes)</code>: functions to install R packages from GitHub, Bitbucket, git, svn repositories, URL-s (also devtools package has functions to install packages from these resources).</li>
</ol>
<blockquote>
<p>NB! As we want to add extra data munging power to the base R, in our course, every R session should start with loading these packages:</p>
</blockquote>
<pre class="r"><code>library(dplyr)
library(tidyr)
library(reshape2)
library(ggplot2)
library(tibble)</code></pre>
<div id="search-for-r-functions" class="section level3">
<h3>Search for R functions</h3>
<p>To find a function containing the word “confusion” in any package:</p>
<pre class="r"><code>RSiteSearch(&quot;confusion&quot;, restrict = &quot;functions&quot;) # this function is avaible from base R</code></pre>
<p>will search online to find matches and will open a web browser to display the results.</p>
<p>The function <code>apropos()</code> will search any <strong>loaded</strong> R packages for a given term. To find functions for creating a confusion matrix within the currently loaded packages:</p>
<pre class="r"><code>library(dplyr) # lets load package caret
apropos(&quot;select&quot;) #  search loaded R packages for a word &#39;confusion&#39;</code></pre>
<pre><code>##  [1] &quot;.selectSuperClasses&quot; &quot;MethodsListSelect&quot;   &quot;select&quot;             
##  [4] &quot;select_&quot;             &quot;select_all&quot;          &quot;select_at&quot;          
##  [7] &quot;select_if&quot;           &quot;select_var&quot;          &quot;select_vars&quot;        
## [10] &quot;select_vars_&quot;        &quot;select.list&quot;         &quot;selectMethod&quot;       
## [13] &quot;selectSuperClasses&quot;  &quot;socketSelect&quot;        &quot;sql_select&quot;</code></pre>
<pre class="r"><code>help(&quot;mutate&quot;) # same as ?</code></pre>
<pre><code>## Help on topic &#39;mutate&#39; was found in the following packages:
## 
##   Package               Library
##   plyr                  /Library/Frameworks/R.framework/Versions/3.4/Resources/library
##   dplyr                 /Library/Frameworks/R.framework/Versions/3.4/Resources/library
## 
## 
## Using the first match ...</code></pre>
</div>
<div id="common-mistakes-in-loading-packages" class="section level3">
<h3>Common mistakes in loading packages</h3>
<ul>
<li>Using the wrong case: help(), Help(), and HELP() - only the first will work.</li>
<li>Forgetting quotation marks – <code>install.packages(&quot;gclus&quot;)</code> works.</li>
<li>Using a function from a package that’s not loaded: library(“foo”)</li>
<li>Forgetting to include the parentheses in a function call. For example <code>help()</code> works, but <code>help</code> doesn’t.</li>
</ul>
<blockquote>
<p>Entering function name without parentheses returns function internals. Very useful!</p>
</blockquote>
<pre class="r"><code>ruut  &lt;- function(x) x^2 # lets define function
ruut # display function internals</code></pre>
<pre><code>## function(x) x^2</code></pre>
<pre class="r"><code>ruut(3) # run function</code></pre>
<pre><code>## [1] 9</code></pre>
<!-- Even if there are no **function arguments**, you still need the `()` appended to function name to execute function. -->
<!-- ```{r} -->
<!-- twoplustwo <- function() 2+2 # here we define our function -->
<!-- twoplustwo # lets see whats in it -->
<!-- twoplustwo() # run function -->
<!-- ``` -->
</div>
</div>
<div id="r-objects" class="section level1">
<h1>R objects</h1>
<p>An R object is anything that can be assigned a value (data, functions, graphs, analytic results, and more). Every object has a class attribute telling R how to handle it. Common R data structures are: vectors (numerical, character, logical), matrices, data frames, and lists. The basic data structure in R is the vector.</p>
<div id="class-of-object" class="section level3">
<h3>Class of object</h3>
<p>An R vector is characterized by a mode that describes its contents: logical, numeric, complex, character.</p>
<p>An R data structure is characterized by a class that describes its structure: matrix, array, factor, time-series, data frame, and list.</p>
<p>To determine the class of your object use <code>class(object)</code> - prints the class attribute of an object.</p>
<pre class="r"><code>myobject &lt;- list(1,&quot;a&quot;)
class(myobject) # gives the data structure of object &#39;myobject&#39;</code></pre>
<pre><code>## [1] &quot;list&quot;</code></pre>
</div>
<div id="r-expressions" class="section level3">
<h3>R expressions</h3>
<p>Syntactically correct R expressions (<code>y &lt;- x * 10</code>) will be referred to as statements. R uses the symbol <code>&lt;-</code> for assignments, rather than the typical <code>=</code> sign.</p>
<p>Here we create a vector named <code>x</code> containing five random numbers from a standard normal distribution.</p>
<pre class="r"><code>x &lt;- rnorm(5)
x</code></pre>
<pre><code>## [1]  1.3761634  0.2861325 -0.8516899  1.7341453 -1.7049719</code></pre>
<pre class="r"><code>y &lt;- x * 10 # here we multiply numeric vector x by 10
y</code></pre>
<pre><code>## [1]  13.761634   2.861325  -8.516899  17.341453 -17.049719</code></pre>
</div>
<div id="assigning-value-to-object" class="section level3">
<h3>Assigning value to object</h3>
<p><code>a</code> is an object containing character “b”:</p>
<pre class="r"><code>a &lt;- &quot;b&quot;
a</code></pre>
<pre><code>## [1] &quot;b&quot;</code></pre>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="en" dir="ltr">
In <a href="https://twitter.com/hashtag/rstats?src=hash">#rstats</a>, it's surprisingly important to realise that names have objects; objects don't have names <a href="https://t.co/bEMO1YVZX0">pic.twitter.com/bEMO1YVZX0</a>
</p>
— Hadley Wickham (<span class="citation">@hadleywickham</span>) <a href="https://twitter.com/hadleywickham/status/732288980549390336">May 16, 2016</a>
</blockquote>
<p>You can overwrite objects (assign a new value to it):</p>
<pre class="r"><code>a &lt;- c(&quot;poodle&quot;,&quot;sheltie&quot;) # c(1,2) is a vector 
a # a now contains two values: &quot;poodle&quot; and &quot;sheltie&quot;</code></pre>
<pre><code>## [1] &quot;poodle&quot;  &quot;sheltie&quot;</code></pre>
<div class="figure">
<img src="http://www.dailytorygraph.com/wp-content/uploads/2016/03/IMG_2139-700x525.jpg" alt="Poodle as innocent victim of overwriting @daily torygraph." />
<p class="caption">Poodle as innocent victim of overwriting <span class="citation">@daily</span> torygraph.</p>
</div>
<p>You can copy objects under new name:</p>
<pre class="r"><code>b &lt;- a
b</code></pre>
<pre><code>## [1] &quot;poodle&quot;  &quot;sheltie&quot;</code></pre>
<p>You can use output of <code>function 1</code> as input to <code>function 2</code>:</p>
<pre class="r"><code>foo &lt;- function(x) x^4 # function 1
foo(x = 2)</code></pre>
<pre><code>## [1] 16</code></pre>
<pre class="r"><code>d &lt;- sqrt(foo(2)) # function &#39;sqrt&#39; calculates square root
d</code></pre>
<pre><code>## [1] 4</code></pre>
<blockquote>
<p>Never use a function name as object name – <code>c</code> vs. <code>c()</code>. You rewrite that function in your environment and you get into trouble!</p>
</blockquote>
</div>
<div id="coercing" class="section level3">
<h3>Coercing</h3>
<pre class="r"><code>a &lt;- &quot;42&quot;
a</code></pre>
<pre><code>## [1] &quot;42&quot;</code></pre>
<pre class="r"><code>class(a)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>b &lt;- as.numeric(a)
b</code></pre>
<pre><code>## [1] 42</code></pre>
<pre class="r"><code>class(b)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>b &lt;- as.factor(a)
b</code></pre>
<pre><code>## [1] 42
## Levels: 42</code></pre>
<pre class="r"><code>class(b)</code></pre>
<pre><code>## [1] &quot;factor&quot;</code></pre>
<p>To coerce the factor <code>ss</code> with two levels <code>10</code> and <code>20</code> into numbers you must convert it to character first:</p>
<pre class="r"><code>ss &lt;- as.factor(c(10,20))
ss</code></pre>
<pre><code>## [1] 10 20
## Levels: 10 20</code></pre>
<pre class="r"><code># lets see what happens if we try to convert ss directly to numeric
as.numeric(ss)</code></pre>
<pre><code>## [1] 1 2</code></pre>
<pre class="r"><code>as.numeric(as.character(ss))</code></pre>
<pre><code>## [1] 10 20</code></pre>
<p>Factor variables are encoded as integers in their underlying representation. So a variable like “poodle” and “sheltie” will be encoded as 1 and 2 in the underlying representation <a href="http://simplystatistics.org/2015/07/24/stringsasfactors-an-unauthorized-biography/">more about factors and stringsAsFactors option when importing a data.frame</a>.</p>
<p>Factors are used to group data by their levels for analysis (e.g. linear model: <code>lm()</code>) &amp; graphing. In earlier versions of R, storing character data as a factor was more space efficient if there is even a small proportion of repeats. However, identical character strings now share storage, so the difference is small in most cases. Nominal variables are categorical, without an implied order.</p>
<pre class="r"><code>diabetes &lt;- c(&quot;Type1&quot;, &quot;Type2&quot;, &quot;Type1&quot;, &quot;Type1&quot;) # diabetes is a factor with 2 levels
diabetes # a character vector</code></pre>
<pre><code>## [1] &quot;Type1&quot; &quot;Type2&quot; &quot;Type1&quot; &quot;Type1&quot;</code></pre>
<pre class="r"><code>class(diabetes)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>diabetes &lt;- factor(diabetes) # coerce to factor
diabetes # factors</code></pre>
<pre><code>## [1] Type1 Type2 Type1 Type1
## Levels: Type1 Type2</code></pre>
<pre class="r"><code>class(diabetes)</code></pre>
<pre><code>## [1] &quot;factor&quot;</code></pre>
<p>Encoding <code>diabetes</code> vector as a factor stores this vector as 1, 2, 1, 1 and associates it with 1 = Type1 and 2 = Type2 internally (the assignment is alphabetical). Any analyses performed on the vector diabetes will treat the variable as nominal and select the statistical methods appropriate for this level of measurement.</p>
<p>Ordinal variables imply order but not amount. <code>Status (poor, improved, excellent)</code>. For vectors representing ordinal variables, add <code>ordered = TRUE</code> to the <code>factor()</code> function.</p>
<pre class="r"><code>status &lt;- c(&quot;Poor&quot;, &quot;Improved&quot;, &quot;Excellent&quot;, &quot;Poor&quot;)
status</code></pre>
<pre><code>## [1] &quot;Poor&quot;      &quot;Improved&quot;  &quot;Excellent&quot; &quot;Poor&quot;</code></pre>
<p>For ordered factors, override the alphabetic default by specifying levels.</p>
<pre class="r"><code>status &lt;- factor(status, ordered = TRUE, levels = c(&quot;Poor&quot;, &quot;Improved&quot;, &quot;Excellent&quot;)) # Assigns the levels as 1 = Poor, 2 = Improved, 3 = Excellent. 
status</code></pre>
<pre><code>## [1] Poor      Improved  Excellent Poor     
## Levels: Poor &lt; Improved &lt; Excellent</code></pre>
<p>Continuous variables have order &amp; amount (<code>class: numeric or integer</code>). Numeric variables can be re-coded as factors. If sex was coded as 1 for male and 2 for female in the original data,</p>
<pre class="r"><code>sex &lt;- sample(c(1,2), 21, replace = TRUE) # lets generate data
sex</code></pre>
<pre><code>##  [1] 2 1 1 2 1 1 1 2 1 1 2 1 1 2 1 2 2 1 1 2 1</code></pre>
<p>then, <code>factor()</code> converts the variable to an unordered factor.<br />
The order of the labels must match the order of the levels. Sex would be treated as categorical, the labels “Male” and “Female” would appear in the output instead of 1 and 2</p>
<pre class="r"><code>sex &lt;- factor(sex, levels = c(1, 2), labels = c(&quot;Male&quot;, &quot;Female&quot;))
sex</code></pre>
<pre><code>##  [1] Female Male   Male   Female Male   Male   Male   Female Male   Male  
## [11] Female Male   Male   Female Male   Female Female Male   Male   Female
## [21] Male  
## Levels: Male Female</code></pre>
</div>
</div>
<div id="data-structures" class="section level1">
<h1>Data structures</h1>
<ul>
<li><strong>Atomic vectors</strong> are arrays that contain a single data type (logical, real, complex, character). Each of the following is a one-dimensional atomic vector:</li>
</ul>
<pre class="r"><code>passed &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE) # random sequence
class(passed)</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<pre class="r"><code>ages &lt;- c(53, 51, 25, 67, 66, 41, 62, 42) # random numbers
class(ages)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>namez &lt;- c(&quot;Marina&quot;, &quot;Allar&quot;, &quot;Siim&quot;, &quot;Mart&quot;, &quot;Mailis&quot;, &quot;Eiki&quot;, &quot;Urmas&quot;) # random names, names is R function!
class(namez)  </code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<p>A scalar is an atomic vector with a single element. So <code>k &lt;- 2</code> is a shortcut for <code>k &lt;- c(2)</code>.</p>
<ul>
<li>A <strong>matrix</strong> is an atomic vector that has a dimension attribute, <code>dim()</code>, containing two elements (<code>nrow</code>, number of rows and <code>ncol</code>, number of columns)</li>
</ul>
<pre class="r"><code>matrix(ages, nrow = 2)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]   53   25   66   62
## [2,]   51   67   41   42</code></pre>
<ul>
<li><strong>Lists</strong> are collections of atomic vectors and/or other lists.</li>
</ul>
<pre class="r"><code>mylist &lt;- list(passed, ages, namez)
mylist</code></pre>
<pre><code>## [[1]]
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## [[2]]
## [1] 53 51 25 67 66 41 62 42
## 
## [[3]]
## [1] &quot;Marina&quot; &quot;Allar&quot;  &quot;Siim&quot;   &quot;Mart&quot;   &quot;Mailis&quot; &quot;Eiki&quot;   &quot;Urmas&quot;</code></pre>
<p>We can assign names to list objects:</p>
<pre class="r"><code>names(mylist) &lt;- c(&quot;passed&quot;, &quot;ages&quot;, &quot;namez&quot;)
mylist</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## $ages
## [1] 53 51 25 67 66 41 62 42
## 
## $namez
## [1] &quot;Marina&quot; &quot;Allar&quot;  &quot;Siim&quot;   &quot;Mart&quot;   &quot;Mailis&quot; &quot;Eiki&quot;   &quot;Urmas&quot;</code></pre>
<ul>
<li><strong>Data frames</strong> are a special type of list, where each atomic vector in the collection has the same length. Each vector represents a column (variable) in the data frame.</li>
</ul>
<pre class="r"><code>exam &lt;- data.frame(name = namez, passed = passed)
exam</code></pre>
<pre><code>##     name passed
## 1 Marina   TRUE
## 2  Allar  FALSE
## 3   Siim  FALSE
## 4   Mart  FALSE
## 5 Mailis   TRUE
## 6   Eiki   TRUE
## 7  Urmas   TRUE</code></pre>
<div class="figure">
<img src="https://raw.githubusercontent.com/Anonymous-Y/BlogImage/master/r-intro-3.jpg" alt="Illustration of R data types. Image: http://yzc.me/2015/12/11/r-intro-1/" />
<p class="caption">Illustration of R data types. Image: <a href="http://yzc.me/2015/12/11/r-intro-1/" class="uri">http://yzc.me/2015/12/11/r-intro-1/</a></p>
</div>
</div>
<div id="selecting-by-index" class="section level1">
<h1>Selecting by index</h1>
<p>Index gives the address that specifies the elements of vector/matrix/list or data.frame, which are then automatically selected.</p>
<ul>
<li>Indexing begins at 1 (not 0) in R</li>
<li>Indexing operators in R are square brackets – ‘[’, <code>[[</code> and dollar sign <code>$</code><br />
</li>
<li><code>[</code> allows selecting more than one element, whereas <code>[[</code> and <code>$</code> select only one element.</li>
<li>Empty index [,] means “select all” – <code>a[,1]</code> means “select all rows and 1st column from <code>a</code>”.</li>
</ul>
<!-- ```{r} -->
<!-- '['(c(1,2,3), 1) == c(1,2,3)[1] # as you can see these are both identical -->
<!-- ``` -->
<!-- + you can select values, rows or columns by index -->
<!-- + `-` (minus) before index means "not this element" -->
<!-- + ! means "not" -->
<!-- + != means "not equal" -->
<!-- + == means "equal" -->
<p>During initial data exploration it is often necessary to have a look how the head of your table looks like, for this you can use convenience methods <code>head</code> and <code>tail</code> which are returning first and last elements of a object, respectively:</p>
<pre class="r"><code>head(mtcars) # Prints first 6 elements (rows) as default</code></pre>
<pre><code>##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1</code></pre>
<pre class="r"><code>tail(mtcars, n = 3) # Prints last 3 elements (rows)</code></pre>
<pre><code>##                mpg cyl disp  hp drat   wt qsec vs am gear carb
## Ferrari Dino  19.7   6  145 175 3.62 2.77 15.5  0  1    5    6
## Maserati Bora 15.0   8  301 335 3.54 3.57 14.6  0  1    5    8
## Volvo 142E    21.4   4  121 109 4.11 2.78 18.6  1  1    4    2</code></pre>
<p>Tip: you can use <code>tail</code> to return the very last element of a object with unknown length.</p>
<pre class="r"><code>tail(LETTERS, n = 1)</code></pre>
<pre><code>## [1] &quot;Z&quot;</code></pre>
</div>
<div id="vectors" class="section level1">
<h1>Vectors</h1>
<p>The combine function <code>c()</code> is used to form the vector.</p>
<pre class="r"><code>a &lt;- c(1, 2, 5, -3, 6, -2, 4)
b &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
d &lt;- c(TRUE,TRUE,TRUE,FALSE,TRUE,FALSE) # We use d instead of c as vector name. Why?</code></pre>
<p><code>a</code> is a numeric vector, <code>b</code> is a character vector, and <code>d</code> is a logical vector. The data in a vector can be only one type (numeric, character, or logical).</p>
<p>You can refer to elements of a vector:</p>
<pre class="r"><code>a[c(2, 4)] # Refers to the second and fourth elements of vector a.</code></pre>
<pre><code>## [1]  2 -3</code></pre>
<pre class="r"><code>&#39;[&#39;(a, c(2,4)) # [ is a function! This is very handy in case of piping, as we see in the upcoming lessons.</code></pre>
<pre><code>## [1]  2 -3</code></pre>
<p>We can sort/order vector:</p>
<pre class="r"><code>sort(a, decreasing = FALSE) # sorts vector in ascending order</code></pre>
<pre><code>## [1] -3 -2  1  2  4  5  6</code></pre>
<p>We can extract uniqe elements of a vector:</p>
<pre class="r"><code>d</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE</code></pre>
<pre class="r"><code>unique(d) # Returns a vector, data frame or array like d but with duplicate elements removed.</code></pre>
<pre><code>## [1]  TRUE FALSE</code></pre>
<p>Create sequence:</p>
<pre class="r"><code>seq(2, 5, by = 0.5)</code></pre>
<pre><code>## [1] 2.0 2.5 3.0 3.5 4.0 4.5 5.0</code></pre>
<p>A complex sequence:</p>
<pre class="r"><code>rep(1:4, times = 2)</code></pre>
<pre><code>## [1] 1 2 3 4 1 2 3 4</code></pre>
<p>Repeat each element of a vector:</p>
<pre class="r"><code>rep(1:2, each = 3)</code></pre>
<pre><code>## [1] 1 1 1 2 2 2</code></pre>
<p>Repeat elements of a vector:</p>
<pre class="r"><code>rep(c(&quot;poodle&quot;,&quot;sheltie&quot;), each = 3, times = 2)</code></pre>
<pre><code>##  [1] &quot;poodle&quot;  &quot;poodle&quot;  &quot;poodle&quot;  &quot;sheltie&quot; &quot;sheltie&quot; &quot;sheltie&quot; &quot;poodle&quot; 
##  [8] &quot;poodle&quot;  &quot;poodle&quot;  &quot;sheltie&quot; &quot;sheltie&quot; &quot;sheltie&quot;</code></pre>
</div>
<div id="data-frame" class="section level1">
<h1>Data frame</h1>
<ul>
<li><p><code>data frame</code>: a collection of vectors where different columns can contain different modes of data (numeric, character, and so on). Each vector contains only 1 mode of data (<code>vector1 &lt;- c(&quot;a&quot;, 2, 3.4)</code> is automatically coerced to <code>chr</code>, but can be manually coerced to numeric or factor). The data frame columns are variables, and the rows are observations. Vectors are bound into matrix/data.frame vertically, with the direction from top to bottom. Column = vector. <code>as.matrix()</code> has default argument <code>byrow = FALSE</code>, change this to fill matrix by rows.</p></li>
<li><code>tibble::data_frame()</code> is a more modern version of data.frame (slight differences for the better) <code>as_data_frame()</code> converts to it. <code>data_frame()</code> does less than <code>data.frame()</code>:
<ul>
<li>it never changes the type of the inputs (e.g. it never converts strings to factors!),</li>
<li>it never changes the names of variables, and it never creates <code>row.names()</code>.</li>
</ul></li>
</ul>
<p><strong>Tibbles</strong> have a print method that shows only the first 10 rows, and all the columns that fit on screen. This makes it much easier to work with large data. <!-- In addition to its name, each column reports its type.  --> <!-- Tibbles clearly delineate `[` and `[[`: `[` always returns another tibble, `[[` always returns a vector.  --> <!-- Some older functions don't work with tibbles because they expect `df[, 1]` to return a vector, not a data frame.  --> <!-- If you encounter one of these functions, use `as.data.frame()` to coerce a tibble back to a data frame: --></p>
<div class="figure">
<img src="http://articles.concreteinteractive.com/wp-content/uploads/2015/03/irises.png" alt="Iris dataset contains sepal and petal measurements of three iris species." />
<p class="caption">Iris dataset contains sepal and petal measurements of three iris species.</p>
</div>
<pre class="r"><code>library(dplyr) # tbl_df 
tbl_df(iris)</code></pre>
<pre><code>## # A tibble: 150 x 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;  &lt;fctr&gt;
##  1          5.1         3.5          1.4         0.2  setosa
##  2          4.9         3.0          1.4         0.2  setosa
##  3          4.7         3.2          1.3         0.2  setosa
##  4          4.6         3.1          1.5         0.2  setosa
##  5          5.0         3.6          1.4         0.2  setosa
##  6          5.4         3.9          1.7         0.4  setosa
##  7          4.6         3.4          1.4         0.3  setosa
##  8          5.0         3.4          1.5         0.2  setosa
##  9          4.4         2.9          1.4         0.2  setosa
## 10          4.9         3.1          1.5         0.1  setosa
## # ... with 140 more rows</code></pre>
<pre class="r"><code>class(as.data.frame(tbl_df(iris)))</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<pre class="r"><code>library(tibble)
height &lt;- c(187, 190, 156)
name &lt;- c(&quot;Jim&quot;, &quot;Joe&quot;, &quot;Jill&quot;)
my_tab &lt;- data_frame(name, height) # object names are used as column names
my_tab</code></pre>
<pre><code>## # A tibble: 3 x 2
##    name height
##   &lt;chr&gt;  &lt;dbl&gt;
## 1   Jim    187
## 2   Joe    190
## 3  Jill    156</code></pre>
<pre class="r"><code>summary(my_tab) # Prints a summary of data</code></pre>
<pre><code>##      name               height     
##  Length:3           Min.   :156.0  
##  Class :character   1st Qu.:171.5  
##  Mode  :character   Median :187.0  
##                     Mean   :177.7  
##                     3rd Qu.:188.5  
##                     Max.   :190.0</code></pre>
<pre class="r"><code>names(my_tab) # Prints column names</code></pre>
<pre><code>## [1] &quot;name&quot;   &quot;height&quot;</code></pre>
<pre class="r"><code>nrow(my_tab) # number of rows</code></pre>
<pre><code>## [1] 3</code></pre>
<pre class="r"><code>ncol(my_tab)</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code>dim(my_tab)</code></pre>
<pre><code>## [1] 3 2</code></pre>
<div id="indexing-data.frames" class="section level2">
<h2>Indexing data.frames</h2>
<!-- Data frames can be indexed in several modes. When [ and [[ are used with a single vector index (x[i] or x[[i]]), they index the data frame as if it were a list. -->
<p>We use R <code>mtcars</code> dataset to illustrate indexing of a data.frame:</p>
<pre class="r"><code>class(mtcars)</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<pre class="r"><code>dim(mtcars) # what&#39;s the size of the data.frame</code></pre>
<pre><code>## [1] 32 11</code></pre>
<pre class="r"><code>mtc &lt;- mtcars[sample(1:nrow(mtcars), 6), ] # select a manageable subset
mtc</code></pre>
<pre><code>##                    mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## Datsun 710        22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
## Merc 230          22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
## Chrysler Imperial 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
## Fiat 128          32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
## Camaro Z28        13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
## Merc 240D         24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2</code></pre>
<p>Here we select columns:</p>
<pre class="r"><code>mtc[,2] # selects 2nd column and returns vector</code></pre>
<pre><code>## [1] 4 4 8 4 8 4</code></pre>
<pre class="r"><code>mtc[3] # selects 3nd column and returns data.frame</code></pre>
<pre><code>##                    disp
## Datsun 710        108.0
## Merc 230          140.8
## Chrysler Imperial 440.0
## Fiat 128           78.7
## Camaro Z28        350.0
## Merc 240D         146.7</code></pre>
<pre class="r"><code>mtc[, &quot;hp&quot;] # selects column named &quot;hp&quot;</code></pre>
<pre><code>## [1]  93  95 230  66 245  62</code></pre>
<pre class="r"><code>mtc$cyl # selects column named &quot;cyl&quot;</code></pre>
<pre><code>## [1] 4 4 8 4 8 4</code></pre>
<pre class="r"><code>df &lt;- data.frame(M = c(2, 3, 6, 3, 34), N = c(34, 3, 8, 3, 3), L = c(TRUE, FALSE, TRUE, FALSE, TRUE))
df</code></pre>
<pre><code>##    M  N     L
## 1  2 34  TRUE
## 2  3  3 FALSE
## 3  6  8  TRUE
## 4  3  3 FALSE
## 5 34  3  TRUE</code></pre>
<pre class="r"><code>df[df$M == 34,] # selects rows from A that have value == 34</code></pre>
<pre><code>##    M N    L
## 5 34 3 TRUE</code></pre>
<pre class="r"><code>df[1:2, &quot;N&quot;] # selects rows 1 through 2 from column &quot;A&quot;</code></pre>
<pre><code>## [1] 34  3</code></pre>
<pre class="r"><code>rownames(df) &lt;- letters[1:5] # letters vector gives us lower case letters
df[rownames(df) == &quot;c&quot;,] # selects row named &quot;c&quot;</code></pre>
<pre><code>##   M N    L
## c 6 8 TRUE</code></pre>
<pre class="r"><code>df[-(2:4),] # drops rows 2 to 4 (incl)</code></pre>
<pre><code>##    M  N    L
## a  2 34 TRUE
## e 34  3 TRUE</code></pre>
<pre class="r"><code>df[, -2] # drops col 2, outputs vector! </code></pre>
<pre><code>##    M     L
## a  2  TRUE
## b  3 FALSE
## c  6  TRUE
## d  3 FALSE
## e 34  TRUE</code></pre>
<pre class="r"><code>df[df$M == 6,] # selects all rows that contain 6 in column named M</code></pre>
<pre><code>##   M N    L
## c 6 8 TRUE</code></pre>
<pre class="r"><code>df[df$M != 6,] # selects all rows that do not contain 6 in column named M</code></pre>
<pre><code>##    M  N     L
## a  2 34  TRUE
## b  3  3 FALSE
## d  3  3 FALSE
## e 34  3  TRUE</code></pre>
<pre class="r"><code>df[df$L==T,] # selects all rows where L is TRUE (T)</code></pre>
<pre><code>##    M  N    L
## a  2 34 TRUE
## c  6  8 TRUE
## e 34  3 TRUE</code></pre>
<p>What if we have duplicated rows or elements in our data frame or vector (and we want to get rid of them)?</p>
<pre class="r"><code>?duplicated #  determines which elements of a vector or data frame are duplicates of elements with smaller subscripts</code></pre>
<pre class="r"><code>df[!duplicated(df),] # removes second one of the duplicated rows from df, we have to use ! to negate logical evaluation</code></pre>
<pre><code>##    M  N     L
## a  2 34  TRUE
## b  3  3 FALSE
## c  6  8  TRUE
## e 34  3  TRUE</code></pre>
<pre class="r"><code>df[df$M &gt; median(df$N) &amp; df$M &lt; 25,] # selects rows where df$M value is &gt; median df$N AND df$M value &lt; 25</code></pre>
<pre><code>##   M N    L
## c 6 8 TRUE</code></pre>
<pre class="r"><code>df[df$M &gt; median(df$N) | df$M == 34,] # selects rows where df$M value is &gt; median df$N OR df$M value == 34</code></pre>
<pre><code>##    M N    L
## c  6 8 TRUE
## e 34 3 TRUE</code></pre>
<pre class="r"><code>sum(df$M[df$L==T]) # sums column df$M at rows where column &#39;L&#39; is TRUE (T)</code></pre>
<pre><code>## [1] 42</code></pre>
<p>A vector can be extracted by <code>$</code> and worked on:</p>
<pre class="r"><code>Mean.height &lt;- mean(my_tab$height)
Mean.height # Prints the answer</code></pre>
<pre><code>## [1] 177.6667</code></pre>
<p>New vectors can be bound into a data.frame:</p>
<pre class="r"><code>my_tab$weight &lt;- c(87, 96, 69) # Now there are 3 columns in my_tab
my_tab</code></pre>
<pre><code>## # A tibble: 3 x 3
##    name height weight
##   &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1   Jim    187     87
## 2   Joe    190     96
## 3  Jill    156     69</code></pre>
<pre class="r"><code>my_tab$experiment &lt;- factor(&quot;A&quot;) # the 4th col contains a factor with a single level &quot;A&quot;
levels(my_tab$experiment) # prints the unique levels in a factor vector</code></pre>
<pre><code>## [1] &quot;A&quot;</code></pre>
</div>
</div>
<div id="matrix" class="section level1">
<h1>Matrix</h1>
<p>Matrix: a collection of data elements, which are all numeric, character, or logical.</p>
<p>Why use matrix? The choice between matrix and data.frame comes up only if you have data of the same type.</p>
<ul>
<li><p>The answer depends on what you are going to do with the data in data.frame/matrix. If it is going to be passed to other functions then the expected type of the arguments of these functions determine the choice.</p></li>
<li><p>Matrices are more memory efficient:</p></li>
</ul>
<pre class="r"><code>m &lt;- matrix(1:4, 2, 2)
d &lt;- as.data.frame(m)
object.size(m)</code></pre>
<pre><code>## 216 bytes</code></pre>
<pre class="r"><code>object.size(d)</code></pre>
<pre><code>## 792 bytes</code></pre>
<ul>
<li>Matrices are a necessity if you plan to do any linear algebra-type of operations.</li>
<li>Data frames are more convenient if you frequently refer to its columns by name (via the <code>$</code> operator).</li>
<li>Data frames are also better for reporting tabular data as you can apply formatting to each column separately.</li>
</ul>
<pre class="r"><code>n &lt;- matrix(rnorm(30), ncol = 5) 
dim(n)</code></pre>
<pre><code>## [1] 6 5</code></pre>
<pre class="r"><code>n</code></pre>
<pre><code>##            [,1]        [,2]       [,3]       [,4]       [,5]
## [1,]  0.9625717  0.08574938  1.4015132 -0.1912197  0.8754069
## [2,] -0.3202461 -0.37379322 -1.0499794  0.3187382  1.1420646
## [3,]  1.0826235  0.32876437 -1.0656420 -0.0214719 -1.9810216
## [4,]  0.6353925 -0.17265983 -0.3996834 -1.4182507 -0.3312632
## [5,] -0.3768512  0.82532371  0.9483084  1.1160782 -0.1887763
## [6,] -1.0271560 -0.18793586  0.5508250 -0.6006577  0.8535260</code></pre>
<pre class="r"><code>exam # we created previously data.frame exam</code></pre>
<pre><code>##     name passed
## 1 Marina   TRUE
## 2  Allar  FALSE
## 3   Siim  FALSE
## 4   Mart  FALSE
## 5 Mailis   TRUE
## 6   Eiki   TRUE
## 7  Urmas   TRUE</code></pre>
<pre class="r"><code>class(exam)</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<pre class="r"><code>m &lt;- as.matrix(exam) # coerce data.frame with n,m dimension to a matrix with n,m dimension 
m</code></pre>
<pre><code>##      name     passed 
## [1,] &quot;Marina&quot; &quot; TRUE&quot;
## [2,] &quot;Allar&quot;  &quot;FALSE&quot;
## [3,] &quot;Siim&quot;   &quot;FALSE&quot;
## [4,] &quot;Mart&quot;   &quot;FALSE&quot;
## [5,] &quot;Mailis&quot; &quot; TRUE&quot;
## [6,] &quot;Eiki&quot;   &quot; TRUE&quot;
## [7,] &quot;Urmas&quot;  &quot; TRUE&quot;</code></pre>
<pre class="r"><code>t(m) # transposes a matrix</code></pre>
<pre><code>##        [,1]     [,2]    [,3]    [,4]    [,5]     [,6]    [,7]   
## name   &quot;Marina&quot; &quot;Allar&quot; &quot;Siim&quot;  &quot;Mart&quot;  &quot;Mailis&quot; &quot;Eiki&quot;  &quot;Urmas&quot;
## passed &quot; TRUE&quot;  &quot;FALSE&quot; &quot;FALSE&quot; &quot;FALSE&quot; &quot; TRUE&quot;  &quot; TRUE&quot; &quot; TRUE&quot;</code></pre>
<!-- Transpose a data frame with 1st column as factor -->
<!-- ```{r} -->
<!-- n <- exam$name -->
<!-- df <- as.data.frame(t(exam[,-1])) -->
<!-- colnames(df) <- n -->
<!-- df -->
<!-- ``` -->
<!-- ### Indexing matrices -->
<!-- Matrices are vectors with a dimension attribute and so all the vector forms of indexing can be used with a single index.  -->
<!-- ```{r} -->
<!-- m <- matrix(1:12, nrow = 3, dimnames = list(c("a","b","d"), LETTERS[1:4])) -->
<!-- m -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[1,]                 # the first row of matrix m -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[1, , drop = FALSE]  # is a 1-row matrix -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[, c(TRUE, FALSE, FALSE, TRUE)] # logical indexing -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[cbind(c(1,2,1), 3:1)] # matrix numeric index -->
<!-- ``` -->
<!-- ```{r} -->
<!-- ci <- cbind(c("a", "b", "a"), c("A", "C", "B")) -->
<!-- m[ci]                 # matrix character index -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[,-1]           # delete the first column of m -->
<!-- ``` -->
</div>
<div id="list" class="section level1">
<h1>List</h1>
<p>A list is an ordered collection of objects. Basically, in R you can shove any data structure into list. E.g. list may contain a combination of vectors, matrices, data frames, and even other lists, (poodles?). You can specify elements of the list by:</p>
<pre class="r"><code>mylist[[2]]</code></pre>
<pre><code>## [1] 53 51 25 67 66 41 62 42</code></pre>
<pre class="r"><code>mylist[[&quot;ages&quot;]]</code></pre>
<pre><code>## [1] 53 51 25 67 66 41 62 42</code></pre>
<pre class="r"><code>mylist$ages</code></pre>
<pre><code>## [1] 53 51 25 67 66 41 62 42</code></pre>
<p>As you can see all these above expressions give identical result</p>
<pre class="r"><code>all.equal(mylist[[2]], mylist[[&quot;ages&quot;]], mylist$ages)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<div id="indexing-lists" class="section level2">
<h2>Indexing lists</h2>
<p>Indexing by <code>[</code> is similar to atomic vectors and selects a list of the specified element(s). Both <code>[[</code> and <code>$</code> select a single element of the list (e.g. a single vector or data frame).</p>
<pre class="r"><code>mylist # here we go back to our mylist object</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## $ages
## [1] 53 51 25 67 66 41 62 42
## 
## $namez
## [1] &quot;Marina&quot; &quot;Allar&quot;  &quot;Siim&quot;   &quot;Mart&quot;   &quot;Mailis&quot; &quot;Eiki&quot;   &quot;Urmas&quot;</code></pre>
<pre class="r"><code>mylist[[1]]               # the first element of list mylist</code></pre>
<pre><code>## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>mylist[c(1, 3)]           # a list containing elements 1 and 3 of mylist</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## $namez
## [1] &quot;Marina&quot; &quot;Allar&quot;  &quot;Siim&quot;   &quot;Mart&quot;   &quot;Mailis&quot; &quot;Eiki&quot;   &quot;Urmas&quot;</code></pre>
<pre class="r"><code>mylist$ages               # the element of mylist named ages</code></pre>
<pre><code>## [1] 53 51 25 67 66 41 62 42</code></pre>
<p>Difference between using <code>[</code> and <code>[[</code> for subsetting a list: Square brackets <code>[</code> return subset of list as list:</p>
<pre class="r"><code>mylist[1]</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>class(mylist[1]) # returns list with one object</code></pre>
<pre><code>## [1] &quot;list&quot;</code></pre>
<pre class="r"><code>mylist[c(1,2)]</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## $ages
## [1] 53 51 25 67 66 41 62 42</code></pre>
<pre class="r"><code>class(mylist[c(1,2)]) # returns list with two objects</code></pre>
<pre><code>## [1] &quot;list&quot;</code></pre>
<p>Double square brackets <code>[[</code> return single list object/value:</p>
<pre class="r"><code>mylist[[1]] # returns list object </code></pre>
<pre><code>## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>class(mylist[[1]]) # logical vector in this case</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<p><strong>Warning</strong>: if you use double square brackets <code>[[</code> instead of <code>[</code> with index vector e.g. c(3,2) we get 2nd element from 3rd list object:</p>
<pre class="r"><code>mylist[[c(3,2)]]</code></pre>
<pre><code>## [1] &quot;Allar&quot;</code></pre>
<p>Be careful, if you won’t get <code>Error in ... : subscript out of bounds</code>, your script proceeds with this value and returns error in some of the next lines or returns wrong result.</p>
<!-- ### Recursive indexing into lists -->
<!-- ```{r} -->
<!-- z <- list(a = list(x = 9, y = "chello"), b = 1:5) # we create list named 'a' inside list 'z' -->
<!-- z -->
<!-- ``` -->
<!-- ```{r} -->
<!-- unlist(z) # look what happens if we simplify this list into vector... -->
<!-- ``` -->
<!-- ```{r} -->
<!-- z$a$x # what's a$x in list z -->
<!-- ``` -->
<!-- ```{r} -->
<!-- z[[c(1, 2)]] # we get second element of 1st element of list z -->
<!-- ``` -->
<!-- ```{r} -->
<!-- z[[c("a", "x")]] <- "piano" # here we replace z$a$x with "piano" -->
<!-- z -->
<!-- ``` -->
<p>Query names of list objects:</p>
<pre class="r"><code>names(mylist)</code></pre>
<pre><code>## [1] &quot;passed&quot; &quot;ages&quot;   &quot;namez&quot;</code></pre>
<p>Set/change names of list objects:</p>
<pre class="r"><code>names(mylist) &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)
names(mylist)</code></pre>
<pre><code>## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre>
<p>New name for nth list object:</p>
<pre class="r"><code>names(mylist)[2] &lt;- c(&quot;poodles&quot;)
names(mylist)</code></pre>
<pre><code>## [1] &quot;a&quot;       &quot;poodles&quot; &quot;c&quot;</code></pre>
</div>
<div id="output-from-statistical-tests" class="section level2">
<h2>Output from statistical tests</h2>
<p>Output of statistical tests in R is usually a list. Here we perform t test to compare two vectors a and b.</p>
<pre class="r"><code>a &lt;- rnorm(10) # random normal vector with mean 0
b &lt;- rnorm(10,2) # random normal vector with mean 2
t.result &lt;- t.test(a, b) # t test
str(t.result) # str() displays the internal structure of an R object</code></pre>
<pre><code>## List of 9
##  $ statistic  : Named num -3.45
##   ..- attr(*, &quot;names&quot;)= chr &quot;t&quot;
##  $ parameter  : Named num 16.6
##   ..- attr(*, &quot;names&quot;)= chr &quot;df&quot;
##  $ p.value    : num 0.00317
##  $ conf.int   : atomic [1:2] -2.931 -0.703
##   ..- attr(*, &quot;conf.level&quot;)= num 0.95
##  $ estimate   : Named num [1:2] 0.177 1.993
##   ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;mean of x&quot; &quot;mean of y&quot;
##  $ null.value : Named num 0
##   ..- attr(*, &quot;names&quot;)= chr &quot;difference in means&quot;
##  $ alternative: chr &quot;two.sided&quot;
##  $ method     : chr &quot;Welch Two Sample t-test&quot;
##  $ data.name  : chr &quot;a and b&quot;
##  - attr(*, &quot;class&quot;)= chr &quot;htest&quot;</code></pre>
<pre class="r"><code>t.result$conf.int # extracts an element from the list</code></pre>
<pre><code>## [1] -2.9305769 -0.7028183
## attr(,&quot;conf.level&quot;)
## [1] 0.95</code></pre>
<pre class="r"><code>t.result$p.value # p.value</code></pre>
<pre><code>## [1] 0.003168964</code></pre>
</div>
</div>
<div id="base-graphics" class="section level1">
<h1>Base graphics</h1>
<p>Some say that R base graphics is only good for <strong>quick and dirty</strong> data exploration, but not very straightforward for creating polished publication quality graphs (but you can master it if you really dive into it).</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/en/7/73/Fat_bastard.jpeg" alt="Base R graphics has mojo too, and massive strength. Photo: wikipedia." />
<p class="caption">Base R graphics has mojo too, and massive strength. Photo: <a href="https://en.wikipedia.org/wiki/Fat_Bastard_(character)">wikipedia</a>.</p>
</div>
<pre class="r"><code>library(help = &quot;graphics&quot;) # complete list of functions</code></pre>
<p>Base R has extensive set of graphical parameters, which can be set or query using function <code>par</code>:</p>
<pre class="r"><code>par() # set or look at the available graphical parameters</code></pre>
<div id="scatterplot" class="section level2">
<h2>Scatterplot</h2>
<p>Scatterplots can be created using <code>plot()</code>. If we use <code>plot()</code> command with only one variable, we get graph with values versus index. We can use this representation to find out where we have gross outliers in our variable.</p>
<pre class="r"><code>plot(iris$Sepal.Length)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-89-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Even more sensible use of scatterplot is visualizing relationship between variables. Here, we explore the relationship between sepal length and width in different iris species.</p>
<pre class="r"><code>plot(iris$Sepal.Length, iris$Sepal.Width)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-90-1.png" width="672" style="display: block; margin: auto;" /> Looks OK-ish. But we don’t know witch dot belongs to which of the three iris species (setosa, versicolor, virginica).</p>
<p>We can fix that with <code>col=</code> argument, where <code>iris$Species</code> column is used as the factor by whose levels to color the dots (R will automatically order factor levels in alphabetical order: setosa, versicolor, virginica). <code>palette()</code> gives you the colors and their order, and it allows you to manipulate the color palette (see <code>?palette</code>).</p>
<pre class="r"><code>plot(iris$Sepal.Length, iris$Sepal.Width, 
     col = iris$Species, # dots are colored by species
     pch = 16, # we use filled dots instead of default empty dots
     las = 1) # horizontal y-axis labels
palette()</code></pre>
<pre><code>## [1] &quot;black&quot;   &quot;red&quot;     &quot;green3&quot;  &quot;blue&quot;    &quot;cyan&quot;    &quot;magenta&quot; &quot;yellow&quot; 
## [8] &quot;gray&quot;</code></pre>
<pre class="r"><code>legend(&quot;topright&quot;, # we place legend to the top right corner of the plot
       legend = levels(iris$Species), # species names in the legend
       pch = 16, # dot shape
       bty = &quot;n&quot;, # the type of box to be drawn around the legend: &quot;n&quot; no box
       col = 1:3) # new colors are added with numbers 1 to 3. This will work like using a factor.</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-91-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>We can plot all variable pairs into a single <strong>matrix of scatterplots</strong>:</p>
<pre class="r"><code>pairs(iris[1:4], # same output can be achieved also by using just plot()
      main = &quot;Iris Dataset&quot;,
      pch = 21, # dots need to be big enough to display color
      bg = iris$Species) # color by species</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-92-1.png" width="672" style="display: block; margin: auto;" /> <!-- `bg=` arguments gives us color for dots background. We can sample colors from colors 2:4 from default `palette()`: `c( "red","green3",  "blue")[unclass(iris$Species)]`. If we just use `iris$Species` then we get colors 1:3, which are "black, red, green3". --></p>
<p><strong>Matrix scatterplots can be created using the R formula interface</strong>, which allows better control over variables we want to explore. We use “Swiss Fertility and Socioeconomic Indicators (1888)” data as example.</p>
<pre class="r"><code>head(swiss)</code></pre>
<pre><code>##              Fertility Agriculture Examination Education Catholic
## Courtelary        80.2        17.0          15        12     9.96
## Delemont          83.1        45.1           6         9    84.84
## Franches-Mnt      92.5        39.7           5         5    93.40
## Moutier           85.8        36.5          12         7    33.77
## Neuveville        76.9        43.5          17        15     5.16
## Porrentruy        76.1        35.3           9         7    90.57
##              Infant.Mortality
## Courtelary               22.2
## Delemont                 22.2
## Franches-Mnt             20.2
## Moutier                  20.3
## Neuveville               20.6
## Porrentruy               26.6</code></pre>
<p>Here we plot matrix scatterplot using formula method from function example <code>?pairs</code>, if left hand side (dependent variable) of the formula is empty, we get all combinations of variables in the right hand side:</p>
<pre class="r"><code>pairs(~ Fertility + Education + Catholic, data = swiss,
      subset = Education &lt; 20, main = &quot;Swiss data, Education &lt; 20&quot;) # formula method from function example </code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-94-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Scatterplots are also ideal for visualising relationships between independent and dependent variables</strong>. We use R in-house dataset <code>CO2</code> showing carbon dioxide uptake in grass plants.</p>
<!-- We first summarise the dataset by calculating mean uptake per conc and ignore the independent variables Plant, Type, and Treatment: -->
<!-- ```{r} -->
<!-- head(CO2) #  -->
<!-- mean.uptake <- tapply(CO2$uptake, CO2$conc, mean) # we calculate mean for each conc ignoring variables Plant, Type, and Treatment. -->
<!-- CO2 <- data.frame(conc = unique(CO2$conc), uptake = mean.uptake) # we overwrite original CO2 dataset -->
<!-- ``` -->
<p>We plot plant CO<sub>2</sub> uptake versus its concentration and add calculated linear model fit to the scatterplot:</p>
<pre class="r"><code>plot(x = CO2$conc, y = CO2$uptake, # 
     pch = 16, col = &quot;blue&quot;, # dot type and color
     main = &quot;Carbon Dioxide Uptake in Grass Plants&quot;, # scatterplot
     las = 1) # horizontal y-axis labels
mod1 &lt;- lm(uptake~conc, data = CO2) # linear model fit
abline(mod1, col = &quot;red&quot;, lty = 2, lwd = 2) # add lin model fit to the scatterplot

coefs &lt;- coef(mod1) # linear model coefficients
b0 &lt;- round(coefs[1], 2) # round for printing
b1 &lt;- round(coefs[2], 2) # round for printing
r2 &lt;- round(summary(mod1)$r.squared, 2) # r squared
eqn &lt;- bquote(italic(y) == .(b0) + .(b1)*italic(x) * &quot;,&quot; ~~ r^2 == .(r2)) # formula and rsuared for printing
text(750, 20, labels = eqn) # add equation to the plot</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-95-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>As we can see in the upper plot, the linear model does not explain the relationship between conc and uptake very well. Therefore we fit exponential function, which seems to fit much better to these data.</p>
<pre class="r"><code>plot(uptake ~ conc, 
     data = CO2, 
     pch = 16, col = &quot;blue&quot;,
     main = &quot;Carbon Dioxide Uptake in Grass Plants&quot;,
     las = 1) # horizontal y-axis labels
lines(x = CO2$conc, y = predict(mod1), col = &quot;red&quot;, lty = 2, lwd = 2) # add linear model fitted line
mod2 &lt;- nls(uptake ~ SSlogis(conc, Asym, xmid, scal), data = CO2) # nonlin fit using SSlogis selfstart model
xvals &lt;- seq(from = 95, to = 1000, by = 3) # new x values for which we want model prediction
lines(x = xvals, y = predict(mod2, list(conc = xvals)), col = &quot;green&quot;, lty = 2, lwd = 2) # add nonlin fit line
legend(&quot;bottomright&quot;, legend = c(&quot;linear model&quot;, &quot;exponential model&quot;) , lty = 2, col = c(&quot;red&quot;, &quot;green&quot;), bty = &quot;n&quot;, lwd = 2) # add legend to the plot</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-96-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="histogram" class="section level2">
<h2>Histogram</h2>
<p>To illustrate <code>hist</code> function we use 2013 Tartu cross-country skiing marathon 63 km times (<code>Aeg</code> in Estonian).</p>
<pre class="r"><code>load(&quot;data/Tartu_Maraton_2013.RData&quot;)
head(tm_2013)</code></pre>
<pre><code>## # A tibble: 6 x 7
##    Koht    Nr             Nimi       Elukoht     Aeg Vanuseklass   Kuubik
##   &lt;int&gt; &lt;int&gt;            &lt;chr&gt;         &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;    &lt;dbl&gt;
## 1    NA     0     Laugal, Emil Harju maakond    &lt;NA&gt;        &lt;NA&gt; 0.000000
## 2  5500  6083  Miezys, Audrius         Leedu 6:25:42         M50 0.000000
## 3     1     4 Oestensen, Simen         Norra 2:45:01         M21 1.000000
## 4     2     1   Brink, Joergen        Rootsi 2:45:02         M35 1.000104
## 5     3     2  Aukland, Anders         Norra 2:45:02         M40 1.000198
## 6     4    50      Näss, Börre         Norra 2:45:02         M21 1.000281</code></pre>
<p>We first convert times in H:M:S format into periods using <code>hms()</code> function from <code>lubridate</code> package, then convert them to period objects with <code>as.duration</code> function (ibid.). <code>as.duration</code> gives us seconds, which we convert to decimal hours by dividing with 3600s (== 1h).</p>
<pre class="r"><code>library(lubridate) # for easy time manipulation
times &lt;- hms(tm_2013$Aeg[-1]) 
times &lt;- unclass(as.duration(times))/3600 # unclass gives us numbers (time in seconds), which we further divide by 3600 to get time in hours</code></pre>
<p>Lets have a look at <code>TP</code>-s finish time and convert it into decimal hours:</p>
<pre class="r"><code>tm_2013[tm_2013$Nimi==&quot;Päll, Taavi&quot;,]$Aeg # TP-s time in H:M:S</code></pre>
<pre><code>## [1] &quot;4:34:20&quot;</code></pre>
<pre class="r"><code>tp_time &lt;- unclass(as.duration(hms(tm_2013[tm_2013$Nimi==&quot;Päll, Taavi&quot;,]$Aeg)))/3600 </code></pre>
<p>Now we plot a histogram of Tartu skiing marathon times and add a vertical line at <code>TP</code>-s time:</p>
<pre class="r"><code>hist(times, 
     breaks = 100, # seems to be a good granularity
     main = &quot;Tartu cross-country skiing\nmarathon 2013, 63 km&quot;, # plot title. Pro tip: &#39;\n&#39; works as enter.
     xlab = &quot;Time, h&quot;, # x-axis label: time in seconds
     las = 1) # horizontal y-axis labels
abline(v = tp_time, col = &quot;red&quot;, lwd = 2) # add red vertical line</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-100-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>hist(times, breaks = seq(2, 10, by = 0.25)) # breaks after every 15 min</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-101-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="boxplot" class="section level2">
<h2>Boxplot</h2>
<p>Boxplots can be created, unsurprisingly, by <code>boxplot</code>:</p>
<pre class="r"><code>boxplot(iris$Sepal.Length ~ iris$Species, 
        las = 1,
        xlab = &quot;Species&quot;,
        ylab = &quot;Sepal Length&quot;,
        main = &quot;Sepal Length by Species in Iris&quot;,
        ylim = c(0, max(iris$Sepal.Length)))</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-102-1.png" width="672" style="display: block; margin: auto;" /></p>
<!-- With base graphics `boxplot` it is possible to use `plot = FALSE` argument to obtain boxplot stats for each group/plot without drawing the plot (**lower whisker, the lower hinge, the median, the upper hinge and the upper whisker**): -->
<!-- ```{r} -->
<!-- p <- boxplot(iris$Sepal.Length ~ iris$Species, plot = FALSE) -->
<!-- p$stats # boxplot stats -->
<!-- ``` -->
<!-- Whereas, lower and upper whiskers show 1.5 IQR by default (can be adjusted with the argument `range=`) and any values which lie outside of extremes of whiskers can be accessed like this:  -->
<!-- ```{r} -->
<!-- p$out # possible outliers -->
<!-- ``` -->
</div>
<div id="bargraphs" class="section level2">
<h2>Bargraphs</h2>
<p>This is <strong>no-brainer</strong>! Base graphics function <code>barplot</code> creates for us barplots with either vertical or horizontal bars:</p>
<pre class="r"><code>load(&quot;data/Rio2016_medals.RData&quot;) # we use rio medals data </code></pre>
<pre class="r"><code>barplot(medals$Total, 
        names.arg = medals$country_un, # country abbreviations, x-axis labels
        horiz = TRUE, # horozontal y-axis
        cex.names = 0.5, # smaller labels
        las = 1, # horizontal axis labels
        col = 4, # fill color nr 4 from default palette = &quot;blue&quot;
        xlab = &quot;Total number of medals&quot;, # x-axis label
        main = &quot;Country ranking by Rio 2016 medals&quot;, # main title
        sub = &quot;Ranking also takes into account the number of gold, silver and bronze medals.&quot;, # subtitle or ingraph caption
        cex.sub = 0.5) # labels perpendicular to x-axis</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-104-1.png" width="384" style="display: block; margin: auto;" /></p>
<!-- ### Dynamite plot -->
<!-- Whenever you open scientific article in biomedical field there is a good chance that you encounter **barplots with errorbars** sticking out of them, these pests are also known as [dynamite plots](http://biostat.mc.vanderbilt.edu/wiki/pub/Main/TatsukiKoyama/Poster3.pdf). In order to blend into the crowd we also learn how to create these wonderful and frightening graphs. -->
<!-- First we have to calculate summary statistics we want to put onto the graph -- mean (bar) and standard deviation (errorbar): -->
<!-- ```{r} -->
<!-- irissl_mean <- tapply(iris$Sepal.Length, iris$Species, mean) # mean for each species -->
<!-- irissl_sd <- tapply(iris$Sepal.Length, iris$Species, sd) # standard deviation for each species -->
<!-- ``` -->
<!-- It might seem little bit complicated, but you can use `tapply` when you want to apply a function (mean or sd in our case) to subsets of a vector (`iris$Sepal.Length` by Species) and the subsets are defined by some other vector, usually a factor (`iris$Species`). -->
<!-- `mapply` - when you have several data structures (e.g. lists) and you want to apply a function to the 1st elements of each, and then the 2nd elements of each, etc. -->
<!-- ```{r} -->
<!-- maxLim <- 1.1*max(mapply(sum, irissl_mean, irissl_sd)) # we find maximum sum of mean and sd in our dataset and multiply this number with 1.1 to give enough headroom for errorbars in our graph -->
<!-- bp <- barplot(irissl_mean, # means of our groups -->
<!--               names.arg = levels(iris$Species), # names for x-axis -->
<!--               ylim = c(0, maxLim)) # we have to set y-axis limits manually -->
<!-- arrows(x0 = bp, # coordinates of our groups on x-axis -->
<!--        y0 = irissl_mean, # start of arrow -->
<!--        y1 = irissl_mean + irissl_sd, # end of arrow -->
<!--        angle = 90) # blunt end for arrows; default is 30deg -->
<!-- ``` -->
</div>
<div id="add-second-y-axis" class="section level2">
<h2>Add second y-axis</h2>
<p>Sometimes it’s necessary to compare trends in two (or more) timeseries with very different scales. This can be solved by plotting these timeseries using separate y-axes for each of them. To illustrate addition of second y-axis to the plot, we use stockmarket data, which can be easily accessed via <code>quantmod</code> library. First we download stock data:</p>
<pre class="r"><code>library(quantmod)
getSymbols(c(&quot;AAPL&quot;,&quot;GOOG&quot;)) # download stock data in xts format</code></pre>
<pre><code>## [1] &quot;AAPL&quot; &quot;GOOG&quot;</code></pre>
<p>Stock data are in xts (time series) format, we convert this data into conventional data.frame:</p>
<pre class="r"><code># base plot of time series prior to xts
# get the data in data.frame format rather than xts
apple &lt;- data.frame(Date = index(AAPL), coredata(AAPL), stringsAsFactors=FALSE
)
head(apple)</code></pre>
<pre><code>##         Date AAPL.Open AAPL.High AAPL.Low AAPL.Close AAPL.Volume
## 1 2007-01-03    13.702    13.748   13.005   11.97143   309579900
## 2 2007-01-04    13.346    13.648   13.310   12.23714   211815100
## 3 2007-01-05    13.619    13.688   13.402   12.15000   208685400
## 4 2007-01-08    13.650    13.740   13.542   12.21000   199276700
## 5 2007-01-09    13.727    14.764   13.521   13.22429   837324600
## 6 2007-01-10    15.045    15.530   14.839   13.85714   738220000
##   AAPL.Adjusted
## 1      10.77017
## 2      11.00922
## 3      10.93082
## 4      10.98480
## 5      11.89731
## 6      12.46666</code></pre>
<pre class="r"><code>google &lt;- data.frame(Date = index(GOOG), coredata(GOOG), stringsAsFactors=FALSE)</code></pre>
<pre class="r"><code>par(mar = c(5, 4, 4, 4))
plot(apple$Date, apple$AAPL.Adjusted, type = &quot;l&quot;, col = &quot;blue&quot;, ylab = NA, xlab = NA)
par(new = TRUE)
plot(google$Date, google$GOOG.Adjusted, type = &quot;l&quot;, col = &quot;red&quot;, axes = FALSE, ylab = NA, xlab = &quot;Date&quot;)
axis(side = 4)
mtext(side = 4, line = 2.5, col = &quot;red&quot;, &quot;Google&quot;)
mtext(side = 2, line = 2.5, col = &quot;blue&quot;, &quot;Apple&quot;)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-107-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="combine-multiple-subplots" class="section level2">
<h2>Combine multiple subplots</h2>
<p>Some say, that <strong>every normal person</strong> should arrange figure panels in a <strong>vector graphics</strong> tool like <code>Inkscape</code> (freeware) or <code>Adobe Illustrator</code> (nonfree). However, from the point of view of reproducibility, you can also very easily assemble your article’s figures ‘automatically’ on-the-fly using R code. For this purpose, we can use R base graphics or by using grid graphics libraries <code>grid</code> and <code>gridExtra</code>. We introduce <code>gridExtra</code> in later lectures.</p>
<div class="figure">
<img src="graphs/normal_person.png" alt="Normal persons. Are you on the picture? Images: google image." />
<p class="caption">Normal persons. Are you on the picture? Images: google image.</p>
</div>
<p>Here we show, how to combine multiple subplots into one overall graph in base R, using either the <code>par()</code> or <code>layout()</code> function. Plotting linear model fit object outputs four separate diagnostic plots – “Residuals vs Fitted”, “Normal Q-Q”, “Scale-Location” and “Residuals vs Leverage”:</p>
<pre class="r"><code>plot(mod1)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-108-1.png" width="672" style="display: block; margin: auto;" /><img src="index_files/figure-html/unnamed-chunk-108-2.png" width="672" style="display: block; margin: auto;" /><img src="index_files/figure-html/unnamed-chunk-108-3.png" width="672" style="display: block; margin: auto;" /><img src="index_files/figure-html/unnamed-chunk-108-4.png" width="672" style="display: block; margin: auto;" /></p>
<p>By telling graphics device to create four slots, arranged 2x2, in our plot window, using <code>par</code> function argument <code>mfrow=c(nr, nc)</code>, we can tidy up all this information little bit:</p>
<pre class="r"><code>par(mfrow=c(2,2))      # number of rows, number of columns
plot(mod1) # plots are arranged into matrix in order of appearance</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-109-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>dev.off()</code></pre>
<pre><code>## quartz_off_screen 
##                 2</code></pre>
<p><code>layout()</code> function specifies graph layout using matrix. Here we create 2x2 layout specified by matrix – plots one and two will appear in the first column and third plot will be placed into second column and occupies two slots:</p>
<pre class="r"><code>layout(matrix(c(1,2,3,3), 2, 2)) 
plot(iris$Sepal.Length, iris$Sepal.Width, col = iris$Species, pch = 16, las = 1)
plot(uptake ~ conc, data = CO2, pch = 16, col = &quot;blue&quot;, main = &quot;Carbon Dioxide Uptake in Grass Plants&quot;, las = 1)
barplot(medals$Total, 
        names.arg = medals$country_un, # country abbreviations, x-axis labels
        horiz = TRUE, # horozontal y-axis
        cex.names = 0.5, # smaller labels
        las = 1, # horizontal axis labels
        col = 4, # fill color nr 4 from default palette = &quot;blue&quot;
        xlab = &quot;Total number of medals&quot;, # x-axis label
        main = &quot;Country ranking by Rio 2016 medals&quot;, # main title
        sub = &quot;Ranking also takes into account the number of gold, silver and bronze medals.&quot;, # subtitle or ingraph caption
        cex.sub = 0.5)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-110-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>dev.off()</code></pre>
<pre><code>## quartz_off_screen 
##                 2</code></pre>
<p>If you want to revert your <code>par(mfrow=...</code> to the original settings with single slot in graphics device, use following approach:</p>
<p>Either run <code>par</code> again with <code>mfrow=c(1,1)</code> settings</p>
<pre class="r"><code>par(mfrow=c(1,1))</code></pre>
<p>Or assign original settings to object and after you have done your multiplot load these setting using <code>par</code>:</p>
<pre class="r"><code>originalpars &lt;- par(mfrow=c(1,2)) # direct current mfrow to originalpars object
hist(rnorm(100))
plot(rnorm(100),rnorm(100))</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-112-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>dev.off()</code></pre>
<pre><code>## quartz_off_screen 
##                 2</code></pre>
<pre class="r"><code>par(originalpars) # loads/restores previous parameters
originalpars # we have only mfrow here </code></pre>
<pre><code>## $mfrow
## [1] 1 1</code></pre>
</div>
<div id="save-plots" class="section level2">
<h2>Save plots</h2>
<p>To save a plot into file you have to open the file and plot device first and then plot any graphics. Base R has graphics devices for BMP, JPEG, PNG and TIFF format bitmap files and for PDF.</p>
<pre class="r"><code>png(filename = &quot;Rplot%03d.png&quot;,
    width = 480, height = 480, units = &quot;px&quot;, pointsize = 12,
     bg = &quot;white&quot;,  res = NA, ...,
    type = c(&quot;cairo&quot;, &quot;cairo-png&quot;, &quot;Xlib&quot;, &quot;quartz&quot;), antialias)</code></pre>
<p>We want to save our disposable output files to directory <code>output</code>, therefore we first check if we already have this directory, if not then we create it:</p>
<pre class="r"><code>if(!dir.exists(&quot;output&quot;)) dir.create(&quot;output&quot;)</code></pre>
<p>In case of .png:</p>
<pre class="r"><code>png(file = &quot;output/iris_sepal.png&quot;, width = 1200, height = 800, res = 300)
plot(iris$Sepal.Length, iris$Sepal.Width, col = iris$Species, pch = 16, las = 1)
dev.off()</code></pre>
<pre><code>## quartz_off_screen 
##                 2</code></pre>
<pre class="r"><code>pdf(file = if(onefile) &quot;Rplots.pdf&quot; else &quot;Rplot%03d.pdf&quot;,
    width, height, onefile, family, title, fonts, version,
    paper, encoding, bg, fg, pointsize, pagecentre, colormodel,
    useDingbats, useKerning, fillOddEven, compress)</code></pre>
<p>width, height – the width and height of the graphics region in inches. The default values are 7.</p>
<pre class="r"><code>pdf(file = &quot;output/co2_uptake.pdf&quot;)
plot(uptake ~ conc, data = CO2, pch = 16, col = &quot;blue&quot;, main = &quot;Carbon Dioxide Uptake in Grass Plants&quot;, las = 1)
dev.off()</code></pre>
<pre><code>## quartz_off_screen 
##                 2</code></pre>
<pre class="r"><code>list.files(&quot;output&quot;)</code></pre>
<pre><code>## [1] &quot;co2_uptake.pdf&quot; &quot;iris_sepal.png&quot; &quot;Md_demo.html&quot;   &quot;Md_demo.Rmd&quot;</code></pre>
</div>
</div>
<div id="getting-data-in-and-out-of-r" class="section level1">
<h1>Getting data in and out of R</h1>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/en/2/2c/Banksy_Better_Out_Than_In_New_York_City_2013.png" alt="You know nothing. Official promotion logo for Banksy’s October 2013 artist residency in New York City. Photo: Banksy" />
<p class="caption">You know nothing. Official promotion logo for Banksy’s October 2013 artist residency in New York City. Photo: Banksy</p>
</div>
<!-- When planning to import your data from external files to R, then -->
<!-- + avoid whitespaces in your file names, replace these with `.`,`_` or `-` -->
<!-- + don't use special characters like `,` `?` `#` `*` `@` `$` `%` `|` `^` `{` `}` `(` `)` `[` `]` `\` `/` -->
<div id="import-tabular-data" class="section level2">
<h2>Import tabular data</h2>
<p><code>read.table</code>, <code>read.csv</code>, <code>read.delim</code> functions allow to create data frames, where different columns may contain different type of data – <code>numeric</code>, <code>character</code> etc. <code>read.table</code> is the basic function with values separated by white space <code>&quot;&quot;</code> (one or more spaces, tabs, newlines). <code>read.csv</code> is a wrapper around it and expects comma <code>,</code> as a field separator and <code>read.delim</code> expects <code>tab</code> separator <code>\t</code>.</p>
<p>Other important arguments of <code>read.table</code> are:</p>
<ul>
<li><code>dec = &quot;.&quot;</code> the character used in the file for decimal points. In many cases ignorant people use comma as decimal separator.</li>
<li><code>stringsAsFactors =</code> default setting is TRUE and character data is converted into factors.</li>
<li><code>na.string = &quot;NA&quot;</code> a character vector of strings which are to be interpreted as NA values. Blank fields are also considered to be missing values in logical, integer, numeric and complex fields.<br />
</li>
<li><code>skip =</code> the number of lines of the data file to skip before beginning to read data.</li>
</ul>
<p>We use survey data (%) of eating fruits and vegetables within last 7 days from Estonian <a href="http://www.tai.ee/en/">Institute for Health Development</a>. Don’t mind the file extension .csv, it’s values are tab separated. TAI offers different download formats, but mostly in useless forms (even for .csv and .txt files). Only “Tabeldieraldusega pealkirjata tekst (.csv)” and “Semikooloneraldusega pealkirjata tekst (.csv)” are in a suitable rectangular format, although lacking column headers. We have to identify and add column headers separately and fix character encoding.</p>
<pre class="r"><code>fruit &lt;- read.table(&quot;data/TKU10m.csv&quot;) # tab separated text
colnames(fruit) &lt;- c(&quot;Year&quot;, &quot;Foodstuff&quot;, &quot;Consumption&quot;, &quot;Gender&quot;, &quot;AGE16-24&quot;, &quot;AGE25-34&quot;, &quot;AGE35-44&quot;, &quot;AGE45-54&quot;, &quot;AGE55-64&quot;)
head(fruit)</code></pre>
<pre><code>##   Year Foodstuff     Consumption Gender AGE16-24 AGE25-34 AGE35-44
## 1 1994   Puuvili Ei s\xf6\xf6nud  Mehed     32.3     24.8     33.8
## 2 1994   Puuvili Ei s\xf6\xf6nud Naised     14.7     15.0     18.1
## 3 1994   Puuvili   1-2 p\xe4eval  Mehed     40.3     45.1     40.4
## 4 1994   Puuvili   1-2 p\xe4eval Naised     40.0     43.8     43.2
## 5 1994   Puuvili   3-5 p\xe4eval  Mehed     22.6     23.0     17.7
## 6 1994   Puuvili   3-5 p\xe4eval Naised     32.0     24.8     25.8
##   AGE45-54 AGE55-64
## 1     34.0     52.4
## 2     22.8     39.0
## 3     43.3     33.3
## 4     46.2     42.1
## 5     16.3     11.9
## 6     26.0     15.2</code></pre>
<pre class="r"><code># Lets translate some variables to english by changing factor labels
fruit$Foodstuff  &lt;- factor(fruit$Foodstuff, levels = c(&quot;K\xf6\xf6givili&quot;,&quot;Puuvili&quot;), labels = c(&quot;Vegetables&quot;, &quot;Fruits&quot;))
fruit$Consumption &lt;-  factor(fruit$Consumption, levels = c(&quot;Ei s\xf6\xf6nud&quot;, &quot;1-2 p\xe4eval&quot;, &quot;3-5 p\xe4eval&quot;, &quot;6-7 p\xe4eval&quot;), labels = c(&quot;No&quot;, &quot;1-2 days&quot;, &quot;3-5 days&quot;, &quot;6-7 days&quot;))
fruit$Gender &lt;-  factor(fruit$Gender, levels = c(&quot;Mehed&quot;, &quot;Naised&quot;), labels = c(&quot;Males&quot;, &quot;Females&quot;))                            
head(fruit)</code></pre>
<pre><code>##   Year Foodstuff Consumption  Gender AGE16-24 AGE25-34 AGE35-44 AGE45-54
## 1 1994    Fruits          No   Males     32.3     24.8     33.8     34.0
## 2 1994    Fruits          No Females     14.7     15.0     18.1     22.8
## 3 1994    Fruits    1-2 days   Males     40.3     45.1     40.4     43.3
## 4 1994    Fruits    1-2 days Females     40.0     43.8     43.2     46.2
## 5 1994    Fruits    3-5 days   Males     22.6     23.0     17.7     16.3
## 6 1994    Fruits    3-5 days Females     32.0     24.8     25.8     26.0
##   AGE55-64
## 1     52.4
## 2     39.0
## 3     33.3
## 4     42.1
## 5     11.9
## 6     15.2</code></pre>
<p>Table of downloadable R .csv datasets to play around and test things is for example available <a href="https://vincentarelbundock.github.io/Rdatasets/datasets.html">here</a>. As you can see, you can use URL to download data directly from web.</p>
<pre class="r"><code>airquality &lt;- read.csv(&quot;https://vincentarelbundock.github.io/Rdatasets/csv/datasets/airquality.csv&quot;)
head(airquality)</code></pre>
<pre><code>##   X Ozone Solar.R Wind Temp Month Day
## 1 1    41     190  7.4   67     5   1
## 2 2    36     118  8.0   72     5   2
## 3 3    12     149 12.6   74     5   3
## 4 4    18     313 11.5   62     5   4
## 5 5    NA      NA 14.3   56     5   5
## 6 6    28      NA 14.9   66     5   6</code></pre>
<div id="readr-package" class="section level3">
<h3><code>readr</code> package</h3>
<p>You can import tabular data using read_ functions from <code>readr</code> package. Compared to base R functions like <code>read.csv()</code>, <code>readr</code> is much faster (important for very large datasets) and gives more convenient output:</p>
<ul>
<li>it never converts strings to factors,</li>
<li>can parse date/times, and</li>
<li>it leaves the column names as in raw data.</li>
</ul>
<p>We can compare what happens with column names in case of <code>read.csv</code> and <code>read_csv</code>:</p>
<p><code>base::read.csv</code> changes column names (1st row):</p>
<pre class="r"><code>read.csv(textConnection(&quot;1 column, my data
               2,3
               4,5&quot;))</code></pre>
<pre><code>##   X1.column my.data
## 1         2       3
## 2         4       5</code></pre>
<p><code>readr::read_csv</code> leaves column names intact:</p>
<pre class="r"><code>library(readr)
read_csv(&quot;1 column, my data
              2,3
              4,5&quot;)  </code></pre>
<pre><code>## # A tibble: 2 x 2
##   `1 column` `my data`
##        &lt;int&gt;     &lt;int&gt;
## 1          2         3
## 2          4         5</code></pre>
<p>Note also that in case of <code>read_csv</code> you can directly paste your comma separated text into function (instead trough textConnection).</p>
<p>The first two arguments of <code>read_csv()</code> are:</p>
<ul>
<li><code>file</code>: path (or URL) to the file you want to load. Readr can automatically decompress files ending in .zip, .gz, .bz2, and .xz.</li>
<li><code>col_names</code>: column names. 3 options: TRUE (the default); FALSE numbers columns sequentially from X1 to Xn. A character vector, used as column names. If these don’t match up with the columns in the data, you’ll get a warning message.</li>
</ul>
<!-- `read_fwf()` reads fixed width files. You can specify fields either by their widths with `fwf_widths()` or their position with `fwf_positions()`.  -->
<p><code>read_table()</code> reads a common variation of fixed width files where columns are separated by white space.</p>
<pre class="r"><code>install.packages(&quot;readr&quot;)
library(readr)
read_table() # read the type of textual data where each column is separate by whitespace
read_csv() # reads comma delimited files, 
read_tsv() # reads tab delimited files, 
read_delim() # reads in files with a user supplied delimiter.</code></pre>
<p>Importantly, <code>read_</code> functions expect specific delimiter: comma for _csv, tab for _tsv etc., and only <code>read_delim</code> has argument for specifying delimiter to be used.</p>
<!-- #### Change column type -->
<!-- ```{r, eval=FALSE} -->
<!-- read_csv("mypath.csv", col_types = col(x = col_integer(), treatment = col_character())) -->
<!-- ``` -->
<!-- You can specify the following types of columns: -->
<!-- + `col_integer()` (i) and `col_double()` (d) specify integer and doubles. -->
<!-- + `col_logical()` (l) parses TRUE, T, FALSE and F into a logical vector. -->
<!-- + `col_character()` (c) leaves strings as is. -->
<!-- + `col_number()` (n) is a more flexible parser for numbers embedded in other strings. It will look for the first number in a string, ignoring non-numeric prefixes and suffixes. -->
<!-- + `col_factor()` (f) allows you to load data directly into a factor if you know what the levels are. -->
<!-- + `col_skip()` (_, -) completely ignores a column. -->
<!-- + `col_date()` (D), `col_datetime()` (T) and `col_time()` (t) parse into dates, date times, and times. -->
<!-- Each column parser has a one letter abbreviation, which you can use instead of the full function call (assuming you're happy with the default arguments): -->
<!-- ```{r, eval=FALSE} -->
<!-- read_csv("mypath.csv", col_types = cols(x = "i", treatment = "c")) -->
<!-- ``` -->
<!-- Each `col_XYZ()` function also has a corresponding `parse_XYZ()` that you can use on a character vector. -->
<!-- ```{r} -->
<!-- parse_integer(c("1", "2", "3")) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- parse_logical(c("TRUE", "FALSE", "NA")) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- parse_number(c("$1000", "20%", "3,000")) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- parse_datetime("2010-10-01T2010") -->
<!-- ``` -->
<!-- ```{r} -->
<!-- parse_date("2010-10-01") -->
<!-- ``` -->
<!-- ```{r} -->
<!-- parse_time("20:10:01") -->
<!-- ``` -->
<!-- ```{r} -->
<!-- parse_date("01/02/15", "%m/%d/%y") -->
<!-- ``` -->
<!-- ```{r} -->
<!-- parse_date("01/02/15", "%d/%m/%y") -->
<!-- ``` -->
<!-- ```{r} -->
<!-- parse_date("01/02/15", "%y/%m/%d") -->
<!-- ``` -->
</div>
</div>
<div id="import-ms-excel" class="section level2">
<h2>Import MS Excel</h2>
<p>There are several libraries and functions available to import MS excel workbooks into R, like <code>XLConnect</code>,<code>gdata::read.xls()</code>, <code>xlsx</code>. <code>XLConnect</code> is a powerful package for working with .xls(x) files, but it depends on Java and has memory limitations: you’ll never know when your script crashes. <code>readxl</code> package contains only two verbs and is very easy to use.</p>
<pre class="r"><code>library(readxl)
xlsfile &lt;- &quot;data/ECIS_140317_MFT_1.xls&quot; # 96-well multi frequency real-time impedance data
sheets &lt;- excel_sheets(xlsfile) 
sheets</code></pre>
<pre><code>##  [1] &quot;Details&quot;    &quot;Comments&quot;   &quot;Z 1000 Hz&quot;  &quot;R 1000 Hz&quot;  &quot;C 1000 Hz&quot; 
##  [6] &quot;Z 2000 Hz&quot;  &quot;R 2000 Hz&quot;  &quot;C 2000 Hz&quot;  &quot;Z 4000 Hz&quot;  &quot;R 4000 Hz&quot; 
## [11] &quot;C 4000 Hz&quot;  &quot;Z 8000 Hz&quot;  &quot;R 8000 Hz&quot;  &quot;C 8000 Hz&quot;  &quot;Z 16000 Hz&quot;
## [16] &quot;R 16000 Hz&quot; &quot;C 16000 Hz&quot; &quot;Z 32000 Hz&quot; &quot;R 32000 Hz&quot; &quot;C 32000 Hz&quot;
## [21] &quot;Z 64000 Hz&quot; &quot;R 64000 Hz&quot; &quot;C 64000 Hz&quot;</code></pre>
<pre class="r"><code>z &lt;- read_excel(xlsfile, sheets[3]) # we import 3rd sheet &quot;Z 1000 Hz&quot;
dim(z)</code></pre>
<pre><code>## [1] 647  97</code></pre>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="en" dir="ltr">
Extract tables from messy spreadsheets with jailbreakr <a href="https://t.co/9wJfDj0cLM">https://t.co/9wJfDj0cLM</a> <a href="https://twitter.com/hashtag/rstats?src=hash">#rstats</a> <a href="https://twitter.com/hashtag/DataScience?src=hash">#DataScience</a>
</p>
— R-bloggers (<span class="citation">@Rbloggers</span>) <a href="https://twitter.com/Rbloggers/status/766226281859997697">August 18, 2016</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js"charset="utf-8"></script>
</div>
<div id="import-ods" class="section level2">
<h2>Import ODS</h2>
<p>To import Open Document Spreadsheets .ods files into R you can try <a href="https://github.com/chainsawriot/readODS">following approach</a>.</p>
<pre class="r"><code>library(readODS)
read_ods(&quot;table.ods&quot;, header = TRUE) ## return only the first sheet
read_ods(&quot;multisheet.ods&quot;, sheet = 2) ## return the second sheet </code></pre>
<!-- ## PDF tables -->
<!-- PDF table extractor -- `Tabula` - exists as both a server application, accessed via a web browser, or as a service using the tabula extractor Java application. The (`tabulizer` R package)[https://github.com/ropenscilabs/tabulizer] provides a wrapper for tabula extractor (bundled within the package), that lets you access the service via it's command line calls. (One dependency you do need to take care of is to have Java installed; adding Java into an RStudio docker container would be one way of taking care of this.) -->
<!-- You can try this code with [more instructions on `github`](https://github.com/ropenscilabs/tabulizer) to install package (if rJava is installed successfully...). -->
<!-- ```{r, eval=FALSE} -->
<!-- devtools::install_github("ropenscilabs/tabulizer") -->
<!-- library("tabulizer") -->
<!-- f <- system.file("examples", "data.pdf", package = "tabulizer") -->
<!-- out1 <- extract_tables(f) -->
<!-- str(out1) -->
<!-- ``` -->
</div>
<div id="import-spss-sas-etc." class="section level2">
<h2>Import SPSS, SAS etc.</h2>
<p><code>foreign</code> package provies functions for reading and writing data stored by Minitab, S, SAS, SPSS, Stata, etc.</p>
<pre class="r"><code>library(foreign)
mydata &lt;- read.spss(&quot;mydata.sav&quot;) # import spss data file, returns list
mydata &lt;- read.spss(&quot;mydata.sav&quot;, to.data.frame = TRUE) # returns data.frame</code></pre>
</div>
<div id="import-all-datasets-from-directory" class="section level2">
<h2>Import all datasets from directory</h2>
<p>We can use <code>sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)</code> or <code>lapply(X, FUN, ...)</code> functions to iterate through vector or list of files, respectively. Three dots <code>...</code> shows that you can pass further arguments to your function (FUN).</p>
<pre class="r"><code>data_files &lt;- list.files(path = &quot;data&quot;, pattern = &quot;.csv&quot;, full.names = TRUE) # 
data_files # ups, we have only one file</code></pre>
<pre><code>## [1] &quot;data/test.csv&quot;   &quot;data/test2.csv&quot;  &quot;data/TKU10m.csv&quot;</code></pre>
<pre class="r"><code>datasets &lt;- sapply(data_files, read.table, simplify = FALSE, USE.NAMES = TRUE) # sapply returns vector or matrix, simplify = FALSE outputs list
str(datasets)</code></pre>
<pre><code>## List of 3
##  $ data/test.csv  :&#39;data.frame&#39;: 6 obs. of  3 variables:
##   ..$ V1: Factor w/ 6 levels &quot;ana,&quot;,&quot;bob,&quot;,..: 4 1 2 3 6 5
##   ..$ V2: Factor w/ 6 levels &quot;12,&quot;,&quot;23.2,&quot;,..: 6 2 1 4 5 3
##   ..$ V3: Factor w/ 3 levels &quot;f&quot;,&quot;m&quot;,&quot;sex&quot;: 3 2 1 2 1 1
##  $ data/test2.csv :&#39;data.frame&#39;: 6 obs. of  3 variables:
##   ..$ V1: Factor w/ 6 levels &quot;ana;&quot;,&quot;bob;&quot;,..: 4 1 2 3 6 5
##   ..$ V2: Factor w/ 6 levels &quot;12;&quot;,&quot;23,2;&quot;,..: 6 2 1 4 5 3
##   ..$ V3: Factor w/ 3 levels &quot;f&quot;,&quot;m&quot;,&quot;sex&quot;: 3 2 1 2 1 1
##  $ data/TKU10m.csv:&#39;data.frame&#39;: 176 obs. of  9 variables:
##   ..$ V1: int [1:176] 1994 1994 1994 1994 1994 1994 1994 1994 1994 1994 ...
##   ..$ V2: Factor w/ 2 levels &quot;K\xf6\xf6givili&quot;,..: 2 2 2 2 2 2 2 2 1 1 ...
##   ..$ V3: Factor w/ 4 levels &quot;1-2 p\xe4eval&quot;,..: 4 4 1 1 2 2 3 3 4 4 ...
##   ..$ V4: Factor w/ 2 levels &quot;Mehed&quot;,&quot;Naised&quot;: 1 2 1 2 1 2 1 2 1 2 ...
##   ..$ V5: num [1:176] 32.3 14.7 40.3 40 22.6 32 4.8 13.3 21.3 17.6 ...
##   ..$ V6: num [1:176] 24.8 15 45.1 43.8 23 24.8 7.1 16.3 22.1 15.7 ...
##   ..$ V7: num [1:176] 33.8 18.1 40.4 43.2 17.7 25.8 8.1 12.9 25 16.1 ...
##   ..$ V8: num [1:176] 34 22.8 43.3 46.2 16.3 26 6.4 5.1 31.7 19.6 ...
##   ..$ V9: num [1:176] 52.4 39 33.3 42.1 11.9 15.2 2.4 3.7 39 28.4 ...</code></pre>
<!-- If you have datasets with same column names, you can import all datasets as a list and rbind them into one data.frame. Here we concatenate our single data.frame in `datasets` object. -->
<!-- `do.call(rbind, my_list_of_dataframes)` is base R solution to this task. -->
<!-- ```{r} -->
<!-- nrow(datasets[[1]]) # how many rows in our original data? datasets is a list. -->
<!-- rbound_datasets <-  do.call(rbind, c(datasets, datasets)) # bind dataframes in list by rows -->
<!-- nrow(rbound_datasets) # how many rows we have now -->
<!-- ``` -->
<!-- Alternative solution is `bind_rows` from `dplyr` package. -->
<!-- ```{r} -->
<!-- rbound_datasets2 <- dplyr::bind_rows(c(datasets, datasets)) -->
<!-- nrow(rbound_datasets2) # how many rows we have now -->
<!-- ``` -->
</div>
<div id="import-text-file" class="section level2">
<h2>Import text file</h2>
<p>Probably, the most basic form of data to import into R is a simple text file.</p>
<p>Here we write our data to external file <code>ex.data</code> and read it into R using <code>scan()</code> function. Importantly, <code>scan()</code> reads vectors of data which all have the same mode. Default data type is numeric, strings can be specified with the <code>what = &quot;&quot;</code> argument.</p>
<pre class="r"><code>cat(&quot;my title line&quot;, &quot;2 3 5 7&quot;, &quot;11 13 17&quot;, file = &quot;ex.data&quot;, sep = &quot;\n&quot;)
pp &lt;- scan(&quot;ex.data&quot;, skip = 1) # we skip 1st line with title text or we get error
unlink(&quot;ex.data&quot;) # tidy up, unlink deletes the file(s) or directories specified
pp</code></pre>
<pre><code>## [1]  2  3  5  7 11 13 17</code></pre>
<p>In case you dont wan’t or can’t save your text into file (bad for reproducibility!), it’s possible to use <code>textConnection()</code> function to input data into R. <code>\n</code> is a newline character.</p>
<p><code>readLines</code> reads “unorganized” data, this is the function that will read input into R so that we can manipulate it further.</p>
<pre class="r"><code>zzz &lt;- textConnection(&quot;my title line 2 3 5 7 11 13 17 9&quot;) 
pp &lt;- readLines(zzz) # zzz is a connection object
pp</code></pre>
<pre><code>## [1] &quot;my title line 2 3 5 7 11 13 17 9&quot;</code></pre>
<pre class="r"><code>close(zzz) # close connection</code></pre>
<pre class="r"><code>pp &lt;- scan(textConnection(&quot;my title line\n2 3 5 7\n11 13 17 9&quot;), skip = 1)
pp</code></pre>
<pre><code>## [1]  2  3  5  7 11 13 17  9</code></pre>
<p>Text in <code>textConnection</code> call can be already structured, so you can quickly import copy-paste data from screen into R.</p>
<pre class="r"><code>zzz &lt;- textConnection(&quot;my title line 
                      2 3 5 7
                      11 13 17 9&quot;)
a &lt;- scan(zzz, skip = 2) # lets skip 1st two lines
a</code></pre>
<pre><code>## [1] 11 13 17  9</code></pre>
<p>Scanned data can be coerced into rectangular matrix. We have 2 rows of numbers in our text string shown above therefore we set <code>nrow = 2</code> and we need to specify that data is inserted into matrix rowwise <code>byrow = TRUE</code> (default option is FALSE) to keep original data structure.</p>
<pre class="r"><code>matrix(pp, nrow = 2, byrow = TRUE)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    2    3    5    7
## [2,]   11   13   17    9</code></pre>
</div>
</div>
<div id="tidy-data" class="section level1">
<h1>Tidy data</h1>
<p>To standardize data analysis, you must start by standardizing data structure. Tidy data arranges values so that the relationships between variables in a data set will parallel the relationship between vectors in R’s storage objects. R stores tabular data as a data frame, a list of atomic vectors arranged to look like a table. Each column in the table is a vector. In tidy data, each variable in the data set is assigned to its own column, i.e., its own vector in the data frame. As a result, you can extract all the values of a variable in a tidy data set by extracting the column vector that contains the variable, i.e. table1$cases. Because R does vector calculations element by element, it is fastest when you compare vectors directly side-by-side.</p>
<ul>
<li>value is the result of a single measurement (167 cm). = cell</li>
<li>variable is what you measure (length, height), or a factor (sex, treatment). = column</li>
<li>observation or data point is a set of measurements that made under similar conditions (John’s height and weight measured on 23.04.2012). = row</li>
<li>Observational unit (who or what was measured): subject no. 1, etc. = 1st column</li>
<li>Type of observational unit: humans, mice, cell lysates, etc. = table</li>
</ul>
<p>Tidy data: each value is in its own “cell”, each variable in its own column, each observation in its own row, and each type of observational unit in its own table - useful for grouping, summarizing, filtering, and plotting. In a tidy table the order of columns is:</p>
<ol style="list-style-type: decimal">
<li>Observational unit</li>
<li>Factors &amp; everything that was not measured (values fixed at experimental planning stage)</li>
<li>Measured Vars.</li>
</ol>
<p>Keeping the data in this form allows multiple tools to be used in sequence. NB! There are always more possible Vars in your data than were measured – do weight and height and get BMI as a bonus.</p>
<div id="melt-data-into-long-format" class="section level2">
<h2>Melt data into long format</h2>
<p>First we load a bunch of <strong>tidyverse</strong> backages:</p>
<pre class="r"><code>library(tidyr)
library(tibble)
library(reshape2)
library(dplyr)
library(readr)</code></pre>
<p><code>reshape2::melt(df)</code> - treats the variables that contain factors or strings as ‘id.vars’, which remain fixed; and melts all numeric columns.</p>
<p>We start by making a mock table:</p>
<pre class="r"><code>subject &lt;- c(&quot;Tim&quot;, &quot;Ann&quot;, &quot;Jill&quot;)
sex &lt;- c(&quot;M&quot;, &quot;F&quot;, &quot;F&quot;)
control &lt;- c(23, 31, 30)
experiment_1 &lt;- c(34, 38, 36)
experiment_2 &lt;- c(40, 42, 44)
df &lt;- tibble(subject, sex, control, experiment_1, experiment_2)
df</code></pre>
<pre><code>## # A tibble: 3 x 5
##   subject   sex control experiment_1 experiment_2
##     &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;
## 1     Tim     M      23           34           40
## 2     Ann     F      31           38           42
## 3    Jill     F      30           36           44</code></pre>
<p>Next we melt it by providing the df as the only argument to <code>reshape2::melt</code>:</p>
<pre class="r"><code>melt(df) # this gives identical result.</code></pre>
<pre><code>## Using subject, sex as id variables</code></pre>
<pre><code>##   subject sex     variable value
## 1     Tim   M      control    23
## 2     Ann   F      control    31
## 3    Jill   F      control    30
## 4     Tim   M experiment_1    34
## 5     Ann   F experiment_1    38
## 6    Jill   F experiment_1    36
## 7     Tim   M experiment_2    40
## 8     Ann   F experiment_2    42
## 9    Jill   F experiment_2    44</code></pre>
<p>We can also use pipe operator (<code>%&gt;%</code>):</p>
<pre class="r"><code>df_melted &lt;- df %&gt;% melt %&gt;% tbl_df # we further convert dataframe to a tibble by tbl_df</code></pre>
<pre><code>## Using subject, sex as id variables</code></pre>
<pre class="r"><code>df_melted</code></pre>
<pre><code>## # A tibble: 9 x 4
##   subject   sex     variable value
##     &lt;chr&gt; &lt;chr&gt;       &lt;fctr&gt; &lt;dbl&gt;
## 1     Tim     M      control    23
## 2     Ann     F      control    31
## 3    Jill     F      control    30
## 4     Tim     M experiment_1    34
## 5     Ann     F experiment_1    38
## 6    Jill     F experiment_1    36
## 7     Tim     M experiment_2    40
## 8     Ann     F experiment_2    42
## 9    Jill     F experiment_2    44</code></pre>
<p>Here we are more explicit about arguments to <code>melt()</code>. If you provide only <code>id.vars</code> or <code>measure.vars</code>, <code>R</code> will assume that all other variables belong to the argument that was not provided:</p>
<pre class="r"><code>df %&gt;% melt(id.vars = c(&quot;subject&quot;, &quot;sex&quot;),   # all the variables to keep, but not split apart 
                        measure.vars = c(&quot;control&quot;, &quot;experiment_1&quot;, &quot;experiment_2&quot;),
                     variable.name = &quot;experiment&quot;, # Name of the destination column for factors that are taken from names of melted columns
                     value.name = &quot;nr.of.counts&quot; # name of the newly made column which contains the values
) %&gt;% tbl_df</code></pre>
<pre><code>## # A tibble: 9 x 4
##   subject   sex   experiment nr.of.counts
##     &lt;chr&gt; &lt;chr&gt;       &lt;fctr&gt;        &lt;dbl&gt;
## 1     Tim     M      control           23
## 2     Ann     F      control           31
## 3    Jill     F      control           30
## 4     Tim     M experiment_1           34
## 5     Ann     F experiment_1           38
## 6    Jill     F experiment_1           36
## 7     Tim     M experiment_2           40
## 8     Ann     F experiment_2           42
## 9    Jill     F experiment_2           44</code></pre>
<p>Alternatively we can use <code>tidyr::gather</code> to melt tables:</p>
<ul>
<li>1st argument (here <code>key = experiment</code>) names the key factor or character column, whose values will be the names of the columns, which are melted into a single column.</li>
<li>The 2nd argument (here <code>value = value</code>) is the name of the resultant single column, which contains the values.</li>
<li>The third argument (here <code>3:ncol(df)</code>) specifies the columns, which are melted into a single column; in the version <code>c(-subject, -sex)</code> every column except these 2 is melted.</li>
</ul>
<pre class="r"><code>df %&gt;% gather(key = experiment, value = value, 3:ncol(df))</code></pre>
<pre><code>## # A tibble: 9 x 4
##   subject   sex   experiment value
##     &lt;chr&gt; &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt;
## 1     Tim     M      control    23
## 2     Ann     F      control    31
## 3    Jill     F      control    30
## 4     Tim     M experiment_1    34
## 5     Ann     F experiment_1    38
## 6    Jill     F experiment_1    36
## 7     Tim     M experiment_2    40
## 8     Ann     F experiment_2    42
## 9    Jill     F experiment_2    44</code></pre>
<pre class="r"><code># df_melted3&lt;-df %&gt;% gather(experiment, value, 3:ncol(df)) works as well.</code></pre>
<pre class="r"><code>df %&gt;% gather(experiment, value, c(-subject, -sex))</code></pre>
<pre><code>## # A tibble: 9 x 4
##   subject   sex   experiment value
##     &lt;chr&gt; &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt;
## 1     Tim     M      control    23
## 2     Ann     F      control    31
## 3    Jill     F      control    30
## 4     Tim     M experiment_1    34
## 5     Ann     F experiment_1    38
## 6    Jill     F experiment_1    36
## 7     Tim     M experiment_2    40
## 8     Ann     F experiment_2    42
## 9    Jill     F experiment_2    44</code></pre>
</div>
<div id="cast-melted-table-back-into-wide" class="section level2">
<h2>Cast melted table back into wide</h2>
<p>While there is only one correct tidy long format, there exist several possible wide formats. Which one to choose depends on what you want to use the wide table for (i.e., on the specific statistical application)</p>
<pre class="r"><code>df_melted %&gt;% dcast(subject + sex ~ value)</code></pre>
<pre><code>##   subject sex 23 30 31 34 36 38 40 42 44
## 1     Ann   F NA NA 31 NA NA 38 NA 42 NA
## 2    Jill   F NA 30 NA NA 36 NA NA NA 44
## 3     Tim   M 23 NA NA 34 NA NA 40 NA NA</code></pre>
<p>Uups!</p>
<pre class="r"><code>df_melted %&gt;% dcast(subject + sex ~ variable)</code></pre>
<pre><code>##   subject sex control experiment_1 experiment_2
## 1     Ann   F      31           38           42
## 2    Jill   F      30           36           44
## 3     Tim   M      23           34           40</code></pre>
<p><code>dcast()</code> starts with melted data and reshapes it into a wide format using a formula. The format is <code>newdata &lt;- dcast(md, formula, FUN)</code> where md is the melted data. The formula takes the form:</p>
<ul>
<li><code>rowvar1 + rowvar2 + … ~ colvar1 + colvar2 + …</code></li>
<li><code>rowvar1 + rowvar2 + …</code> define the rows, and</li>
<li><code>colvar1 + colvar2 + …</code> define the columns.</li>
</ul>
<blockquote>
<p>Important! the right-hand argument to the equation <code>~</code> is the column that contains the factor levels or character vectors that will be tranformed into column names of the wide table.</p>
</blockquote>
<p>We can use <code>tidyr::spread()</code> as an alternative to <code>dcast()</code>. Here <strong>variable</strong> is the factor or character column, whose values will be transformed into column names and <strong>value</strong> is the name of the column, which contains all the values that are spread into the new columns.</p>
<pre class="r"><code>df_melted %&gt;% spread(key = variable, value = value)</code></pre>
<pre><code>## # A tibble: 3 x 5
##   subject   sex control experiment_1 experiment_2
## *   &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;
## 1     Ann     F      31           38           42
## 2    Jill     F      30           36           44
## 3     Tim     M      23           34           40</code></pre>
</div>
<div id="separate" class="section level2">
<h2>Separate</h2>
<p>Separate separates one column into many:</p>
<pre class="r"><code>df &lt;- tibble(country = c(&quot;Albania&quot;), disease.cases = c(&quot;80/1000&quot;))
df</code></pre>
<pre><code>## # A tibble: 1 x 2
##   country disease.cases
##     &lt;chr&gt;         &lt;chr&gt;
## 1 Albania       80/1000</code></pre>
<p>We want to separate <code>80/1000</code> at the slash. Default action of separate is to look at the any sequence of non-alphanumeric values:</p>
<pre class="r"><code>df %&gt;% separate(disease.cases, into = c(&quot;cases&quot;, &quot;thousand&quot;)) # works ok in this case!</code></pre>
<pre><code>## # A tibble: 1 x 3
##   country cases thousand
## *   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;
## 1 Albania    80     1000</code></pre>
<p>We can supply regular expression, matching <code>/</code>:</p>
<pre class="r"><code>df %&gt;% separate(disease.cases, into = c(&quot;cases&quot;, &quot;thousand&quot;), sep = &quot;/&quot;) #match slash</code></pre>
<pre><code>## # A tibble: 1 x 3
##   country cases thousand
## *   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;
## 1 Albania    80     1000</code></pre>
<pre class="r"><code>df %&gt;% separate(disease.cases, into = c(&quot;cases&quot;, &quot;thousand&quot;), sep = &quot;\\W&quot;) # any non-alphanumeric</code></pre>
<pre><code>## # A tibble: 1 x 3
##   country cases thousand
## *   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;
## 1 Albania    80     1000</code></pre>
<pre class="r"><code>df %&gt;% separate(disease.cases, into=c(&quot;cases&quot;, &quot;thousand&quot;), sep = 2)</code></pre>
<pre><code>## # A tibble: 1 x 3
##   country cases thousand
## *   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;
## 1 Albania    80    /1000</code></pre>
<pre class="r"><code>df %&gt;% separate(disease.cases, into=c(&quot;cases&quot;, &quot;thousand&quot;), sep = -6)</code></pre>
<pre><code>## # A tibble: 1 x 3
##   country cases thousand
## *   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;
## 1 Albania    80    /1000</code></pre>
<pre class="r"><code>df &lt;- tibble(index = c(1, 2), taxon = c(&quot;Procaryota; Bacteria; Alpha-Proteobacteria; Escharichia&quot;, &quot;Eukaryota; Chordata&quot;))
df %&gt;% separate(taxon, c(&#39;riik&#39;, &#39;hmk&#39;, &quot;klass&quot;, &quot;perekond&quot;), sep = &#39;;&#39;, extra = &quot;merge&quot;, fill = &quot;right&quot;)</code></pre>
<pre><code>## # A tibble: 2 x 5
##   index       riik       hmk                 klass     perekond
## * &lt;dbl&gt;      &lt;chr&gt;     &lt;chr&gt;                 &lt;chr&gt;        &lt;chr&gt;
## 1     1 Procaryota  Bacteria  Alpha-Proteobacteria  Escharichia
## 2     2  Eukaryota  Chordata                  &lt;NA&gt;         &lt;NA&gt;</code></pre>
<p>Some special cases:</p>
<pre class="r"><code>df &lt;- tibble(index = c(1, 2), taxon = c(&quot;Procaryota || Bacteria || Alpha-Proteobacteria || Escharichia&quot;, &quot;Eukaryota || Chordata&quot;))
df %&gt;% separate(taxon, c(&quot;riik&quot;, &quot;hmk&quot;, &quot;klass&quot;, &quot;perekond&quot;), sep = &quot;\\|\\|&quot;, extra = &quot;merge&quot;, fill = &quot;right&quot;)</code></pre>
<pre><code>## # A tibble: 2 x 5
##   index        riik        hmk                  klass     perekond
## * &lt;dbl&gt;       &lt;chr&gt;      &lt;chr&gt;                  &lt;chr&gt;        &lt;chr&gt;
## 1     1 Procaryota   Bacteria   Alpha-Proteobacteria   Escharichia
## 2     2  Eukaryota    Chordata                   &lt;NA&gt;         &lt;NA&gt;</code></pre>
<pre class="r"><code>df &lt;- tibble(index = c(1, 2), taxon = c(&quot;Procaryota.Bacteria.Alpha-Proteobacteria.Escharichia&quot;, &quot;Eukaryota.Chordata&quot;))
df %&gt;% separate(taxon, c(&#39;riik&#39;, &#39;hmk&#39;, &quot;klass&quot;, &quot;perekond&quot;), sep = &#39;[.]&#39;, extra = &quot;merge&quot;, fill = &quot;right&quot;)</code></pre>
<pre><code>## # A tibble: 2 x 5
##   index       riik      hmk                klass    perekond
## * &lt;dbl&gt;      &lt;chr&gt;    &lt;chr&gt;                &lt;chr&gt;       &lt;chr&gt;
## 1     1 Procaryota Bacteria Alpha-Proteobacteria Escharichia
## 2     2  Eukaryota Chordata                 &lt;NA&gt;        &lt;NA&gt;</code></pre>
<pre class="r"><code>df &lt;- tibble(index = c(1, 2), taxon = c(&quot;Procaryota.Bacteria,Alpha-Proteobacteria.Escharichia&quot;, &quot;Eukaryota.Chordata&quot;))
df %&gt;% separate(taxon, c(&#39;riik&#39;, &#39;hmk&#39;, &quot;klass&quot;, &quot;perekond&quot;), sep = &#39;[,\\.]&#39;, extra = &quot;merge&quot;, fill = &quot;right&quot;) </code></pre>
<pre><code>## # A tibble: 2 x 5
##   index       riik      hmk                klass    perekond
## * &lt;dbl&gt;      &lt;chr&gt;    &lt;chr&gt;                &lt;chr&gt;       &lt;chr&gt;
## 1     1 Procaryota Bacteria Alpha-Proteobacteria Escharichia
## 2     2  Eukaryota Chordata                 &lt;NA&gt;        &lt;NA&gt;</code></pre>
<pre class="r"><code># [,\\.] separates by dot or comma. Isn&#39;t that cool?</code></pre>
<p>The companion FUN to separate is <code>unite()</code> - see help (if you should feel the need for it, which you probably wont).</p>
<div id="find-and-replace-helps-to-deal-with-unruly-labelling-inside-columns-containing-strings" class="section level3">
<h3>Find and replace helps to deal with unruly labelling inside columns containing strings</h3>
<p>The idea is to find a pattern in a collection of strings and replace it with something else. <code>String == character vector</code>.</p>
<p>To find and replace we use <code>str_replace_all()</code>, whose base R analogue is <code>gsub()</code>:</p>
<pre class="r"><code>library(stringr)</code></pre>
<pre><code>## 
## Attaching package: &#39;stringr&#39;</code></pre>
<pre><code>## The following object is masked _by_ &#39;.GlobalEnv&#39;:
## 
##     fruit</code></pre>
<pre class="r"><code>bad.df &lt;- tibble(time = c(&quot;t0&quot;, &quot;t1&quot;, &quot;t12&quot;), value = c(2, 4, 9))
bad.df$time &lt;- str_replace_all(bad.df$time, &quot;t&quot;, &quot;&quot;) %&gt;% as.numeric() </code></pre>
<p>Now we have a numeric time column, which can be used in plotting.</p>
<p>or</p>
<p>Here we do the same thing more elegantly by directly parsing numbers from a character string:</p>
<pre class="r"><code>bad.df$time &lt;- parse_number(bad.df$time)</code></pre>
</div>
</div>
<div id="it-is-high-time-to-learn-the-5-verbs-of-dplyr" class="section level2">
<h2>It is high time to learn the 5 verbs of dplyr</h2>
<p>NB! Check the data wrangling cheatsheet and help for further details</p>
<div id="select" class="section level3">
<h3>select</h3>
<p><code>select</code> selects, renames, and re-orders columns</p>
<p>To select columns from sex to value:</p>
<pre class="r"><code>df_melted</code></pre>
<pre><code>## # A tibble: 9 x 4
##   subject   sex     variable value
##     &lt;chr&gt; &lt;chr&gt;       &lt;fctr&gt; &lt;dbl&gt;
## 1     Tim     M      control    23
## 2     Ann     F      control    31
## 3    Jill     F      control    30
## 4     Tim     M experiment_1    34
## 5     Ann     F experiment_1    38
## 6    Jill     F experiment_1    36
## 7     Tim     M experiment_2    40
## 8     Ann     F experiment_2    42
## 9    Jill     F experiment_2    44</code></pre>
<pre class="r"><code>df_melted %&gt;% select(sex:value)</code></pre>
<pre><code>## # A tibble: 9 x 3
##     sex     variable value
##   &lt;chr&gt;       &lt;fctr&gt; &lt;dbl&gt;
## 1     M      control    23
## 2     F      control    31
## 3     F      control    30
## 4     M experiment_1    34
## 5     F experiment_1    38
## 6     F experiment_1    36
## 7     M experiment_2    40
## 8     F experiment_2    42
## 9     F experiment_2    44</code></pre>
<p>To select just 2 columns and rename <em>subject</em> to <em>SUBJ</em>:</p>
<pre class="r"><code>df_melted %&gt;% select(sex, value, SUBJ=subject)</code></pre>
<pre><code>## # A tibble: 9 x 3
##     sex value  SUBJ
##   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;
## 1     M    23   Tim
## 2     F    31   Ann
## 3     F    30  Jill
## 4     M    34   Tim
## 5     F    38   Ann
## 6     F    36  Jill
## 7     M    40   Tim
## 8     F    42   Ann
## 9     F    44  Jill</code></pre>
<p>To select all cols, except sex and value, and rename the <em>subject</em> col:</p>
<pre class="r"><code>df_melted %&gt;% select(-sex, -value, SUBJ=subject)</code></pre>
<pre><code>## # A tibble: 9 x 2
##    SUBJ     variable
##   &lt;chr&gt;       &lt;fctr&gt;
## 1   Tim      control
## 2   Ann      control
## 3  Jill      control
## 4   Tim experiment_1
## 5   Ann experiment_1
## 6  Jill experiment_1
## 7   Tim experiment_2
## 8   Ann experiment_2
## 9  Jill experiment_2</code></pre>
</div>
<div id="mutate" class="section level3">
<h3>mutate</h3>
<p>Mutate adds new columns (and transmute creates new columns while losing the previous columns - see the cheatsheet and help)</p>
<p>Here we firstly create a new column, which contains log-transformed values from the <em>value</em> column, and name it <em>log.value</em>. And secondly we create a new col <em>strange.value</em>, which contains the results of a really silly data transformation including taking a square root.</p>
<pre class="r"><code>df_melted %&gt;% mutate(log.value = log10(value), strange.value= sqrt(value - log.value))</code></pre>
<pre><code>## # A tibble: 9 x 6
##   subject   sex     variable value log.value strange.value
##     &lt;chr&gt; &lt;chr&gt;       &lt;fctr&gt; &lt;dbl&gt;     &lt;dbl&gt;         &lt;dbl&gt;
## 1     Tim     M      control    23  1.361728      4.651696
## 2     Ann     F      control    31  1.491362      5.432185
## 3    Jill     F      control    30  1.477121      5.340681
## 4     Tim     M experiment_1    34  1.531479      5.698116
## 5     Ann     F experiment_1    38  1.579784      6.034916
## 6    Jill     F experiment_1    36  1.556303      5.868875
## 7     Tim     M experiment_2    40  1.602060      6.196607
## 8     Ann     F experiment_2    42  1.623249      6.354270
## 9    Jill     F experiment_2    44  1.643453      6.508191</code></pre>
<p>The same with transmute: note the dropping of some of the original cols, keeping the original <em>subject</em> col and renaming the <em>sex</em> col.</p>
<pre class="r"><code>df_melted %&gt;% transmute(subject, gender=sex, log.value = log10(value))</code></pre>
<pre><code>## # A tibble: 9 x 3
##   subject gender log.value
##     &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;
## 1     Tim      M  1.361728
## 2     Ann      F  1.491362
## 3    Jill      F  1.477121
## 4     Tim      M  1.531479
## 5     Ann      F  1.579784
## 6    Jill      F  1.556303
## 7     Tim      M  1.602060
## 8     Ann      F  1.623249
## 9    Jill      F  1.643453</code></pre>
</div>
<div id="filter" class="section level3">
<h3>filter</h3>
<p>Filter filters rows</p>
<p>Keep rows that have sex level “M” and value &gt;30.</p>
<pre class="r"><code>df_melted %&gt;% filter(sex==&quot;M&quot; &amp; value &lt; 30)</code></pre>
<pre><code>## # A tibble: 1 x 4
##   subject   sex variable value
##     &lt;chr&gt; &lt;chr&gt;   &lt;fctr&gt; &lt;dbl&gt;
## 1     Tim     M  control    23</code></pre>
<p>Keep rows that have sex level “M” or value &gt;30.</p>
<pre class="r"><code>df_melted %&gt;% filter(sex==&quot;M&quot; | value &lt; 30)</code></pre>
<pre><code>## # A tibble: 3 x 4
##   subject   sex     variable value
##     &lt;chr&gt; &lt;chr&gt;       &lt;fctr&gt; &lt;dbl&gt;
## 1     Tim     M      control    23
## 2     Tim     M experiment_1    34
## 3     Tim     M experiment_2    40</code></pre>
<p>Keep rows that have sex level not “M” (which in this case equals “F”) or value &gt;30.</p>
<pre class="r"><code>df_melted %&gt;% filter(sex != &quot;M&quot; | value &lt;= 30)</code></pre>
<pre><code>## # A tibble: 7 x 4
##   subject   sex     variable value
##     &lt;chr&gt; &lt;chr&gt;       &lt;fctr&gt; &lt;dbl&gt;
## 1     Tim     M      control    23
## 2     Ann     F      control    31
## 3    Jill     F      control    30
## 4     Ann     F experiment_1    38
## 5    Jill     F experiment_1    36
## 6     Ann     F experiment_2    42
## 7    Jill     F experiment_2    44</code></pre>
<p>Filtering with regular expression: we keep the rows where <em>subject</em> starts with the letter “T”</p>
<pre class="r"><code>library(stringr)
df_melted %&gt;% filter(subject==(str_subset(subject, &quot;^T&quot;))) </code></pre>
<pre><code>## # A tibble: 3 x 4
##   subject   sex     variable value
##     &lt;chr&gt; &lt;chr&gt;       &lt;fctr&gt; &lt;dbl&gt;
## 1     Tim     M      control    23
## 2     Tim     M experiment_1    34
## 3     Tim     M experiment_2    40</code></pre>
<p>As you can see there are endless vistas here, open for a regular expression fanatic. I so wish I was one!</p>
</div>
<div id="summarise" class="section level3">
<h3>summarise</h3>
<p>Summarise does just that</p>
<p>Here we generate common summary statistics for our value variable. This is all right in a limited sort of way.</p>
<pre class="r"><code>df_melted %&gt;% summarise(MEAN= mean(value), SD= sd(value), MAD=mad(value), N= n(), unique_values_sex= n_distinct(sex))</code></pre>
<pre><code>## # A tibble: 1 x 5
##       MEAN       SD   MAD     N unique_values_sex
##      &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;             &lt;int&gt;
## 1 35.33333 6.614378 7.413     9                 2</code></pre>
<p>To do something more exiting we must first group our observations by some facto(s) levels.</p>
</div>
<div id="group_by" class="section level3">
<h3>group_by</h3>
<p>Groups values for summarising or mutating</p>
<p>When we summarise by <em>sex</em> we will get two values for each summary statistic: for males and females. Aint that sexy?!</p>
<pre class="r"><code>df_melted %&gt;% group_by(sex) %&gt;% summarise(MEAN= mean(value), SD= sd(value), MAD=mad(value), N= n(), unique_values_sex= n_distinct(sex))</code></pre>
<pre><code>## # A tibble: 2 x 6
##     sex     MEAN       SD    MAD     N unique_values_sex
##   &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt;             &lt;int&gt;
## 1     F 36.83333 5.671567 8.1543     6                 1
## 2     M 32.33333 8.621678 8.8956     3                 1</code></pre>
<p>Now we group first by <em>variable</em> and then inside each group again by <em>sex</em>. This is getting complicated …</p>
<pre class="r"><code>df_melted %&gt;% group_by(variable, sex) %&gt;% summarise(MEAN= mean(value), SD= sd(value), MAD=mad(value), N= n(), unique_values_sex= n_distinct(sex))</code></pre>
<pre><code>## # A tibble: 6 x 7
## # Groups:   variable [?]
##       variable   sex  MEAN        SD    MAD     N unique_values_sex
##         &lt;fctr&gt; &lt;chr&gt; &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt;             &lt;int&gt;
## 1      control     F  30.5 0.7071068 0.7413     2                 1
## 2      control     M  23.0        NA 0.0000     1                 1
## 3 experiment_1     F  37.0 1.4142136 1.4826     2                 1
## 4 experiment_1     M  34.0        NA 0.0000     1                 1
## 5 experiment_2     F  43.0 1.4142136 1.4826     2                 1
## 6 experiment_2     M  40.0        NA 0.0000     1                 1</code></pre>
<p>Now we group first by sex and then by variable. Spot the difference!</p>
<pre class="r"><code>df_melted %&gt;% group_by(sex, variable) %&gt;% summarise(MEAN= mean(value), SD= sd(value), MAD=mad(value), N= n(), unique_values_sex= n_distinct(sex))</code></pre>
<pre><code>## # A tibble: 6 x 7
## # Groups:   sex [?]
##     sex     variable  MEAN        SD    MAD     N unique_values_sex
##   &lt;chr&gt;       &lt;fctr&gt; &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt;             &lt;int&gt;
## 1     F      control  30.5 0.7071068 0.7413     2                 1
## 2     F experiment_1  37.0 1.4142136 1.4826     2                 1
## 3     F experiment_2  43.0 1.4142136 1.4826     2                 1
## 4     M      control  23.0        NA 0.0000     1                 1
## 5     M experiment_1  34.0        NA 0.0000     1                 1
## 6     M experiment_2  40.0        NA 0.0000     1                 1</code></pre>
<p>Here we group and then mutate (meaning that the resulting table has as many rows — but more column — than the original table).</p>
<pre class="r"><code>df_melted %&gt;% group_by(sex) %&gt;% mutate(normalised.value=value/mean(value), n2.val=value/sd(value))</code></pre>
<pre><code>## # A tibble: 9 x 6
## # Groups:   sex [2]
##   subject   sex     variable value normalised.value   n2.val
##     &lt;chr&gt; &lt;chr&gt;       &lt;fctr&gt; &lt;dbl&gt;            &lt;dbl&gt;    &lt;dbl&gt;
## 1     Tim     M      control    23        0.7113402 2.667694
## 2     Ann     F      control    31        0.8416290 5.465862
## 3    Jill     F      control    30        0.8144796 5.289544
## 4     Tim     M experiment_1    34        1.0515464 3.943548
## 5     Ann     F experiment_1    38        1.0316742 6.700089
## 6    Jill     F experiment_1    36        0.9773756 6.347453
## 7     Tim     M experiment_2    40        1.2371134 4.639468
## 8     Ann     F experiment_2    42        1.1402715 7.405361
## 9    Jill     F experiment_2    44        1.1945701 7.757998</code></pre>
<p>Compare with a “straight” mutate to note the difference in values.</p>
<pre class="r"><code>df_melted %&gt;% mutate(normalised.value=value/mean(value), n2.val=value/sd(value))</code></pre>
<pre><code>## # A tibble: 9 x 6
##   subject   sex     variable value normalised.value   n2.val
##     &lt;chr&gt; &lt;chr&gt;       &lt;fctr&gt; &lt;dbl&gt;            &lt;dbl&gt;    &lt;dbl&gt;
## 1     Tim     M      control    23        0.6509434 3.477273
## 2     Ann     F      control    31        0.8773585 4.686759
## 3    Jill     F      control    30        0.8490566 4.535574
## 4     Tim     M experiment_1    34        0.9622642 5.140317
## 5     Ann     F experiment_1    38        1.0754717 5.745060
## 6    Jill     F experiment_1    36        1.0188679 5.442688
## 7     Tim     M experiment_2    40        1.1320755 6.047432
## 8     Ann     F experiment_2    42        1.1886792 6.349803
## 9    Jill     F experiment_2    44        1.2452830 6.652175</code></pre>
<!-- ## A more realistic example: -->
<!-- Its not unheard of of one having to analyse a table with less than perfect structure. Yes, life really does suck. Here some column names need to be renamed for consistency, an empty column has to be dropped and column *OTU* must be cleansed from NAs. We will also convert the df to tibble. -->
<!-- ```{r} -->
<!-- y1 <- read.csv("/Users/ulomaivali/Dropbox/Viia kartul/Viia_original.csv") -->
<!-- y1<- y1 %>% rename(KARS2=KARS2.7, TS1=TS1.26, kars1=karS1) %>% -->
<!--   select(-Col53)%>% -->
<!--   drop_na(OTU) %>%  -->
<!--   as_data_frame() -->
<!-- names(y1)  -->
<!-- y1 -->
<!-- ``` -->
<!-- Woeh, it wasnt too bad, I guess. -->
<!-- Next we drop the first col *X*, which kind of popped up unannounced, and melt the table. -->
<!-- ```{r} -->
<!-- y2<-y1[,-1] %>% melt -->
<!-- as_data_frame(y2) -->
<!-- ``` -->
<!-- This is the explicit melt - same result. -->
<!-- ```{r} -->
<!-- y3<-y1[,-1] %>% melt(id.vars=c("OTU","TAXON.ID"),   # all the variables to keep, but not split apart  -->
<!--                 variable.name="experiment", # Name of the destination column for factors that are taken from names of melted columns -->
<!--                 value.name="nr.of.counts" # name of the newly made single value column -->
<!-- )%>% as_data_frame() -->
<!-- y3 -->
<!-- ``` -->
<!-- or tidyr::gather - same result again -->
<!-- ```{r} -->
<!-- y4<-y1 %>% gather(key="experiment", value="nr.of.counts", 4:ncol(y1)) %>% select(-X) -->
<!-- y4 -->
<!-- all.equal(y3, y4) -->
<!-- ``` -->
<!-- and dcast to cast the table back into wide format... -->
<!-- (This is just for show --- in reality we usually work with a porpose in mind.) -->
<!-- ```{r} -->
<!-- w1<-y4%>% dcast(OTU+TAXON.ID~experiment) %>% as_data_frame() -->
<!-- w1 -->
<!-- ``` -->
<!-- or tidyr::spread --- same result -->
<!-- ```{r} -->
<!-- w2<-y4 %>% spread(key=experiment, value=nr.of.counts) %>% as_data_frame() -->
<!-- w2 -->
<!-- ``` -->
<!-- and finally, tidyr::separate sepatates the content of the column *TAXON.ID* into several columns -->
<!-- ```{r} -->
<!-- y5<-y4%>%separate(TAXON.ID, c("riik", "hmk", "klass", "selts", "sgk", "prk", "liik"), sep=';', extra="merge") -->
<!-- y5 -->
<!-- ``` -->
</div>
</div>
</div>
<div id="ggplot2" class="section level1">
<h1>ggplot2</h1>
<p><strong>ggplot2</strong> is an R package for producing statistical graphics based on the grammar of graphics (hence the gg!).</p>
<ul>
<li><strong>ggplot2 works iteratively</strong> – you start with a layer showing the raw data and then add layers of geoms, annotations, and statistical summaries.</li>
</ul>
<p>To compose plots, you have to supply minimally:</p>
<ul>
<li><strong>Data</strong> that you want to visualise and <strong>aes</strong>thetic mappings – what’s on x-axis, what’s on y-axis, and how to you want to group and color your data.</li>
<li><strong>Layers</strong> made up of <strong>geom</strong>etric elements: points, lines, boxes, etc.</li>
</ul>
<p>You can further adjust your plot:</p>
<ul>
<li>by adding <strong>statistical summaries</strong> of your raw data.</li>
<li>using <strong>scale</strong>s to redraw a legend or axes.</li>
<li>using <strong>facet</strong>ing to break up the data into subsets for display.</li>
<li>using <strong>theme</strong>s which control plot features like the font size and background colour.</li>
</ul>
<p>ggplot2 is different from base graphics:</p>
<ul>
<li>Plots created by base graphics appear only on the screen and you cannot assign plot to an object for later use. Everything is created in place.</li>
<li>You can only draw on top of the plot, you cannot modify or delete existing content.</li>
</ul>
<p>That was theory, you can read more from <a href="https://github.com/hadley/ggplot2-book">ggplot2-book</a>, this is where rubber meets the road:</p>
<pre class="r"><code>library(ggplot2) # load ggplot2 library
library(dplyr) # dplyr is necessary for piping operator and for some data munging
library(tidyr)</code></pre>
<p>We use ggplot2 builtin dataset <code>mpg</code> with fuel economy data from 1999 and 2008 for 38 models of car:</p>
<pre class="r"><code>mpg</code></pre>
<pre><code>## # A tibble: 234 x 11
##    manufacturer      model displ  year   cyl      trans   drv   cty   hwy
##           &lt;chr&gt;      &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt;      &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt;
##  1         audi         a4   1.8  1999     4   auto(l5)     f    18    29
##  2         audi         a4   1.8  1999     4 manual(m5)     f    21    29
##  3         audi         a4   2.0  2008     4 manual(m6)     f    20    31
##  4         audi         a4   2.0  2008     4   auto(av)     f    21    30
##  5         audi         a4   2.8  1999     6   auto(l5)     f    16    26
##  6         audi         a4   2.8  1999     6 manual(m5)     f    18    26
##  7         audi         a4   3.1  2008     6   auto(av)     f    18    27
##  8         audi a4 quattro   1.8  1999     4 manual(m5)     4    18    26
##  9         audi a4 quattro   1.8  1999     4   auto(l5)     4    16    25
## 10         audi a4 quattro   2.0  2008     4 manual(m6)     4    20    28
## # ... with 224 more rows, and 2 more variables: fl &lt;chr&gt;, class &lt;chr&gt;</code></pre>
<p>Key variables in <code>mpg</code> dataset are <code>displ</code> – engine displacement (L), <code>cyl</code> – number of cylinders, <code>cty</code> – city miles per gallon, <code>hwy</code> – highway miles per gallon.</p>
<p>Simple scatterplot to explore relationship between fuel consumption in city traffick (cty) and engine size (displ) is created like this:</p>
<pre class="{r}s"><code>ggplot(mpg, aes(displ, cty)) + geom_point()</code></pre>
<p><strong>Notice that</strong>: in ggplot first two unnamed arguments to <code>aes()</code> are <code>x</code> and <code>y</code>, so we can easily skip <code>x =</code> and <code>y =</code> to reduce typing.</p>
<div id="scatterplot-1" class="section level2">
<h2>Scatterplot</h2>
<p>To illustrate layerwise plot creation in ggplot:</p>
<pre class="r"><code>p &lt;- ggplot(data = mpg) # first add data
p &lt;- p + aes(x = cty, y = hwy) # add aesthetics
p &lt;- p + geom_point() # add geom, specifying plot type 
p + stat_smooth(method = &quot;lm&quot;) # add statistical summary</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-172-1.png" width="672" style="display: block; margin: auto;" /> The <strong>point geom is used to create scatterplots</strong>.</p>
<p>Of course, this result is usually achieved by this oneliner:</p>
<pre class="r"><code>ggplot(mpg, aes(cty, hwy)) + geom_point() + stat_smooth(method = &quot;lm&quot;)</code></pre>
</div>
<div id="color-size-shape-and-fill" class="section level2">
<h2>Color, size, shape, and fill</h2>
<p>Other aesthetics like <code>color</code>, <code>shape</code>, <code>fill</code>, and <code>size</code> can be used to add additional variables to a plot:</p>
<pre class="r"><code>ggplot(mpg, aes(cty, hwy, color = drv)) + geom_point() # &#39;colour=&#39; can be used too</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-174-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="point-shape-codes" class="section level2">
<h2>Point shape codes</h2>
<p>While colors and sizes are intuitive, it seems impossible to remember available point shape codes in R. The quickest way out of this is to know how to generate an example plot of the shapes quickly. <a href="http://www.win-vector.com/blog/2012/04/how-to-remember-point-shape-codes-in-r/">This is how to do this in ggplot2.</a></p>
<pre class="r"><code>ggplot(data=data.frame(x=c(0:25))) + geom_point(size=8, aes(x=x,y=x,shape=x)) +
  facet_wrap(~ x, scales=&#39;free&#39;) + xlab(&#39;&#39;) + ylab(&#39;&#39;) +
  scale_shape_identity() +
  theme(axis.text.x=element_blank(), axis.text.y=element_blank(),
        axis.ticks=element_blank(), legend.position=&#39;none&#39;,
        panel.background=element_blank(),
        panel.grid.major=element_blank(),
        panel.border=element_blank())</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-175-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="facetting" class="section level2">
<h2>Facetting</h2>
<p>Another possibility to add more variables is to use <code>facet_wrap</code>:</p>
<pre class="r"><code>ggplot(mpg, aes(cty, hwy)) + 
  geom_point() + 
  facet_wrap( ~ drv) # to specify name of a variable preceded by  ̃</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-176-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Two-way table can be created using <code>facet_grid</code> command:</p>
<pre class="r"><code>ggplot(mpg, aes(cty, hwy)) + 
  geom_point() + 
  facet_grid(year ~ drv) # to specify row variable ̃column variable</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-177-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="modify-axes-start-y-or-x-axis-at-zero" class="section level2">
<h2>Modify axes, start y or x axis at zero</h2>
<p>Axis labels can be changed using <code>xlab()</code> and <code>ylab()</code>:</p>
<pre class="r"><code>p + xlab(&quot;City driving (miles per gallon)&quot;) + # to set x axis label
  ylab(&quot;Highway driving (miles per gallon)&quot;) # to set y axis label</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-178-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>The other way around, to remove axis leables, set them to <code>NULL</code>:</p>
<pre class="r"><code>p + xlab(NULL) + ylab(NULL)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-179-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>In many cases proper visual representation of data requires that e.g. y axis starts from zero. By default, ggplot zooms only into region where data is located and 0 is dropped from axes. To change this behaviour, ggplot has command <code>expand_limits()</code> specifying the value(-s) that should be included in each scale:</p>
<pre class="r"><code>p + expand_limits(x = 0, y = 0) # upper and lower axis limits can be specified by supplying vector of two values</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-180-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><code>scale_x_continuous()</code> and <code>scale_y_continuous()</code> have argument limits, which can be used to set axis limits, but values remaining outside limits will be set to <code>NA</code>:</p>
<pre class="r"><code>p + scale_y_continuous(limits = c(0, 20))</code></pre>
<pre><code>## Warning: Removed 145 rows containing missing values (geom_point).</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-181-1.png" width="672" style="display: block; margin: auto;" /> Note the warning!</p>
<p>More simply, we can use <code>xlim()</code> and <code>ylim()</code>:</p>
<pre class="r"><code>p + xlim(15, 20) + ylim(0, 30)</code></pre>
<pre><code>## Warning: Removed 119 rows containing missing values (geom_point).</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-182-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="ggsave-plot" class="section level2">
<h2>ggsave plot</h2>
<p><code>ggsave</code> recognises .eps/ps, .tex (pictex), .pdf, .jpeg, .tiff, .png, .bmp, .svg, and .wmf (windows only) file extensions. To save a plot <code>p</code> to e.g. as <code>.png</code> file use:</p>
<pre class="r"><code>ggsave(&quot;graphs/my_biutiful_plot.png&quot;, plot = p, width = 7, height = 5)</code></pre>
<p>By default <code>plot=</code> is the last plot.</p>
</div>
<div id="histograms" class="section level2">
<h2>Histograms</h2>
<p>Differently from base R graphics, where histogram is drawn by a special command, ggplot specifies the type of plot by geoms, like <code>geom_histogram()</code>:</p>
<pre class="r"><code>df &lt;- tibble(x = rnorm(10000)) # For demo we create tibble with 10000 random numbers from normal distribution
ggplot(df, aes(x)) + geom_histogram() # to plot histogram we specify geom_histogram </code></pre>
<pre><code>## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-184-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>ggplot says: <code>stat_bin()</code> using <code>bins = 30</code>. Pick better value with <code>binwidth</code>, also help file notes that ‘the default is to use bins bins that cover the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data’. OK, Messy Goes to Okido, lets try:</p>
<pre class="r"><code>ggplot(df, aes(x)) + geom_histogram(binwidth = 0.1) # for better granularity, we specify binwith = 0.1</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-185-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Alternatively, you can specify the number of bins (and perhaps send some hidden messages along with your visualisation):</p>
<pre class="r"><code>ggplot(df, aes(x)) + geom_histogram(bins = 5) # if we want to split data into eg. 5 bins</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-186-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>For some more practice, lets recreate Tartu Marathon 2013 histogram:</p>
<pre class="r"><code>library(lubridate)
load(&quot;data/Tartu_Maraton_2013.RData&quot;)</code></pre>
<pre class="r"><code>tm &lt;- tm_2013 %&gt;% mutate(Aeg = unclass(as.duration(hms(Aeg)))/3600) %&gt;% filter(complete.cases(.))
tm %&gt;% ggplot(aes(Aeg)) + geom_histogram(binwidth = 1/12) # we want binwidth ~5 minutes (1/12 hour)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-188-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>These were histograms with counts on y-axis, but we may want to plot (kernel) density instead, for this we use <code>geom_density()</code>:</p>
<pre class="r"><code>ggplot(df, aes(x)) + geom_density()</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-189-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Histogram with densities on y-axis:</p>
<pre class="r"><code>ggplot(df, aes(x, ..density..)) + geom_histogram()</code></pre>
<pre><code>## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-190-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Kernel density plot and histogram together:</p>
<pre class="r"><code>ggplot(df, aes(x, ..density..)) + 
  geom_histogram(binwidth = 0.1) +
  geom_density()</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-191-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>p &lt;- ggplot(df, aes(x)) + 
  geom_histogram(aes(y = ..density..), # note that we specify density here, 
                 binwidth = 0.1, 
                 fill = &quot;white&quot;, color = &quot;black&quot;) +
  geom_density()
p # we disrected plot to object</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-192-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>We can add vertical line, denoting mean, to our histogram like this:</p>
<pre class="r"><code>p + geom_vline(aes(xintercept = mean(x)), color = &quot;red&quot;, linetype = &quot;dashed&quot;, size = 1) </code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-193-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>To compare distributions</strong> we can overlay histograms and density plots. To demonstrate this, let’s create dummy dataset of two normal distributions:</p>
<pre class="r"><code>df2 &lt;- tibble(pop = rep(c(&quot;N&quot;, &quot;S&quot;), each = 1000), 
              value = c(rnorm(1000, 20, 3), rnorm(1000, 25, 3)))
df2</code></pre>
<pre><code>## # A tibble: 2,000 x 2
##      pop    value
##    &lt;chr&gt;    &lt;dbl&gt;
##  1     N 19.60917
##  2     N 20.51657
##  3     N 25.46626
##  4     N 23.41358
##  5     N 19.22600
##  6     N 21.08701
##  7     N 19.34756
##  8     N 23.53181
##  9     N 17.61602
## 10     N 18.51658
## # ... with 1,990 more rows</code></pre>
<p>When overlaying histograms in ggplot, default action is to ‘stack’ them one to another, making comparison difficult. We have to specify <code>position = &quot;identity&quot;</code> to place them directly onto x-axis (each bar starts from y = 0). Also we specify <code>alpha =</code> for some transparency:</p>
<pre class="r"><code>p1 &lt;- df2 %&gt;% ggplot(aes(value, fill = pop)) 
p1 + geom_histogram(position = &quot;identity&quot;, alpha = 0.7, binwidth = 0.3)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-195-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Alternatively, it’s possible to place comparable bars next to each other by specifying <code>position = &quot;dodge&quot;</code>:</p>
<pre class="r"><code>p1 + geom_histogram(position = &quot;dodge&quot;, binwidth = 1)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-196-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Overlaid kernel density plots:</p>
<pre class="r"><code>p2 &lt;- p1 + geom_density(alpha = 0.7)
p2</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-197-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>To indicate means for these two distributions, we have to calculate means into a new data frame:</p>
<pre class="r"><code>df2_stats &lt;- df2 %&gt;% group_by(pop) %&gt;% summarise(pop_mean = mean(value))
p2 + geom_vline(data = df2_stats, aes(xintercept = pop_mean, color = pop), linetype = &quot;dashed&quot;, size = 1)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-198-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="boxplots" class="section level2">
<h2>Boxplots</h2>
<p><strong>Boxplots</strong> are created using <code>geom_boxplot</code>:</p>
<pre class="r"><code>df2 %&gt;% ggplot(aes(pop, value)) + geom_boxplot()</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-199-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>p3 &lt;- df2 %&gt;% ggplot(aes(pop, value, fill = pop)) + geom_boxplot()
p3</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-200-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Often, it’s a good idea to overlay original values to plot. Specially, if there is only few values. Let’s add original data points to previous boxplot:</p>
<pre class="r"><code>p3 + geom_point()</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-201-1.png" width="672" style="display: block; margin: auto;" /> Adding geom_points was not very helpful in this case. s We can try to jitter these points, where argument <code>width=</code> specifies jitter width (default full boxplot width):</p>
<pre class="r"><code>p3 + geom_jitter(width = 0.5)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-202-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>As shown previously, we can also add summary data (mean) to this plot (large red dots):</p>
<pre class="r"><code>p3 + geom_point(data = df2_stats, aes(y = pop_mean), shape = 16, color = &quot;red&quot;, size = 3)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-203-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="plotting-means-and-error-bars" class="section level2">
<h2>Plotting means and error bars</h2>
<p>Summaries and e.g. errorbars can also be calculated on the fly. To illustrate this, we take first smaller sample from our dataset in order to have larger errorbars. Here we add bootstrapped 99% confidence intervals of the mean:</p>
<pre class="r"><code>p4 &lt;- df2 %&gt;% sample_n(50) %&gt;% # to have larger error
  ggplot(aes(pop, value, fill = pop)) + geom_jitter(color = &quot;gray&quot;, width = 1/3) 
p4 + stat_summary(fun.data = &quot;mean_cl_boot&quot;, fun.args = list(conf.int = .99), geom = &quot;pointrange&quot;) # poinrange is default geom </code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-204-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Here we add errorbars, denoting standard error of the mean:</p>
<pre class="r"><code>p4 &lt;- p4 + stat_summary(fun.y = mean, geom = &quot;point&quot;, shape = 95, color = &quot;red&quot;, size = 15) + # mean
  stat_summary(fun.data = mean_se, geom = &quot;errorbar&quot;, width = 0.25) # standard deviation
p4</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-205-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="linegraphs" class="section level2">
<h2>Linegraphs</h2>
<p>Now we create line graphs with errorbars, we use <code>mpg</code> data. We calculate mean and standard error of the mean for highway fuel consumption (hwy) per year and per number of cylinders:</p>
<pre class="r"><code>mpg_sum &lt;- mpg %&gt;% 
  filter(cyl %in% c(4,6,8)) %&gt;%  # to include only comparable values
  group_by(year, cyl) %&gt;% # to compare two years
  summarise(mean_hwy = mean(hwy), # to calculate mean
            N = n(), # N to calculate standard error
            se_hwy = sd(cty)/sqrt(N)) # standard error
mpg_sum</code></pre>
<pre><code>## # A tibble: 6 x 5
## # Groups:   year [?]
##    year   cyl mean_hwy     N    se_hwy
##   &lt;int&gt; &lt;int&gt;    &lt;dbl&gt; &lt;int&gt;     &lt;dbl&gt;
## 1  1999     4 28.37778    45 0.6324200
## 2  1999     6 22.31111    45 0.2490386
## 3  1999     8 17.03704    27 0.3172771
## 4  2008     4 29.33333    36 0.3823717
## 5  2008     6 23.50000    34 0.3273554
## 6  2008     8 18.00000    43 0.2873450</code></pre>
<p><code>geom_line()</code> is used to create linegraphs in ggplot. We want two distinct colors for year variable, therefore we coerce year to factor:</p>
<pre class="r"><code>p5 &lt;- mpg_sum %&gt;% ggplot(aes(cyl, mean_hwy, color = factor(year))) 
p5 + geom_point() + geom_line()</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-207-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Errorbars can be added by using <code>geom_errorbar</code>, which needs arguments <code>ymin</code> and <code>ymax</code>:</p>
<pre class="r"><code>p5 + geom_point() + geom_line() +
  geom_errorbar(aes(ymin = mean_hwy + se_hwy, ymax = mean_hwy - se_hwy), width = 0.25)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-208-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>When the errorbars overlap, use <code>position_dodge</code> to move them horizontally.</p>
<pre class="r"><code>pd &lt;- position_dodge(0.7) # move them </code></pre>
<pre class="r"><code>p5 + geom_point(position = pd) + 
  geom_line(position = pd) +
  geom_errorbar(aes(ymin = mean_hwy + se_hwy, ymax = mean_hwy - se_hwy), 
                   width = 0.25, 
                   position = pd)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-210-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="bargraphs-1" class="section level2">
<h2>Bargraphs</h2>
<p>Bargraphs are created using <code>geom_bar</code> and default stat <code>counts</code> needs to changed to <code>identity</code>:</p>
<pre class="r"><code>p6 &lt;- mpg_sum %&gt;% filter(year == 1999) %&gt;% 
  ggplot(aes(factor(cyl), mean_hwy))
p6 + geom_bar(stat = &quot;identity&quot;)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-211-1.png" width="672" style="display: block; margin: auto;" /> Note that bargraph starts at 0.</p>
<p>When adding additional variables to a bargraphs e.g. via <code>fill =</code> you need also unstack the bars by specifying <code>position = position_dodge()</code>:</p>
<pre class="r"><code>pd &lt;- position_dodge(0.9) 
p6 &lt;- mpg_sum %&gt;% ggplot(aes(factor(cyl), mean_hwy, fill = factor(year)))
p7 &lt;- p6 + geom_bar(stat = &quot;identity&quot;, position = pd)
p7</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-212-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>p7 + geom_errorbar(aes(ymin = mean_hwy - se_hwy, ymax = mean_hwy + se_hwy),
                   position = pd, width = 0.25)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-213-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="merging-tables" class="section level1">
<h1>Merging tables</h1>
<div id="combine-by-rows-and-columns" class="section level2">
<h2>Combine by rows and columns</h2>
<p>Base R <code>rbind</code> and <code>cbind</code> <strong>take in a sequence of vector, matrix or data-frame</strong> and combine by rows or columns, respectively. Meaning that if you want to combine only data frames you have also option to use Hadleyverse’s <code>dplyr::bind_rows</code> or <code>dplyr::bind_cols</code>. Otherwise, if playing around with vectors and/or matrices too, you have to stick with base R functions.</p>
<p>Don’t try to understand this excerpt from help: for <code>rbind</code> column names are taken from the first argument with appropriate names: colnames for a matrix, or names for a vector of length the number of columns of the result.</p>
<p>To illustrate combining two data.frames by rowwise we first subset <code>mtcars</code> dataset into two mini dataframes:</p>
<pre class="r"><code>dim(mtcars)</code></pre>
<pre><code>## [1] 32 11</code></pre>
<pre class="r"><code>df1 &lt;- mtcars[1:2, c(1,4)]
df1</code></pre>
<pre><code>##               mpg  hp
## Mazda RX4      21 110
## Mazda RX4 Wag  21 110</code></pre>
<pre class="r"><code>df2 &lt;- mtcars[11:13, c(1,4)]
df2</code></pre>
<pre><code>##             mpg  hp
## Merc 280C  17.8 123
## Merc 450SE 16.4 180
## Merc 450SL 17.3 180</code></pre>
<p>Combine by rows using base R <code>rbind</code>, <strong>columns need to match</strong>:</p>
<pre class="r"><code>rbind(df1, df2)</code></pre>
<pre><code>##                mpg  hp
## Mazda RX4     21.0 110
## Mazda RX4 Wag 21.0 110
## Merc 280C     17.8 123
## Merc 450SE    16.4 180
## Merc 450SL    17.3 180</code></pre>
<p>Hadleyverse’s verb to perform this task is <code>bind_rows</code>, however note that <code>bind_rows</code> (<code>bind_cols</code>) <strong>needs data frames</strong> (NO vectors or matrices!):</p>
<pre class="r"><code>library(dplyr)
bind_rows(df1, df2) </code></pre>
<pre><code>##    mpg  hp
## 1 21.0 110
## 2 21.0 110
## 3 17.8 123
## 4 16.4 180
## 5 17.3 180</code></pre>
<p>Neat feature of the <code>bind_rows</code> function is that when you supply a column name with the <code>.id=</code> argument, a new column is created to link each row to its original data frame:</p>
<pre class="r"><code>bind_rows(df1 = df1, df2 = df2, .id = &quot;id&quot;)</code></pre>
<pre><code>##    id  mpg  hp
## 1 df1 21.0 110
## 2 df1 21.0 110
## 3 df2 17.8 123
## 4 df2 16.4 180
## 5 df2 17.3 180</code></pre>
<p><strong>Columns don’t need to match</strong> when row-binding using <code>bind_rows</code>, missing values are filled with <code>NA</code>-s:</p>
<pre class="r"><code>bind_rows(df1 = df1, 
          df2 = mtcars[11:13, c(1,4,6)], 
          df3 = mtcars[4:6, c(1,6)],
          .id = &quot;id&quot;)</code></pre>
<pre><code>##    id  mpg  hp    wt
## 1 df1 21.0 110    NA
## 2 df1 21.0 110    NA
## 3 df2 17.8 123 3.440
## 4 df2 16.4 180 4.070
## 5 df2 17.3 180 3.730
## 6 df3 21.4  NA 3.215
## 7 df3 18.7  NA 3.440
## 8 df3 18.1  NA 3.460</code></pre>
<p>If you have <strong>data frames or tibbles in a list</strong>, then you can bind them rowwise into one data frame.</p>
<p>Here we first create list with two dataframes:</p>
<pre class="r"><code>df_list &lt;- list(df1, df2)
df_list</code></pre>
<pre><code>## [[1]]
##               mpg  hp
## Mazda RX4      21 110
## Mazda RX4 Wag  21 110
## 
## [[2]]
##             mpg  hp
## Merc 280C  17.8 123
## Merc 450SE 16.4 180
## Merc 450SL 17.3 180</code></pre>
<p><code>do.call(rbind, my_list_of_dataframes)</code> is base R solution to this task, but you need data frames with same column names:</p>
<pre class="r"><code>do.call(rbind, df_list) # bind dataframes in list by rows</code></pre>
<pre><code>##                mpg  hp
## Mazda RX4     21.0 110
## Mazda RX4 Wag 21.0 110
## Merc 280C     17.8 123
## Merc 450SE    16.4 180
## Merc 450SL    17.3 180</code></pre>
<p><code>bind_rows</code> argument can also be a <strong>list of data frames</strong>, and again, columns are matched by name, and any values that don’t match will be filled with <code>NA</code>-s:</p>
<pre class="r"><code>df_list2 &lt;- list(df1 = df1, 
          df2 = mtcars[11:13, c(1,4,6)], 
          df3 = mtcars[4:6, c(1,6)])
bind_rows(df_list2, .id = &quot;id&quot;)</code></pre>
<pre><code>##    id  mpg  hp    wt
## 1 df1 21.0 110    NA
## 2 df1 21.0 110    NA
## 3 df2 17.8 123 3.440
## 4 df2 16.4 180 4.070
## 5 df2 17.3 180 3.730
## 6 df3 21.4  NA 3.215
## 7 df3 18.7  NA 3.440
## 8 df3 18.1  NA 3.460</code></pre>
<p>Combining two vectors of same length columnwise results in matrix (similar to rbind):</p>
<pre class="r"><code>cbind(letters[1:5], 1:5)</code></pre>
<pre><code>##      [,1] [,2]
## [1,] &quot;a&quot;  &quot;1&quot; 
## [2,] &quot;b&quot;  &quot;2&quot; 
## [3,] &quot;c&quot;  &quot;3&quot; 
## [4,] &quot;d&quot;  &quot;4&quot; 
## [5,] &quot;e&quot;  &quot;5&quot;</code></pre>
<p>When combining vectors with different lengths, the shorter one is recycled:</p>
<pre class="r"><code>m &lt;- cbind(1, 1:7) # the &#39;1&#39; (= shorter vector) is recycled
m</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    1
## [2,]    1    2
## [3,]    1    3
## [4,]    1    4
## [5,]    1    5
## [6,]    1    6
## [7,]    1    7</code></pre>
<pre class="r"><code>rbind(1:6, 7:8) # same applies to rbind</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6]
## [1,]    1    2    3    4    5    6
## [2,]    7    8    7    8    7    8</code></pre>
<p>Columns can be inserted by specifing order of colums in the index:</p>
<pre class="r"><code>cbind(m, 8:14)[, c(1, 3, 2)] # insert a column</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    8    1
## [2,]    1    9    2
## [3,]    1   10    3
## [4,]    1   11    4
## [5,]    1   12    5
## [6,]    1   13    6
## [7,]    1   14    7</code></pre>
<p>When the arguments consist of a mix of matrices and vectors the number of rows of the result is determined by the number of rows of the matrix arguments:</p>
<pre class="r"><code>cbind(1:7, matrix(11:16, nrow = 3)) # vector is subset -&gt; warning</code></pre>
<pre><code>## Warning in cbind(1:7, matrix(11:16, nrow = 3)): number of rows of result is
## not a multiple of vector length (arg 1)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1   11   14
## [2,]    2   12   15
## [3,]    3   13   16</code></pre>
<p>When column-binding, rows are matched by position, not value so all data frames must have the same number of rows:</p>
<pre class="r"><code>bind_cols(df1, mtcars[1:2,5:6])</code></pre>
<pre><code>##   mpg  hp drat    wt
## 1  21 110  3.9 2.620
## 2  21 110  3.9 2.875</code></pre>
<p>Summary:</p>
<ul>
<li><code>rbind</code>, <code>cbind</code> take in vectors, matrices and data frames.</li>
<li><code>bind_rows</code>, <code>bind_cols</code> – <strong>data frames only</strong>.</li>
<li>with <code>rbind</code> column names must match as well numbers of columns.</li>
<li><code>bind_rows</code> handles non-matching cols and rows with ease.</li>
<li>in case of combining vector with array, <code>cbind</code> handles non-matching vector length with row number and recycles or subsets vector if necessary.</li>
<li><code>bind_cols</code> need same number of rows in data frames.</li>
<li>whatever you combine, onus is on you to ensure that proper rows and columns get combined, when they get combined.</li>
</ul>
</div>
<div id="joins" class="section level2">
<h2>Joins</h2>
<p>During data analysis you find out quite often that your data is lying around in multiple tables and you need to combine these sets. In <code>dplyr</code>, <a href="https://cran.r-project.org/web/packages/dplyr/vignettes/two-table.html">there are three families of verbs</a> that work with two tables at a time:</p>
<ul>
<li>Mutating joins, which add new variables to one table from matching rows in another.</li>
<li>Filtering joins, which filter observations from one table based on whether or not they match an observation in the other table.</li>
<li>Set operations, which combine the observations in the data sets as if they were set elements.</li>
</ul>
<p>To illustrate joining, let’s consider <a href="http://www.ester.ee/record=b2697405*est">following data</a>. Here we have day of travel, city, and population.</p>
<pre class="r"><code>library(dplyr)
trip &lt;- data_frame(day = c(1:8), city = c(&quot;Teheran&quot;, &quot;Qom&quot;, &quot;Esfahan&quot;, &quot;Persepolis&quot;, &quot;Shiraz&quot;, &quot;Bandar&quot;, &quot;Karaj&quot;, &quot;Tabriz&quot;), pop = c(8846782,1374036,1945765,NA,1460665,212,1967005,1549453))
head(trip)</code></pre>
<pre><code>## # A tibble: 6 x 3
##     day       city     pop
##   &lt;int&gt;      &lt;chr&gt;   &lt;dbl&gt;
## 1     1    Teheran 8846782
## 2     2        Qom 1374036
## 3     3    Esfahan 1945765
## 4     4 Persepolis      NA
## 5     5     Shiraz 1460665
## 6     6     Bandar     212</code></pre>
<p>Next table we have hotels with addresses for some of the cities.</p>
<pre class="r"><code>hotels &lt;- data_frame(city = c(&quot;Teheran&quot;, &quot;Qom&quot;, &quot;Esfahan&quot;, &quot;Persepolis&quot;, &quot;Shiraz&quot;, &quot;Bandar&quot;), hotel = c(&quot;Firouzeh Hotel&quot;, &quot;Aria Hotel&quot;, &quot;Amir Kabir Hotel&quot;, &quot;Sita Aukh Guest House&quot;, &quot;Anvari Hotel&quot;, &quot;Bolivar Inn&quot;), address = c(&quot;Dowlat Abad Alley&quot;, &quot;Astane Square&quot;, &quot;Chahar Bagh Abbasi Street&quot;, &quot;Tume Junn Mohammad Street&quot;, &quot;Anvari Street&quot;, &quot;Abuzar Street&quot;))
head(hotels)</code></pre>
<pre><code>## # A tibble: 6 x 3
##         city                 hotel                   address
##        &lt;chr&gt;                 &lt;chr&gt;                     &lt;chr&gt;
## 1    Teheran        Firouzeh Hotel         Dowlat Abad Alley
## 2        Qom            Aria Hotel             Astane Square
## 3    Esfahan      Amir Kabir Hotel Chahar Bagh Abbasi Street
## 4 Persepolis Sita Aukh Guest House Tume Junn Mohammad Street
## 5     Shiraz          Anvari Hotel             Anvari Street
## 6     Bandar           Bolivar Inn             Abuzar Street</code></pre>
<div id="mutating-joins" class="section level3">
<h3>Mutating joins</h3>
<p>We use <code>dplyr</code> <code>left_join</code> and <code>inner_join</code> functions to combine these tables by explicitly specifying column/variable ‘by = “city”’ (e.g. in order to guarantee consistent behaviour when number of columns in our data frame can vary in our script). If keep default ‘by = NULL’, then two datasets are combined by all matching columns.</p>
<p><code>left_join</code> returns all rows from trip where there are matching values in trip, and all columns from trip and hotels.</p>
<pre class="r"><code>left_join(trip, hotels, by = &quot;city&quot;) </code></pre>
<pre><code>## # A tibble: 8 x 5
##     day       city     pop                 hotel                   address
##   &lt;int&gt;      &lt;chr&gt;   &lt;dbl&gt;                 &lt;chr&gt;                     &lt;chr&gt;
## 1     1    Teheran 8846782        Firouzeh Hotel         Dowlat Abad Alley
## 2     2        Qom 1374036            Aria Hotel             Astane Square
## 3     3    Esfahan 1945765      Amir Kabir Hotel Chahar Bagh Abbasi Street
## 4     4 Persepolis      NA Sita Aukh Guest House Tume Junn Mohammad Street
## 5     5     Shiraz 1460665          Anvari Hotel             Anvari Street
## 6     6     Bandar     212           Bolivar Inn             Abuzar Street
## 7     7      Karaj 1967005                  &lt;NA&gt;                      &lt;NA&gt;
## 8     8     Tabriz 1549453                  &lt;NA&gt;                      &lt;NA&gt;</code></pre>
<p><code>left_join</code> is the most commonly used join because it ensures that you don’t lose observations from your primary table on the left side.</p>
<p><code>inner_join</code> returns all rows from trip, and all columns from trip and hotels. Rows in trip with no match in hotels will have NA values in the new columns.</p>
<pre class="r"><code>inner_join(trip, hotels, by = &quot;city&quot;) </code></pre>
<pre><code>## # A tibble: 6 x 5
##     day       city     pop                 hotel                   address
##   &lt;int&gt;      &lt;chr&gt;   &lt;dbl&gt;                 &lt;chr&gt;                     &lt;chr&gt;
## 1     1    Teheran 8846782        Firouzeh Hotel         Dowlat Abad Alley
## 2     2        Qom 1374036            Aria Hotel             Astane Square
## 3     3    Esfahan 1945765      Amir Kabir Hotel Chahar Bagh Abbasi Street
## 4     4 Persepolis      NA Sita Aukh Guest House Tume Junn Mohammad Street
## 5     5     Shiraz 1460665          Anvari Hotel             Anvari Street
## 6     6     Bandar     212           Bolivar Inn             Abuzar Street</code></pre>
<pre class="r"><code>df1 &lt;- data_frame(x = c(1, 2), y = c(T, F))
df1</code></pre>
<pre><code>## # A tibble: 2 x 2
##       x     y
##   &lt;dbl&gt; &lt;lgl&gt;
## 1     1  TRUE
## 2     2 FALSE</code></pre>
<pre class="r"><code>df2 &lt;- data_frame(x = c(1, 3), a = 10, b = &quot;a&quot;)
df2</code></pre>
<pre><code>## # A tibble: 2 x 3
##       x     a     b
##   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;
## 1     1    10     a
## 2     3    10     a</code></pre>
<p><code>left_join(x, y)</code> includes all observations from x and observations from y that have match in x:</p>
<pre class="r"><code>left_join(df1, df2)</code></pre>
<pre><code>## Joining, by = &quot;x&quot;</code></pre>
<pre><code>## # A tibble: 2 x 4
##       x     y     a     b
##   &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;chr&gt;
## 1     1  TRUE    10     a
## 2     2 FALSE    NA  &lt;NA&gt;</code></pre>
<p><code>inner_join(x, y)</code> only includes observations that match in both x and y:</p>
<pre class="r"><code>inner_join(df1, df2)</code></pre>
<pre><code>## Joining, by = &quot;x&quot;</code></pre>
<pre><code>## # A tibble: 1 x 4
##       x     y     a     b
##   &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;chr&gt;
## 1     1  TRUE    10     a</code></pre>
<p>Return all rows from trip where there are not matching values in hotels, keeping just columns from trip.</p>
<pre class="r"><code>anti_join(trip[1:3,], hotels[3:4,], by = &quot;city&quot;) # returns cols fron trip where there are no matching values in hotels </code></pre>
<pre><code>## # A tibble: 2 x 3
##     day    city     pop
##   &lt;int&gt;   &lt;chr&gt;   &lt;dbl&gt;
## 1     2     Qom 1374036
## 2     1 Teheran 8846782</code></pre>
<p>Return all rows and all columns from both trip and hotels. Where there are not matching values, returns NA for the one missing.</p>
<pre class="r"><code>full_join(trip[1:3,], hotels[3:6,], by = &quot;city&quot;) </code></pre>
<pre><code>## # A tibble: 6 x 5
##     day       city     pop                 hotel                   address
##   &lt;int&gt;      &lt;chr&gt;   &lt;dbl&gt;                 &lt;chr&gt;                     &lt;chr&gt;
## 1     1    Teheran 8846782                  &lt;NA&gt;                      &lt;NA&gt;
## 2     2        Qom 1374036                  &lt;NA&gt;                      &lt;NA&gt;
## 3     3    Esfahan 1945765      Amir Kabir Hotel Chahar Bagh Abbasi Street
## 4    NA Persepolis      NA Sita Aukh Guest House Tume Junn Mohammad Street
## 5    NA     Shiraz      NA          Anvari Hotel             Anvari Street
## 6    NA     Bandar      NA           Bolivar Inn             Abuzar Street</code></pre>
</div>
</div>
</div>
<div id="find-character-strings" class="section level1">
<h1>Find character strings</h1>
<p>Character strings can be matched and manipulated in base R by using <code>regular expressions</code> in functions <code>grep</code>, <code>grepl</code>, <code>sub</code>, <code>gsub</code>, <code>regexpr</code> + <code>regmatches</code> and some others. Also tidyverse package ‘stringr’ contains analogous verbs with more consistent syntax. A <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html">regular expression</a> is a pattern that describes a set of strings.</p>
<!-- + The fundamental building blocks are the regular expressions that match a single character.  -->
<ul>
<li><a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html">Regular Expressions as used in R</a></li>
<li>Most characters, including all letters and digits, are regular expressions that match themselves. Whereas, e.g. <code>.</code> matches any single character.</li>
<li>You can refer also to a character class, which is a list of characters enclosed between <code>[</code> and <code>]</code>, e.g. <code>[[:alnum:]]</code> is same as <code>[A-z0-9]</code>.</li>
<li>Most common character classes:
<ul>
<li><code>[:alnum:]</code> includes alphanumerics (<code>[:alpha:]</code> and <code>[:digit:]</code>);</li>
<li><code>[:alpha:]</code>, includes alphabetic characters (<code>[:upper:]</code> and <code>[:lower:]</code> case);</li>
<li><code>[:punct:]</code> includes punctuation characters ! &quot; # $ % &amp; ’ ( ) * + , - . / : ; &lt; = &gt; ? @ [  ] ^ _ ` ` { | } ~.;</li>
<li><code>[:blank:]</code> includes space and tab; etc.</li>
</ul></li>
<li>The metacharacters in regular expressions are <code>. \ | ( ) [ { ^ $ * + ?</code>, whether these have a special meaning depends on the context.</li>
<li>When matching any metacharacter as a regular character, precede it with a double backslash <code>\\</code>.</li>
<li>Repetition quantifiers put after regex specify how many times regex is matched: <code>?</code>, optional, at most once; <code>*</code>, zero or more times; <code>+</code>, one or more times; <code>{n}</code>, n times; <code>{n,}</code>, n or more times; <code>{n,m}</code>, n to m times.</li>
<li>The caret <code>^</code> and the dollar sign <code>$</code> are metacharacters that respectively match the empty string at the beginning and end of a line.</li>
</ul>
<div id="common-operations-with-regular-expressions" class="section level2">
<h2>Common operations with regular expressions</h2>
<ul>
<li>Locate a pattern match (positions)</li>
<li>Extract a matched pattern</li>
<li>Identify a match to a pattern</li>
<li>Replace a matched pattern</li>
</ul>
</div>
<div id="get-string-length" class="section level2">
<h2>Get string length</h2>
<p>To get the length of a text string (i.e. the number of characters in the string):</p>
<pre class="r"><code>x &lt;- c(&quot;reformation&quot;, &quot;post&quot;, &quot;TLC&quot;)
nchar(x)</code></pre>
<pre><code>## [1] 11  4  3</code></pre>
</div>
<div id="locate-and-extract-strings" class="section level2">
<h2>Locate and extract strings</h2>
<p><code>regexpr</code> returns position of 1st match and its length in a string:</p>
<pre class="r"><code>regexpr(&quot;o&quot;, x)</code></pre>
<pre><code>## [1]  4  2 -1
## attr(,&quot;match.length&quot;)
## [1]  1  1 -1
## attr(,&quot;useBytes&quot;)
## [1] TRUE</code></pre>
<p>We can see that “o” is the 4th character in a 1st string and 2nd character in the 2nd string and is missing (-1) from the last string, all have length 1 chracter (useBytes=T).</p>
<p>Lets try vector of strings. We want to return matching strings **after underscore ’_’ ** and we know that this <strong>match may contain both letters and numbers</strong> and is located at the end of the string:</p>
<pre class="r"><code>y &lt;- c(&quot;AreaShape_Area&quot;, &quot;AreaShape_Perimeter&quot;, &quot;AreaShape_MajorAxisLength&quot;, &quot;Intensity_MADIntensity&quot;)
m &lt;- regexpr(&quot;[[:alnum:]]*$&quot;, y) # to return start and length of match
m # to have have a look: 1st vector is the first match from beginning, 2nd the lenght of match </code></pre>
<pre><code>## [1] 11 11 11 11
## attr(,&quot;match.length&quot;)
## [1]  4  9 15 12
## attr(,&quot;useBytes&quot;)
## [1] TRUE</code></pre>
<p>What the heck we do with this list? <code>regexpr</code> works with the <code>regmatches</code> command, you can return matching strings:</p>
<pre class="r"><code>regmatches(y, m) # to return matching strings</code></pre>
<pre><code>## [1] &quot;Area&quot;            &quot;Perimeter&quot;       &quot;MajorAxisLength&quot; &quot;MADIntensity&quot;</code></pre>
<blockquote>
<p>Tidyverse’s <code>stringr</code> library resolves the problem of difficult to work with putputs and produces outputs than can easily be used as inputs.</p>
</blockquote>
<p><code>stringr</code> library verbs to fulfill tasks by <code>regexpr</code> and <code>regmatches</code> are <code>str_locate</code> and <code>str_extract</code>:</p>
<pre class="r"><code>library(stringr)
str_locate(y, &quot;[[:alnum:]]*$&quot;) # if we want only start and end positions</code></pre>
<pre><code>##      start end
## [1,]    11  14
## [2,]    11  19
## [3,]    11  25
## [4,]    11  22</code></pre>
<p>Note that, <code>str_locate</code> returns more conveniently a matrix (instead of a list as in regexpr).</p>
<pre class="r"><code>str_extract(y, &quot;[[:alnum:]]*$&quot;) # if we want actual strings</code></pre>
<pre><code>## [1] &quot;Area&quot;            &quot;Perimeter&quot;       &quot;MajorAxisLength&quot; &quot;MADIntensity&quot;</code></pre>
<p>Seems nice and tidy.</p>
<p>To return multiple matches from the string, not just the first one, use <code>gregexpr</code>, which returns start position and length of every match:</p>
<pre class="r"><code>regmatches(y, gregexpr(&quot;Area&quot;, y)) # to return start position and length of every match</code></pre>
<pre><code>## [[1]]
## [1] &quot;Area&quot; &quot;Area&quot;
## 
## [[2]]
## [1] &quot;Area&quot;
## 
## [[3]]
## [1] &quot;Area&quot;
## 
## [[4]]
## character(0)</code></pre>
<p>Please try to return positions of all upper case letters from y:</p>
<pre class="r"><code>regmatches(y, gregexpr(&quot;[[:upper:]]&quot;, y))</code></pre>
<pre><code>## [[1]]
## [1] &quot;A&quot; &quot;S&quot; &quot;A&quot;
## 
## [[2]]
## [1] &quot;A&quot; &quot;S&quot; &quot;P&quot;
## 
## [[3]]
## [1] &quot;A&quot; &quot;S&quot; &quot;M&quot; &quot;A&quot; &quot;L&quot;
## 
## [[4]]
## [1] &quot;I&quot; &quot;M&quot; &quot;A&quot; &quot;D&quot; &quot;I&quot;</code></pre>
<p>Tidyverse alternatives to <code>gregexpr</code> is <code>str_locate_all</code> and <code>str_extract_all</code>:</p>
<pre class="r"><code>str_locate_all(y, &quot;e&quot;) # to locate all start positions and lengths of letter &quot;e&quot;</code></pre>
<pre><code>## [[1]]
##      start end
## [1,]     3   3
## [2,]     9   9
## [3,]    13  13
## 
## [[2]]
##      start end
## [1,]     3   3
## [2,]     9   9
## [3,]    12  12
## [4,]    16  16
## [5,]    18  18
## 
## [[3]]
##      start end
## [1,]     3   3
## [2,]     9   9
## [3,]    21  21
## 
## [[4]]
##      start end
## [1,]     4   4
## [2,]    17  17</code></pre>
<pre class="r"><code>str_extract_all(y, &quot;[[:upper:]]&quot;) # to extract all upper case letters</code></pre>
<pre><code>## [[1]]
## [1] &quot;A&quot; &quot;S&quot; &quot;A&quot;
## 
## [[2]]
## [1] &quot;A&quot; &quot;S&quot; &quot;P&quot;
## 
## [[3]]
## [1] &quot;A&quot; &quot;S&quot; &quot;M&quot; &quot;A&quot; &quot;L&quot;
## 
## [[4]]
## [1] &quot;I&quot; &quot;M&quot; &quot;A&quot; &quot;D&quot; &quot;I&quot;</code></pre>
</div>
<div id="use-of-string-extraction-in-dplyr" class="section level2">
<h2>Use of string extraction in dplyr</h2>
</div>
<div id="find-matching-elements-in-vector" class="section level2">
<h2>Find matching elements in vector</h2>
<p><code>grep(pattern, x)</code> finds a pattern in x. Pattern – character string containing a regular expressions (or exact character string for fixed = TRUE).</p>
<p>What really happens when we use <code>grep</code> or <code>grepl</code> on a vector x. By using <code>grep()</code> with default arguments gets us vector of the indices of the matching items in x:</p>
<pre class="r"><code>grep(&quot;Area&quot;, y)</code></pre>
<pre><code>## [1] 1 2 3</code></pre>
<p>Using <code>grep(value = TRUE)</code> we get character vector containing the selected elements of x:</p>
<pre class="r"><code>grep(&quot;Area&quot;, y, value = TRUE)</code></pre>
<pre><code>## [1] &quot;AreaShape_Area&quot;            &quot;AreaShape_Perimeter&quot;      
## [3] &quot;AreaShape_MajorAxisLength&quot;</code></pre>
<p>Tidy way to run <code>grep</code> is to use <code>str_subset()</code> from <code>stringr</code> library:</p>
<pre class="r"><code>str_subset(y, &quot;Area&quot;) # note that strings and pattern have changed positions</code></pre>
<pre><code>## [1] &quot;AreaShape_Area&quot;            &quot;AreaShape_Perimeter&quot;      
## [3] &quot;AreaShape_MajorAxisLength&quot;</code></pre>
<p>However, by using <code>grepl</code> we get logical vector showing match for each element:</p>
<pre class="r"><code>grepl(&quot;Area&quot;, y)</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE FALSE</code></pre>
<p>Neat thing with the <code>grepl</code> is that it’s versatile: you can use its result for subsetting or to count matches (TRUE = 1 and FALSE = 0):</p>
<pre class="r"><code>grepl(&quot;Area&quot;, y) %&gt;% sum</code></pre>
<pre><code>## [1] 3</code></pre>
<p>Respectively, <code>stringr</code> library verb is <code>str_detect()</code>:</p>
<pre class="r"><code>str_detect(y, &quot;Area&quot;)</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE FALSE</code></pre>
</div>
<div id="filter-variables" class="section level2">
<h2>Filter variables</h2>
<p>We can use <code>grepl</code> in <code>dplyr::filter</code> to subset data frame. For example we want to look at the participants with first name ‘Jaan’ in 2013 Tartu Ski Marathon finish protocol:</p>
<pre class="r"><code>tm_2013 %&gt;% filter(grepl(&quot;, Jaan&quot;, Nimi)) %&gt;% tbl_df # Nimi is name and is given as &#39;lastname, firstname&#39;.</code></pre>
<pre><code>## # A tibble: 103 x 7
##     Koht    Nr             Nimi            Elukoht     Aeg Vanuseklass
##    &lt;int&gt; &lt;int&gt;            &lt;chr&gt;              &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;
##  1   166   119  Laidvee, Jaanus      Harju maakond 3:11:07         M35
##  2   197   249       Jõgi, Jaan       Võru maakond 3:13:21         M60
##  3   219   248  Undrest, Jaanus Lääne-Viru maakond 3:15:25         M35
##  4   289   237   Bauman, Jaanus Lääne-Viru maakond 3:19:37         M35
##  5   388   626 Johanson, Jaanus   Viljandi maakond 3:24:42         M40
##  6   499   345   Ritson, Jaanus      Harju maakond 3:29:41         M40
##  7   567   908 Tiisvend, Jaanus      Harju maakond 3:32:42         M35
##  8   638   564    Koval, Jaanus      Harju maakond 3:35:33         M21
##  9   710   532     Olop, Jaanus      Harju maakond 3:37:32         M40
## 10   716   407      Aus, Jaanus      Pärnu maakond 3:37:54         M35
## # ... with 93 more rows, and 1 more variables: Kuubik &lt;dbl&gt;</code></pre>
<p>Ups, we got ‘Jaanus’-es too!</p>
<p>Let’s add end of a line anchor <code>$</code> to get only ’Jaan’s and lets use <code>str_detect</code> verb:</p>
<pre class="r"><code>tm_2013 %&gt;% filter(str_detect(Nimi, &quot;, Jaan$&quot;)) %&gt;% tbl_df # Nimi is name and is given as &#39;lastname, firstname&#39;. We use tbl_df to print only head of the table.</code></pre>
<pre><code>## # A tibble: 31 x 7
##     Koht    Nr           Nimi          Elukoht     Aeg Vanuseklass
##    &lt;int&gt; &lt;int&gt;          &lt;chr&gt;            &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;
##  1   197   249     Jõgi, Jaan     Võru maakond 3:13:21         M60
##  2  1072  1177 Jagomägi, Jaan    Tartu maakond 3:51:05         M35
##  3  1639  1735   Saviir, Jaan    Lääne maakond 4:08:01         M50
##  4  1778   956   Leppik, Jaan    Harju maakond 4:12:01         M40
##  5  1793  1213    Harak, Jaan     Hiiu maakond 4:12:13         M55
##  6  1847  1359   Reiner, Jaan Viljandi maakond 4:13:53         M40
##  7  2049  6144 Lendsaar, Jaan     Võru maakond 4:20:49         M20
##  8  2076  6051   Joonas, Jaan     Võru maakond 4:21:38         M40
##  9  2193  2239    Sibul, Jaan    Harju maakond 4:24:38         M35
## 10  2321  1907  Pedajas, Jaan    Valga maakond 4:28:08         M35
## # ... with 21 more rows, and 1 more variables: Kuubik &lt;dbl&gt;</code></pre>
<p>Good!</p>
</div>
<div id="replace-strings" class="section level2">
<h2>Replace strings</h2>
<p>To substitute parts of a string, base R uses <code>sub</code> and <code>gsub</code> to perform replacement of the first and all matches respectively. <code>stringr</code> versions of these verbs are <code>str_replace</code> and <code>str_replace_all</code>, respectively:</p>
<pre class="r"><code>str_replace(y, &quot;Area&quot;, &quot;XXX&quot;) # to replace first occurence of Area in each string with XXX</code></pre>
<pre><code>## [1] &quot;XXXShape_Area&quot;            &quot;XXXShape_Perimeter&quot;      
## [3] &quot;XXXShape_MajorAxisLength&quot; &quot;Intensity_MADIntensity&quot;</code></pre>
<pre class="r"><code>str_replace_all(y, &quot;Area&quot;, &quot;XXX&quot;) # replaces all Area-s with XXX</code></pre>
<pre><code>## [1] &quot;XXXShape_XXX&quot;             &quot;XXXShape_Perimeter&quot;      
## [3] &quot;XXXShape_MajorAxisLength&quot; &quot;Intensity_MADIntensity&quot;</code></pre>
<!-- # Using Dates and Times in R -->
<!-- % Bonnie Dixon -->
<!-- % 14-02-10 15:09:57 -->
<!-- *Today at the [Davis R Users' -->
<!-- Group](http://www.noamross.net/davis-r-users-group.html), [Bonnie -->
<!-- Dixon](http://ffhi.ucdavis.edu/people/directory/bmdixon) gave a tutorial on the -->
<!-- various ways to handle dates and times in R. Bonnie provided this great script -->
<!-- which walks through essential classes, functions, and packages. Here it is piped through -->
<!-- `knitr::spin`. The original R script can be found as a gist -->
<!-- [here](https://gist.github.com/noamross/8928124).* -->
</div>
</div>
<div id="date-and-time-classes" class="section level1">
<h1>Date and time classes</h1>
<p>Three date and time classes are built-in in R, <code>Date</code>, <code>POSIXct</code>, and <code>POSIXlt</code>.</p>
<div id="date" class="section level2">
<h2>Date</h2>
<p>If you have <strong>only dates</strong> in your data (but no times).</p>
<p>Create a date:</p>
<pre class="r"><code>bs &lt;- as.Date(&quot;2016-08-29&quot;)
class(bs)</code></pre>
<pre><code>## [1] &quot;Date&quot;</code></pre>
<pre class="r"><code>bs</code></pre>
<pre><code>## [1] &quot;2016-08-29&quot;</code></pre>
<p>If you don’t specify format, <code>as.Date</code> will try “%Y-%m-%d” then “%Y/%m/%d”. Other formats must be specified:</p>
<pre class="r"><code>es &lt;- as.Date(&quot;01/29/2017&quot;, format = &quot;%m/%d/%Y&quot;)
es  </code></pre>
<pre><code>## [1] &quot;2017-01-29&quot;</code></pre>
<pre class="r"><code>ch &lt;- as.Date(&quot;December 19, 2016&quot;, format = &quot;%B %d, %Y&quot;)
ch</code></pre>
<pre><code>## [1] NA</code></pre>
<p>The list of format symbols can be accessed via <code>strptime</code>:</p>
<pre class="r"><code>?strptime     </code></pre>
<p>Get the current date:</p>
<pre class="r"><code>Sys.Date()</code></pre>
<pre><code>## [1] &quot;2017-09-08&quot;</code></pre>
<p><strong>Calculations with dates</strong>. Find the difference between dates:</p>
<pre class="r"><code>es - bs</code></pre>
<pre><code>## Time difference of 153 days</code></pre>
<pre class="r"><code>difftime(ch, bs, units = &quot;weeks&quot;)</code></pre>
<pre><code>## Time difference of NA weeks</code></pre>
<p>Add or subtract days:</p>
<pre class="r"><code>bs + 40</code></pre>
<pre><code>## [1] &quot;2016-10-08&quot;</code></pre>
<pre class="r"><code>ch - 10</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Create a vector of dates and find the intervals between them:</p>
<pre class="r"><code>road.fatalities &lt;- as.Date(c(&quot;01.01.2016&quot;, &quot;05.01.2016&quot;, &quot;11.01.2016&quot;,&quot;18.01.2016&quot;,&quot;02.02.2016&quot;,&quot;08.02.2016&quot;,&quot;19.02.2016&quot;,&quot;25.02.2016&quot;, &quot;02.03.2016&quot;, &quot;28.03.2016&quot;, &quot;29.03.2016&quot;, &quot;21.03.2016&quot;, &quot;04.04.2016&quot;, &quot;12.04.2016&quot;, &quot;13.04.2016&quot;,&quot;09.05.2016&quot;,&quot;13.05.2016&quot;,&quot;16.05.2016&quot;, &quot;01.08.2016&quot;,&quot;22.08.2016&quot;), format = &quot;%d.%m.%Y&quot;)
road.fatalities &lt;- sort(road.fatalities) # just in case, lets sort it
road.fatalities</code></pre>
<pre><code>##  [1] &quot;2016-01-01&quot; &quot;2016-01-05&quot; &quot;2016-01-11&quot; &quot;2016-01-18&quot; &quot;2016-02-02&quot;
##  [6] &quot;2016-02-08&quot; &quot;2016-02-19&quot; &quot;2016-02-25&quot; &quot;2016-03-02&quot; &quot;2016-03-21&quot;
## [11] &quot;2016-03-28&quot; &quot;2016-03-29&quot; &quot;2016-04-04&quot; &quot;2016-04-12&quot; &quot;2016-04-13&quot;
## [16] &quot;2016-05-09&quot; &quot;2016-05-13&quot; &quot;2016-05-16&quot; &quot;2016-08-01&quot; &quot;2016-08-22&quot;</code></pre>
<pre class="r"><code>diff(road.fatalities)</code></pre>
<pre><code>## Time differences in days
##  [1]  4  6  7 15  6 11  6  6 19  7  1  6  8  1 26  4  3 77 21</code></pre>
<p>Create a sequence of dates:</p>
<pre class="r"><code>six.weeks &lt;- seq(Sys.Date(), length = 6, by = &quot;week&quot;) 
six.weeks</code></pre>
<pre><code>## [1] &quot;2017-09-08&quot; &quot;2017-09-15&quot; &quot;2017-09-22&quot; &quot;2017-09-29&quot; &quot;2017-10-06&quot;
## [6] &quot;2017-10-13&quot;</code></pre>
<pre class="r"><code>six.weeks &lt;- seq(Sys.Date(), length = 6, by = 7)
six.weeks</code></pre>
<pre><code>## [1] &quot;2017-09-08&quot; &quot;2017-09-15&quot; &quot;2017-09-22&quot; &quot;2017-09-29&quot; &quot;2017-10-06&quot;
## [6] &quot;2017-10-13&quot;</code></pre>
<pre class="r"><code>six.weeks &lt;- seq(Sys.Date(), length = 3, by = &quot;2 weeks&quot;)
six.weeks</code></pre>
<pre><code>## [1] &quot;2017-09-08&quot; &quot;2017-09-22&quot; &quot;2017-10-06&quot;</code></pre>
<p>See the internal integer representation:</p>
<pre class="r"><code>unclass(bs)</code></pre>
<pre><code>## [1] 17042</code></pre>
<p>Note, that internal integer representation of Date class is number of days from <code>January 1, 1970</code>:</p>
<pre class="r"><code>bs - as.Date(&quot;1970-01-01&quot;) # </code></pre>
<pre><code>## Time difference of 17042 days</code></pre>
</div>
<div id="posixct" class="section level2">
<h2>POSIXct</h2>
<p>If you have <strong>times in your data</strong>, this is usually the best class to use.</p>
<p>Create some POSIXct objects:</p>
<pre class="r"><code>mft1 &lt;- as.POSIXct(&quot;2014-03-11  17:14:15&quot;)
mft1</code></pre>
<pre><code>## [1] &quot;2014-03-11 17:14:15 EET&quot;</code></pre>
<p>Specify format:</p>
<pre class="r"><code>mft2 &lt;- as.POSIXct(&quot;22-Oct-2013 16:30:55&quot;, format = &quot;%d-%b-%Y %H:%M:%S&quot;)
mft2</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Specify the time zone:</p>
<pre class="r"><code>rstudio.webinar &lt;- as.POSIXct(&quot;November 9, 2016 11am&quot;, 
                  format = &quot;%B %d, %Y %I%p&quot;, 
                  tz = &quot;EST&quot;)
rstudio.webinar</code></pre>
<pre><code>## [1] NA</code></pre>
<p><strong>Some calculations with times</strong> Compare times:</p>
<pre class="r"><code>mft1 &gt; mft2</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Add or subtract seconds:</p>
<pre class="r"><code>mft1 + 30</code></pre>
<pre><code>## [1] &quot;2014-03-11 17:14:45 EET&quot;</code></pre>
<pre class="r"><code>mft2 - 30</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Find the difference between times:</p>
<pre class="r"><code>mft1 - mft2</code></pre>
<pre><code>## Time difference of NA secs</code></pre>
<p>Automatically adjusts for daylight savings time. Last sunday in march, clocks are adjusted forward one hour:</p>
<pre class="r"><code>as.POSIXct(&quot;2016-03-27 3:00:00&quot;) - as.POSIXct(&quot;2016-03-26 23:55:00&quot;) # note that time difference is only 2.08 hours</code></pre>
<pre><code>## Time difference of 5 mins</code></pre>
<p>Get the current time (in POSIXct by default):</p>
<pre class="r"><code>Sys.time()</code></pre>
<pre><code>## [1] &quot;2017-09-08 10:29:28 EEST&quot;</code></pre>
<p>See the internal integer representation in seconds:</p>
<pre class="r"><code>unclass(mft1)</code></pre>
<pre><code>## [1] 1394550855
## attr(,&quot;tzone&quot;)
## [1] &quot;&quot;</code></pre>
<pre class="r"><code>difftime(mft1, as.POSIXct(&quot;1970-01-01 00:00:00&quot;, tz = &quot;UTC&quot;), units = &quot;secs&quot;)</code></pre>
<pre><code>## Time difference of 1394550855 secs</code></pre>
</div>
<div id="posixlt" class="section level2">
<h2>POSIXlt</h2>
<p>This class enables easy extraction of specific componants of a time.</p>
<ul>
<li><code>ct</code> – calendar time</li>
<li><code>lt</code> – local time. <code>lt</code> also helps one remember that POXIXlt objects are <em>lists</em>.)</li>
</ul>
<p>Create a time:</p>
<pre class="r"><code>mft1.lt &lt;- as.POSIXlt(&quot;2014-03-11   17:14:15&quot;)
mft1.lt</code></pre>
<pre><code>## [1] &quot;2014-03-11 17:14:15 EET&quot;</code></pre>
<pre class="r"><code>unclass(mft1.lt)</code></pre>
<pre><code>## $sec
## [1] 15
## 
## $min
## [1] 14
## 
## $hour
## [1] 17
## 
## $mday
## [1] 11
## 
## $mon
## [1] 2
## 
## $year
## [1] 114
## 
## $wday
## [1] 2
## 
## $yday
## [1] 69
## 
## $isdst
## [1] 0
## 
## $zone
## [1] &quot;EET&quot;
## 
## $gmtoff
## [1] NA</code></pre>
<pre class="r"><code>unlist(mft1.lt)</code></pre>
<pre><code>##    sec    min   hour   mday    mon   year   wday   yday  isdst   zone 
##   &quot;15&quot;   &quot;14&quot;   &quot;17&quot;   &quot;11&quot;    &quot;2&quot;  &quot;114&quot;    &quot;2&quot;   &quot;69&quot;    &quot;0&quot;  &quot;EET&quot; 
## gmtoff 
##     NA</code></pre>
<p>Extract componants of a time object:</p>
<pre class="r"><code>mft1.lt$sec</code></pre>
<pre><code>## [1] 15</code></pre>
<pre class="r"><code>mft1.lt$wday</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Truncate or round off the time:</p>
<pre class="r"><code>trunc(mft1.lt, &quot;days&quot;)</code></pre>
<pre><code>## [1] &quot;2014-03-11 EET&quot;</code></pre>
<pre class="r"><code>trunc(mft1.lt, &quot;mins&quot;)</code></pre>
<pre><code>## [1] &quot;2014-03-11 17:14:00 EET&quot;</code></pre>
<p><strong>Summary of date and time classes</strong></p>
<ul>
<li>When you just have dates, use <code>Date</code>.</li>
<li>When you have times, <code>POSIXct</code> is usually the best,</li>
<li><code>POSIXlt</code> enables easy extraction of specific components</li>
<li>and there is also <code>chron</code> package when you don’t need to deal with timezones and daylight savings time.</li>
</ul>
</div>
<div id="manipulating-times-and-dates" class="section level2">
<h2>Manipulating times and dates</h2>
<div id="lubridate" class="section level3">
<h3>lubridate</h3>
<p>This package is a wrapper for POSIXct with more intuitive syntax.</p>
<pre class="r"><code>library(lubridate)</code></pre>
<p>Create a time. Note that lubridate uses UTC time zones as default:</p>
<pre class="r"><code>mft1.lub &lt;- ymd_hms(&quot;2014-03-11 17:14:15&quot;)
mft1.lub</code></pre>
<pre><code>## [1] &quot;2014-03-11 17:14:15 UTC&quot;</code></pre>
<p>We have to set timezone explicitly:</p>
<pre class="r"><code>mft2.lub &lt;- dmy_hm(&quot;22-Oct-2013 16:30&quot;, tz = &quot;EET&quot;) </code></pre>
<pre><code>## Warning: All formats failed to parse. No formats found.</code></pre>
<pre class="r"><code>mft2.lub</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Timezone can be easily changed using <code>force_tz</code>:</p>
<pre class="r"><code>mft1.lub &lt;- force_tz(mft1.lub, &quot;EET&quot;)
mft1.lub</code></pre>
<pre><code>## [1] &quot;2014-03-11 17:14:15 EET&quot;</code></pre>
<pre class="r"><code>rstudio.webinar &lt;- mdy_h(&quot;November 9, 2016 11am&quot;)</code></pre>
<pre><code>## Warning: All formats failed to parse. No formats found.</code></pre>
<pre class="r"><code>rstudio.webinar</code></pre>
<pre><code>## [1] NA</code></pre>
<pre class="r"><code>today &lt;- ymd(Sys.Date())
today</code></pre>
<pre><code>## [1] &quot;2017-09-08&quot;</code></pre>
<p>Some manipulations: Extract or reassign componants:</p>
<pre class="r"><code>year(mft1.lub)</code></pre>
<pre><code>## [1] 2014</code></pre>
<pre class="r"><code>week(mft1.lub)</code></pre>
<pre><code>## [1] 10</code></pre>
<pre class="r"><code>wday(mft1.lub, label = TRUE)</code></pre>
<pre><code>## [1] Tues
## Levels: Sun &lt; Mon &lt; Tues &lt; Wed &lt; Thurs &lt; Fri &lt; Sat</code></pre>
<pre class="r"><code>hour(mft1.lub)</code></pre>
<pre><code>## [1] 17</code></pre>
<pre class="r"><code>tz(mft1.lub)</code></pre>
<pre><code>## [1] &quot;EET&quot;</code></pre>
<pre class="r"><code>second(mft1.lub) &lt;- 7
mft1.lub</code></pre>
<pre><code>## [1] &quot;2014-03-11 17:14:07 EET&quot;</code></pre>
<p>Converting to decimal hours can facilitate some types of calculations:</p>
<pre class="r"><code>mft1.dechr &lt;- hour(mft1.lub) + minute(mft1.lub)/60 + second(mft1.lub)/3600
mft1.dechr</code></pre>
<pre><code>## [1] 17.23528</code></pre>
<ul>
<li>Lubridate distinguishes between four types of objects: instant, interval, duration, and period.</li>
<li>An instant is a specific moment in time.</li>
<li>Interval, duration, and period are all ways of recording time spans.</li>
</ul>
<p>Dates and times parsed in lubridate are instants:</p>
<pre class="r"><code>is.instant(mft1.lub)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Round an instant:</p>
<pre class="r"><code>round_date(mft1.lub, &quot;minute&quot;)</code></pre>
<pre><code>## [1] &quot;2014-03-11 17:14:00 EET&quot;</code></pre>
<pre class="r"><code>round_date(mft1.lub, &quot;day&quot;)</code></pre>
<pre><code>## [1] &quot;2014-03-12 EET&quot;</code></pre>
<p>Get the current time or date as an instant (<code>Sys.time()</code>):</p>
<pre class="r"><code>now()</code></pre>
<pre><code>## [1] &quot;2017-09-08 10:29:29 EEST&quot;</code></pre>
<p>Shortcut for <code>Sys.Date()</code></p>
<pre class="r"><code>today()</code></pre>
<pre><code>## [1] &quot;2017-09-08&quot;</code></pre>
<p>Some calculations with instants. Note that the units are seconds:</p>
<pre class="r"><code>mft1.lub - mft2.lub</code></pre>
<pre><code>## Time difference of NA secs</code></pre>
<pre class="r"><code>mft1.lub &gt; mft2.lub</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Add seconds:</p>
<pre class="r"><code>mft1.lub + 30</code></pre>
<pre><code>## [1] &quot;2014-03-11 17:14:37 EET&quot;</code></pre>
<p>An interval is the span of time that occurs between two specified instants.</p>
<pre class="r"><code>time.to.xmas &lt;- interval(now(), dmy(&quot;24-12-2016&quot;))
time.to.xmas</code></pre>
<pre><code>## [1] 2017-09-08 10:29:29 EEST--2016-12-24 02:00:00 EET</code></pre>
<p>Check whether a certain instant occured with a specified interval:</p>
<pre class="r"><code>rstudio.webinar %within% time.to.xmas</code></pre>
<pre><code>## [1] NA</code></pre>
<pre class="r"><code>mft1.lub %within% time.to.xmas</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>Determine whether two intervals overlap:</p>
<pre class="r"><code>daylight &lt;- as.interval(ymd_hm(&quot;2016-03-26 23:55&quot;), ymd_hm(&quot;2016-03-27 3:00&quot;))
daylight</code></pre>
<pre><code>## [1] 2016-03-26 23:55:00 UTC--2016-03-27 03:00:00 UTC</code></pre>
<pre class="r"><code>inbed &lt;- as.interval(ymd_hm(&quot;2016-03-26 22:30&quot;), ymd_hm(&quot;2016-03-27 7:30&quot;))</code></pre>
<pre class="r"><code>int_overlaps(inbed, daylight)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>A <strong>duration is a time span not anchored to specific start and end times</strong>. It has an exact, fixed length, and is stored internally in seconds. Lets go to the wild side and create some durations:</p>
<pre class="r"><code>six.minutes &lt;- dminutes(6)
six.minutes</code></pre>
<pre><code>## [1] &quot;360s (~6 minutes)&quot;</code></pre>
<pre class="r"><code>five.days &lt;- ddays(5)
five.days</code></pre>
<pre><code>## [1] &quot;432000s (~5 days)&quot;</code></pre>
<p>And now, after some practice with days and minutes, lets create whole year…</p>
<pre class="r"><code>one.year &lt;- dyears(1)
one.year</code></pre>
<pre><code>## [1] &quot;31536000s (~52.14 weeks)&quot;</code></pre>
<pre class="r"><code>as.duration(inbed)</code></pre>
<pre><code>## [1] &quot;32400s (~9 hours)&quot;</code></pre>
<p>Calculations with durations:</p>
<pre class="r"><code>year(mft1.lub)</code></pre>
<pre><code>## [1] 2014</code></pre>
<pre class="r"><code>mft1.lub + one.year</code></pre>
<pre><code>## [1] &quot;2015-03-11 17:14:07 EET&quot;</code></pre>
<pre class="r"><code>five.days + dhours(12)</code></pre>
<pre><code>## [1] &quot;475200s (~5.5 days)&quot;</code></pre>
<pre class="r"><code>six.minutes/as.duration(inbed)</code></pre>
<pre><code>## [1] 0.01111111</code></pre>
<p>A <strong>period is a time span not anchored to specific start and end times and measured in units larger than seconds with inexact lengths</strong>. Create some periods:</p>
<pre class="r"><code>three.weeks &lt;- weeks(3)
three.weeks</code></pre>
<pre><code>## [1] &quot;21d 0H 0M 0S&quot;</code></pre>
<pre class="r"><code>four.hours &lt;- hours(4)
four.hours</code></pre>
<pre><code>## [1] &quot;4H 0M 0S&quot;</code></pre>
<p>Calculations with periods:</p>
<pre class="r"><code>mft2.lub</code></pre>
<pre><code>## [1] NA</code></pre>
<pre class="r"><code>mft2.lub + three.weeks</code></pre>
<pre><code>## [1] NA</code></pre>
<pre class="r"><code>sabbatical &lt;- months(6) + days(12)
sabbatical</code></pre>
<pre><code>## [1] &quot;6m 12d 0H 0M 0S&quot;</code></pre>
<pre class="r"><code>three.weeks/sabbatical</code></pre>
<pre><code>## estimate only: convert to intervals for accuracy</code></pre>
<pre><code>## [1] 0.1078998</code></pre>
</div>
</div>
<div id="calculating-mean-clock-times" class="section level2">
<h2>Calculating mean clock times</h2>
<p>Say we have a vector of clock times in decimal hours and <strong>we want to calculate the mean clock time</strong>.</p>
<pre class="r"><code>bed.times &lt;- c(23.9, 0.5, 22.7, 0.1, 23.3, 1.2, 23.6)
bed.times</code></pre>
<pre><code>## [1] 23.9  0.5 22.7  0.1 23.3  1.2 23.6</code></pre>
<pre class="r"><code>mean(bed.times)  # doesn&#39;t work, gives aritmetic mean</code></pre>
<pre><code>## [1] 13.61429</code></pre>
<p>The <strong>clock has a circular scale</strong>, which ends where it begins, so we need to use circular statistics. Get the package <code>psych</code>.</p>
<pre class="r"><code>library(psych)</code></pre>
<pre><code>## 
## Attaching package: &#39;psych&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:ggplot2&#39;:
## 
##     %+%, alpha</code></pre>
<pre class="r"><code>circadian.mean(bed.times)</code></pre>
<pre><code>## [1] 23.89926</code></pre>
</div>
<div id="using-times-and-dates-in-a-data-frame" class="section level2">
<h2>Using times and dates in a data frame</h2>
<p>Here is a data frame with a week of hypothetical times of going to bed and getting up for one person, and the total amount of time sleep time obtained each night according to a sleep monitoring device.</p>
<pre class="r"><code>sleep &lt;- 
  data.frame(
    bed.time = ymd_hms(&quot;2013-09-01 23:05:24&quot;, &quot;2013-09-02 22:51:09&quot;,
                       &quot;2013-09-04 00:09:16&quot;, &quot;2013-09-04 23:43:31&quot;,
                       &quot;2013-09-06 00:17:41&quot;, &quot;2013-09-06 22:42:27&quot;,
                       &quot;2013-09-08 00:22:27&quot;),
    rise.time = ymd_hms(&quot;2013-09-02 08:03:29&quot;, &quot;2013-09-03 07:34:21&quot;,
                        &quot;2013-09-04 07:45:06&quot;, &quot;2013-09-05 07:07:17&quot;,
                        &quot;2013-09-06 08:17:13&quot;, &quot;2013-09-07 06:52:11&quot;,
                        &quot;2013-09-08 07:15:19&quot;),
    sleep.time = dhours(c(6.74, 7.92, 7.01, 6.23, 6.34, 7.42, 6.45))
              ); sleep</code></pre>
<pre><code>##              bed.time           rise.time           sleep.time
## 1 2013-09-01 23:05:24 2013-09-02 08:03:29 24264s (~6.74 hours)
## 2 2013-09-02 22:51:09 2013-09-03 07:34:21 28512s (~7.92 hours)
## 3 2013-09-04 00:09:16 2013-09-04 07:45:06 25236s (~7.01 hours)
## 4 2013-09-04 23:43:31 2013-09-05 07:07:17 22428s (~6.23 hours)
## 5 2013-09-06 00:17:41 2013-09-06 08:17:13 22824s (~6.34 hours)
## 6 2013-09-06 22:42:27 2013-09-07 06:52:11 26712s (~7.42 hours)
## 7 2013-09-08 00:22:27 2013-09-08 07:15:19 23220s (~6.45 hours)</code></pre>
<p>We want to calculate sleep efficiency, the percent of time in bed spent asleep.</p>
<pre class="r"><code>sleep$efficiency &lt;- 
  round(sleep$sleep.time/(sleep$rise.time - sleep$bed.time)*100, 1)
sleep</code></pre>
<pre><code>##              bed.time           rise.time           sleep.time efficiency
## 1 2013-09-01 23:05:24 2013-09-02 08:03:29 24264s (~6.74 hours)       75.2
## 2 2013-09-02 22:51:09 2013-09-03 07:34:21 28512s (~7.92 hours)       90.8
## 3 2013-09-04 00:09:16 2013-09-04 07:45:06 25236s (~7.01 hours)       92.3
## 4 2013-09-04 23:43:31 2013-09-05 07:07:17 22428s (~6.23 hours)       84.2
## 5 2013-09-06 00:17:41 2013-09-06 08:17:13 22824s (~6.34 hours)       79.3
## 6 2013-09-06 22:42:27 2013-09-07 06:52:11 26712s (~7.42 hours)       90.9
## 7 2013-09-08 00:22:27 2013-09-08 07:15:19 23220s (~6.45 hours)       93.7</code></pre>
<p>Now let’s calculate the mean of each column:</p>
<pre class="r"><code>colMeans(sleep)  # doesn&#39;t work</code></pre>
<pre class="r"><code>circadian.mean(hour(sleep$bed.time) + 
               minute(sleep$bed.time)/60 + 
               second(sleep$bed.time)/3600)</code></pre>
<pre><code>## [1] 23.60028</code></pre>
<pre class="r"><code>circadian.mean(hour(sleep$rise.time) + 
               minute(sleep$rise.time)/60 + 
               second(sleep$rise.time)/3600)</code></pre>
<pre><code>## [1] 7.55924</code></pre>
<pre class="r"><code>mean(sleep$sleep.time)/3600</code></pre>
<pre><code>## [1] 6.872857</code></pre>
<pre class="r"><code>mean(sleep$efficiency)</code></pre>
<pre><code>## [1] 86.62857</code></pre>
<!-- We can also plot sleep duration and efficiency across the week: -->
<!-- ```{r} -->
<!-- par(mar = c(5, 4, 4, 4)) -->
<!-- plot(round_date(sleep$rise.time, "day"), sleep$efficiency,  -->
<!--      type = "o", col = "blue", xlab = "Morning", ylab = NA) -->
<!-- par(new = TRUE) -->
<!-- plot(round_date(sleep$rise.time, "day"), sleep$sleep.time/3600,  -->
<!--      type = "o", col = "red", axes = FALSE, ylab = NA, xlab = NA) -->
<!-- axis(side = 4) -->
<!-- mtext(side = 4, line = 2.5, col = "red", "Sleep duration") -->
<!-- mtext(side = 2, line = 2.5, col = "blue", "Sleep efficiency") -->
<!-- ``` -->
<!-- More resources on times and dates -->
<!-- Date and time tutorials for R: -->
<!-- + [http://www.stat.berkeley.edu/classes/s133/dates.html](http://www.stat.berkeley.edu/classes/s133/dates.html) -->
<!-- + [http://science.nature.nps.gov/im/datamgmt/statistics/r/fundamentals/dates.cfm](http://science.nature.nps.gov/im/datamgmt/statistics/r/fundamentals/dates.cfm) -->
<!-- + [http://en.wikibooks.org/wiki/R_Programming/Times_and_Dates](http://en.wikibooks.org/wiki/R_Programming/Times_and_Dates) -->
<!-- [lubridate](http://www.jstatsoft.org/v40/i03/paper) -->
<!-- Time zone and daylight saving time info: -->
<!-- + [http://www.timeanddate.com/](http://www.timeanddate.com/) -->
<!-- + [http://en.wikipedia.org/wiki/List_of_tz_database_time_zones](http://en.wikipedia.org/wiki/List_of_tz_database_time_zones) -->
<!-- + [http://www.twinsun.com/tz/tz-link.htm](http://www.twinsun.com/tz/tz-link.htm) -->
<!-- + Also see the R help file at `?Sys.timezone` -->
</div>
</div>
<div id="functions" class="section level1">
<h1>Functions</h1>
<p>A function is a piece of code to carry out a specified task, e.g. calculate mean, split data frame. It may accept arguments (or not) and it may return zero to more values or objects.</p>
<p>General form of R function is following:</p>
<pre><code>
function(argslist) expr
</code></pre>
<p>Where, <code>argslist</code> is either empty or one to more <code>name</code> or <code>name=expression</code> terms. When calling a function you can specify arguments by position, by complete name, or by partial name.</p>
<p>Example function with no arguments, doing only one thing:</p>
<pre class="r"><code>dedication &lt;- function() {
  cat(&quot;And Pierce Brosnan how dare you prescribe\n
      Sad grief and bed wet pills&quot;)
}</code></pre>
<p>Above defined function prints cryptic lyrics (Credit: ME Smith)</p>
<pre class="r"><code>dedication()</code></pre>
<pre><code>## And Pierce Brosnan how dare you prescribe
## 
##       Sad grief and bed wet pills</code></pre>
<p>But we can tune above function to insert your computer’s username into that line instead of that actor:</p>
<pre class="r"><code>not_medication &lt;- function() cat(paste(&quot;And&quot;, system(&quot;whoami&quot;,T), &quot;how dare you prescribe\n
Sad grief and bed wet pills&quot;))</code></pre>
<pre class="r"><code>not_medication()</code></pre>
<pre><code>## And taavi how dare you prescribe
## 
## Sad grief and bed wet pills</code></pre>
<ul>
<li>Function names must be concise, <a href="http://thefall.org/discography/data/album31.html">like above</a></li>
<li>Note that, when writing a multiline function, braces <code>{}</code> must be used to enclose the body of the function.</li>
</ul>
<p>Onliners like this does not need braces:</p>
<pre class="r"><code>plusone &lt;- function(x) x + 1
plusone(1)</code></pre>
<pre><code>## [1] 2</code></pre>
<div id="default-arguments" class="section level2">
<h2>Default arguments</h2>
<p>Some arguments have default values specified, as shown below. Arguments without a default must have a value supplied for the function to run. You do not need to provide a value for those arguments with a default, as the function will use the default value:</p>
<pre class="r"><code>sum_stat &lt;- function(x, f = &quot;mean&quot;){
  do.call(f, list(x))
}

v &lt;- rnorm(10)
sum_stat(v) # by default this function calculates mean</code></pre>
<pre><code>## [1] -0.3977647</code></pre>
<p>But we can also calculate median, if we change f argument:</p>
<pre class="r"><code>sum_stat(v, f = &quot;median&quot;) # </code></pre>
<pre><code>## [1] -0.4815106</code></pre>
</div>
<div id="ellipsis" class="section level2">
<h2>Ellipsis</h2>
<p>The addition of <code>...</code>, or <strong>ellipsis</strong>, in the function definition allows other arguments to be passed into the function, and passed onto to another function:</p>
<pre class="r"><code># Let&#39;s redifine sum_stat function with ellipsis to pass additional arguments to summary function
sum_stat2 &lt;- function(x, f = &quot;mean&quot;, ...){
  do.call(f, list(x, ...)) # do.call constructs and executes a function call from a function and a list of arguments to be passed to it
}

v2 &lt;- c(NA, v, NA, NA)
sum_stat2(v2) # NA-s start to give trouble, as mean fun has na.rm = FALSE argument</code></pre>
<pre><code>## [1] NA</code></pre>
<pre class="r"><code>sum_stat2(v2, na.rm = TRUE) # here we pass na.rm = TRUE to our function and voila!</code></pre>
<pre><code>## [1] -0.3977647</code></pre>
</div>
<div id="function-environment" class="section level2">
<h2>Function environment</h2>
<p>By default, function returns result from last expression:</p>
<pre class="r"><code>logit &lt;- function(p) {
 odds &lt;- p/(1-p)
 log(odds)
}

logit(0.5)</code></pre>
<pre><code>## [1] 0</code></pre>
<p>Importantly, objects that are created within the function are local to the environment of the function. If you direct your last expression into an object inside function, you need to explicitly <code>return()</code> the value of that object:</p>
<pre class="r"><code># look what happens
logit2 &lt;- function(p) {
 odds &lt;- p/(1-p)
 log_odds &lt;- log(odds) # last expression&#39;s value is assigned to log_odds object inside function
}
logit2(0.5) # nothing is returned

## use of return()
logit3 &lt;- function(p) {
 odds &lt;- p/(1-p)
 log_odds &lt;- log(odds) # last expression&#39;s value is assigned to log_odds object inside function
 return(log_odds) # return object log_odds value
 }
logit3(0.5) </code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code>## use of return()
logit4 &lt;- function(p) {
 odds &lt;- p/(1-p)
 log_odds &lt;- log(odds) # last expression&#39;s value is assigned to log_odds object inside function
 return(list(odds = odds, log_odds = log_odds)) # return two objects from function environment as named list
}

logit4(0.5) </code></pre>
<pre><code>## $odds
## [1] 1
## 
## $log_odds
## [1] 0</code></pre>
</div>
<div id="anonymous-function-inside-for-loop" class="section level2">
<h2>Anonymous function inside for loop</h2>
<p><code>lapply()</code>/<code>sapply()</code> takes a function, applies it to each element in a list/vector, and returns the results in the form of a list. Its easy to use when you want to calculate eg. mean of each list element. But what if you need to do something more specific with your data:</p>
<pre class="r"><code>let &lt;- c(&quot;a&quot;,&quot;z&quot;,&quot;x&quot;,&quot;u&quot;,&quot;b&quot;) # we have a list of letters
sapply(let, function(x) grep(x, letters)) # we need to know the position of each letter in alphabet</code></pre>
<pre><code>##  a  z  x  u  b 
##  1 26 24 21  2</code></pre>
</div>
<div id="functional-sequence" class="section level2">
<h2>Functional sequence</h2>
<p><code>magrittr</code> allows to use <code>%&gt;%</code> piping operator not only to produce values but also <a href="https://blog.rstudio.org/2014/12/01/magrittr-1-5/">to produce functions</a>. This kind of functional sequences denote input with <code>.</code> dot:</p>
<pre class="r"><code>library(magrittr)</code></pre>
<pre><code>## 
## Attaching package: &#39;magrittr&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:tidyr&#39;:
## 
##     extract</code></pre>
<pre class="r"><code>mae &lt;- . %&gt;% abs %&gt;% mean(na.rm = TRUE)
mae(rnorm(10))</code></pre>
<pre><code>## [1] 1.01109</code></pre>
<p>This is similar to following function:</p>
<pre class="r"><code>mae &lt;- function(x) {
  mean(abs(x), na.rm = TRUE)
}</code></pre>
<p>Quite common use case of these functional sequences is inside lapply/sapply:</p>
<pre class="r"><code>library(dplyr)
library(readr)
library(reshape2)
data &lt;- paths-to-csv-files %&gt;% lapply(. %&gt;% read_csv %&gt;% melt)</code></pre>
<p>It’s cool that you can subset these functional sequences and use only parts of them when necessary:</p>
<pre class="r"><code>mae[2](rnorm(5))</code></pre>
<pre><code>## [1] -0.1033614</code></pre>
<pre class="r"><code>mae[1](rnorm(10))</code></pre>
<pre><code>##  [1] 0.5926652 1.7963513 0.7491883 0.3358356 0.6365017 0.6814533 0.4140032
##  [8] 0.3712234 2.1135068 0.9381112</code></pre>
<div id="another-example" class="section level4">
<h4>Another example</h4>
<p>Let’s create function to calculate <strong>standardised effect size, Cohen’s d</strong>. First let’s simulate some toy data of blood pressure readings from patients with high systolic bp, treated either with drug or placebo:</p>
<pre class="r"><code>library(ggplot2)
probs_h &lt;- pnorm(70:190, 150, 7) 
probs_n &lt;- pnorm(70:190, 130, 7)
m &lt;- data.frame(bp = c(sample(70:190, 56, replace = T, prob = probs_h), 
                sample(70:190, 60, replace = T, prob = probs_n)), 
                tr = c(rep(&quot;placebo&quot;, 56), rep(&quot;drug&quot;, 60)))</code></pre>
<p>This is how our dummy dataset looks like:</p>
<pre class="r"><code>ggplot(m, aes(tr, bp)) + geom_boxplot() + geom_jitter(width = 0.5)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-359-1.png" width="288" style="display: block; margin: auto;" /></p>
<p><a href="https://en.wikipedia.org/wiki/Effect_size">Cohen’s d is defined</a> as the difference between two means divided by a standard deviation for the data:</p>
<p><span class="math display">\[d = \frac{\bar{x}_1-\bar{x}_2}{s}\]</span></p>
<p><span class="math inline">\(s\)</span> is pooled standard deviation:</p>
<p><span class="math display">\[s = \sqrt{\frac{(n_1-1){s_1}^2+(n_2-1){s_2}^2}{n_1+n_2-2}}\]</span></p>
<p>Using above equations, we define function:</p>
<pre class="r"><code>cohensd &lt;- function(x1, x2){ # &#39;{}&#39; because our function is spread on multiple lines
  
  n1 &lt;- length(x1) - 1
  n2 &lt;- length(x2) - 1
  
  # mean difference
  md  &lt;- abs(mean(x1, na.rm = T) - mean(x2, na.rm = T))        
  
  # common sd
  s &lt;- n1 * var(x1, na.rm = T) + n2 * var(x2, na.rm = T)
  s &lt;- s/(n1 + n2)
  s &lt;- sqrt(s)                     
  
  # calculate Cohen&#39;s d
  md/s # last expression&#39;s result is returned
}</code></pre>
<p>Cohen’s d is interpreted that d values of 0.2, 0.5, and 0.8 represent small, medium, and large effect sizes respectively:</p>
<pre class="r"><code>bp &lt;- split(m$bp, m$tr) # to split data frame into two vectors
cohensd(bp$placebo, bp$drug) # to input treatment groups as vectors</code></pre>
<pre><code>## [1] 0.4465261</code></pre>
<p>Because our function arguments are two vectors x1 and x2 and we had data frame in the long format, we had to split data frame into vectors. [Can we embed these two vectors into data frame in the long format (two cols - one col per vector)?]</p>
<p>We can try to wrap this function into another function to use our data frame:</p>
<pre class="r"><code>cohens_d &lt;- function(data, values, group){
  v &lt;- split(data[[values]], data[[group]])
  cohensd(v[[1]], v[[2]])
}
save(cohens_d, file = &quot;lib/cohens_d.R&quot;) # save your function into lib folder</code></pre>
<pre class="r"><code>cd &lt;- cohens_d(m, &quot;bp&quot;, &quot;tr&quot;)
cd</code></pre>
<pre><code>## [1] 0.4465261</code></pre>
<p>Now we can create function to insert word explaining the size of the effect into text:</p>
<pre class="r"><code>mansplain_cohensd &lt;- function(x) {
  if(x&lt;=0.2) return(&quot;small&quot;) 
  if(x&gt;=0.2&amp;x&lt;=0.5) return(&quot;medium&quot;)
  if(x&gt;0.5&amp;x&lt;Inf) return(&quot;large&quot;)
  if(x==Inf) return(&quot;cosmos&quot;)
}

cdv &lt;- mansplain_cohensd(cd)
cdv</code></pre>
<pre><code>## [1] &quot;medium&quot;</code></pre>
<pre><code>Seems that the standardised effect size for the drug treatment effect on blood pressure is **` r round(cd, 2)`**, which means it&#39;s **` r mansplain_cohensd(cd)`**.</code></pre>
<p>Whitch produces following output:</p>
<p>Seems that the standardised effect size for the drug treatment effect on blood pressure is <strong>0.45</strong>, which means it’s <strong>medium</strong>.</p>
<hr />
<ul>
<li>Try to keep your functions in separate sub directory <code>lib</code> in your project’s dir</li>
<li>load functions using <code>load(lib/cohens_d.R)</code></li>
</ul>
<p>Good function is:</p>
<ul>
<li>short</li>
<li>performs one task</li>
<li>has intuitive short name</li>
</ul>
</div>
</div>
</div>
<div id="reports-with-rmarkdown" class="section level1">
<h1>Reports with rmarkdown</h1>
<p>R markdown is a variant of markdown that has embedded R code chunks. R markdown allows you to combine your R code, producing statistics and plots, with write-up. With the help of knitr and pandoc R markdown documents can be converted into reports in html, pdf or MS word format.</p>
<p><a href="http://kbroman.org/knitr_knutshell/pages/Rmarkdown.html">Quick overview of R markdown document, what it contains and how its structure looks like.</a></p>
<p><a href="https://www.rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf">R markdown cheatsheet</a>.</p>
<strong>This is how basic rmarkdown document template looks like in RStudio:</strong>
<pre><code>---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.</code></pre>
<div id="yaml" class="section level3">
<h3>YAML</h3>
<p>Lets break down this document, first part, embedded between double <code>---</code> is YAML header. We can pass additional arguments to header, like author or date:</p>
<pre><code>---
title: "Reproducible Data Analysis in R"
author: "Ülo Maiväli^1^, Taavi Päll^2^"
date: "`r Sys.Date()`" 
output:
  html_document:
    theme: journal
    highlight: pygments
    toc: true
    toc_float: true
    toc_depth: 4
---</code></pre>
<p>Note that above, date is returned as <code>Sys.Date()</code> using R code, but it could be much simpler, like “29. september 2016”. If you run Knit from RStudio <strong>all fields in YAML are optional</strong>. Default <code>output: html_document</code> specifies .html output, <code>pdf_document</code> and <code>word_document</code> specify that .pdf and .docx ,respectively, is genereated by pandoc.</p>
</div>
<div id="code-chunks" class="section level3">
<h3>Code chunks</h3>
<p>Most important parts of R markdown document are R code chunks, which look like this:</p>
<pre><code>
```{r plotnorm}
x <- rnorm(100)
boxplot(x)
```
</code></pre>
R markdown chunks start with triple backticks, followed by <code>{r}</code>:
<pre><code>
```{r chunkname}
</code></pre>
Then comes your R code. And chunk ends with triple backticks (grave accent):
<pre><code>
```
</code></pre>
<p>An R Markdown document usually contains many code chunks. All consequtive chunks are evaluated in order of appearance in a single R session. All objects generated will be preserved in future chunks. It’s like running source on your R file without interleaved text. In fact, you can pull out only R code from your R markdown file using knitr command <code>purl</code>.</p>
</div>
<div id="chunk-options" class="section level3">
<h3>Chunk options</h3>
<p>Chunk output can be customized with knitr <a href="http://yihui.name/knitr/options/">options</a>, arguments set in the <code>{}</code> of a chunk header. Some of the frequently used chunk options:</p>
<ul>
<li><code>include = FALSE</code> prevents code and results from appearing in the finished file. R Markdown still runs the code in the chunk, and the results can be used by other chunks.</li>
<li><code>echo = FALSE</code> prevents code, but not the results from appearing in the finished file. This is a useful way to embed figures.</li>
<li><code>message = FALSE</code> prevents messages that are generated by code from appearing in the finished file.</li>
<li><code>warning = FALSE</code> prevents warnings that are generated by code from appearing in the finished.</li>
<li><code>fig.cap = &quot;...&quot;</code> adds a figure caption.</li>
</ul>
<p>To knit this rmarkdown document into a html, pdf or word document hit <code>Knit</code> button in the head of source file window in RStudio:</p>
<div class="figure">
<img src="graphs/knit.png" alt="It is easy to Knit your R markdown document in RStudio." />
<p class="caption">It is easy to Knit your R markdown document in RStudio.</p>
</div>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
