<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-1.1/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-1.1/highlight.js"></script>
<link href="site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Reproducible Data Analysis in R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
    Home
  </a>
</li>
<li>
  <a href="about.html">
    <span class="fa fa-info"></span>
     
    About
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>

<div id="TOC">
<ul>
<li><a href="#data-structures">Data structures</a></li>
<li><a href="#selecting-by-index">Selecting by index</a></li>
<li><a href="#vectors">Vectors</a></li>
<li><a href="#data-frame">Data frame</a><ul>
<li><a href="#indexing-data.frames">Indexing data.frames</a></li>
</ul></li>
<li><a href="#matrix">Matrix</a></li>
<li><a href="#list">List</a><ul>
<li><a href="#indexing-lists">Indexing lists</a></li>
<li><a href="#output-from-statistical-tests">Output from statistical tests</a></li>
</ul></li>
</ul>
</div>

<hr />
<hr />
<div id="data-structures" class="section level1">
<h1>Data structures</h1>
<ul>
<li><strong>Atomic vectors</strong> are arrays that contain a single data type (logical, real, complex, character). Each of the following is a one-dimensional atomic vector:</li>
</ul>
<pre class="r"><code>passed &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE) # random sequence
class(passed)</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<pre class="r"><code>ages &lt;- c(53, 51, 25, 67, 66, 41, 62, 42) # random numbers
class(ages)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>namez &lt;- c(&quot;Marina&quot;, &quot;Allar&quot;, &quot;Siim&quot;, &quot;Mart&quot;, &quot;Mailis&quot;, &quot;Eiki&quot;, &quot;Urmas&quot;) # random names, names is R function!
class(namez)  </code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<p>A scalar is an atomic vector with a single element. So <code>k &lt;- 2</code> is a shortcut for <code>k &lt;- c(2)</code>.</p>
<ul>
<li>A <strong>matrix</strong> is an atomic vector that has a dimension attribute, <code>dim()</code>, containing two elements (<code>nrow</code>, number of rows and <code>ncol</code>, number of columns)</li>
</ul>
<pre class="r"><code>matrix(ages, nrow = 2)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]   53   25   66   62
## [2,]   51   67   41   42</code></pre>
<ul>
<li><strong>Lists</strong> are collections of atomic vectors and/or other lists.</li>
</ul>
<pre class="r"><code>mylist &lt;- list(passed, ages, namez)
mylist</code></pre>
<pre><code>## [[1]]
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## [[2]]
## [1] 53 51 25 67 66 41 62 42
## 
## [[3]]
## [1] &quot;Marina&quot; &quot;Allar&quot;  &quot;Siim&quot;   &quot;Mart&quot;   &quot;Mailis&quot; &quot;Eiki&quot;   &quot;Urmas&quot;</code></pre>
<p>We can assign names to list objects:</p>
<pre class="r"><code>names(mylist) &lt;- c(&quot;passed&quot;, &quot;ages&quot;, &quot;namez&quot;)
mylist</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## $ages
## [1] 53 51 25 67 66 41 62 42
## 
## $namez
## [1] &quot;Marina&quot; &quot;Allar&quot;  &quot;Siim&quot;   &quot;Mart&quot;   &quot;Mailis&quot; &quot;Eiki&quot;   &quot;Urmas&quot;</code></pre>
<ul>
<li><strong>Data frames</strong> are a special type of list, where each atomic vector in the collection has the same length. Each vector represents a column (variable) in the data frame.</li>
</ul>
<pre class="r"><code>exam &lt;- data.frame(name = namez, passed = passed)
exam</code></pre>
<pre><code>##     name passed
## 1 Marina   TRUE
## 2  Allar  FALSE
## 3   Siim  FALSE
## 4   Mart  FALSE
## 5 Mailis   TRUE
## 6   Eiki   TRUE
## 7  Urmas   TRUE</code></pre>
<div class="figure">
<img src="https://raw.githubusercontent.com/Anonymous-Y/BlogImage/master/r-intro-3.jpg" alt="Illustration of R data types. Image: http://yzc.me/2015/12/11/r-intro-1/" />
<p class="caption">Illustration of R data types. Image: <a href="http://yzc.me/2015/12/11/r-intro-1/" class="uri">http://yzc.me/2015/12/11/r-intro-1/</a></p>
</div>
</div>
<div id="selecting-by-index" class="section level1">
<h1>Selecting by index</h1>
<p>Index gives the address that specifies the elements of vector/matrix/list or data.frame, which are then automatically selected.</p>
<ul>
<li>Indexing begins at 1 (not 0) in R</li>
<li>Indexing operators in R are square brackets – ‘[’, <code>[[</code> and dollar sign <code>$</code><br />
</li>
<li><code>[</code> allows selecting more than one element, whereas <code>[[</code> and <code>$</code> select only one element.</li>
<li>Empty index [,] means “select all” – <code>a[,1]</code> means “select all rows and 1st column from <code>a</code>”.</li>
</ul>
<!-- ```{r} -->
<!-- '['(c(1,2,3), 1) == c(1,2,3)[1] # as you can see these are both identical -->
<!-- ``` -->
<!-- + you can select values, rows or columns by index -->
<!-- + `-` (minus) before index means "not this element" -->
<!-- + ! means "not" -->
<!-- + != means "not equal" -->
<!-- + == means "equal" -->
<p>During initial data exploration it is often necessary to have a look how the head of your table looks like, for this you can use convenience methods <code>head</code> and <code>tail</code> which are returning first and last elements of a object, respectively:</p>
<pre class="r"><code>head(mtcars) # Prints first 6 elements (rows) as default</code></pre>
<pre><code>##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1</code></pre>
<pre class="r"><code>tail(mtcars, n = 3) # Prints last 3 elements (rows)</code></pre>
<pre><code>##                mpg cyl disp  hp drat   wt qsec vs am gear carb
## Ferrari Dino  19.7   6  145 175 3.62 2.77 15.5  0  1    5    6
## Maserati Bora 15.0   8  301 335 3.54 3.57 14.6  0  1    5    8
## Volvo 142E    21.4   4  121 109 4.11 2.78 18.6  1  1    4    2</code></pre>
<p>Tip: you can use <code>tail</code> to return the very last element of a object with unknown length.</p>
<pre class="r"><code>tail(LETTERS, n = 1)</code></pre>
<pre><code>## [1] &quot;Z&quot;</code></pre>
</div>
<div id="vectors" class="section level1">
<h1>Vectors</h1>
<p>The combine function <code>c()</code> is used to form the vector.</p>
<pre class="r"><code>a &lt;- c(1, 2, 5, -3, 6, -2, 4)
b &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
d &lt;- c(TRUE,TRUE,TRUE,FALSE,TRUE,FALSE) # We use d instead of c as vector name. Why?</code></pre>
<p><code>a</code> is a numeric vector, <code>b</code> is a character vector, and <code>d</code> is a logical vector. The data in a vector can be only one type (numeric, character, or logical).</p>
<p>You can refer to elements of a vector:</p>
<pre class="r"><code>a[c(2, 4)] # Refers to the second and fourth elements of vector a.</code></pre>
<pre><code>## [1]  2 -3</code></pre>
<pre class="r"><code>&#39;[&#39;(a, c(2,4)) # [ is a function! This is very handy in case of piping, as we see in the upcoming lessons.</code></pre>
<pre><code>## [1]  2 -3</code></pre>
<p>We can sort/order vector:</p>
<pre class="r"><code>sort(a, decreasing = FALSE) # sorts vector in ascending order</code></pre>
<pre><code>## [1] -3 -2  1  2  4  5  6</code></pre>
<p>We can extract uniqe elements of a vector:</p>
<pre class="r"><code>d</code></pre>
<pre><code>## [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE</code></pre>
<pre class="r"><code>unique(d) # Returns a vector, data frame or array like d but with duplicate elements removed.</code></pre>
<pre><code>## [1]  TRUE FALSE</code></pre>
<p>Create sequence:</p>
<pre class="r"><code>seq(2, 5, by = 0.5)</code></pre>
<pre><code>## [1] 2.0 2.5 3.0 3.5 4.0 4.5 5.0</code></pre>
<p>A complex sequence:</p>
<pre class="r"><code>rep(1:4, times = 2)</code></pre>
<pre><code>## [1] 1 2 3 4 1 2 3 4</code></pre>
<p>Repeat each element of a vector:</p>
<pre class="r"><code>rep(1:2, each = 3)</code></pre>
<pre><code>## [1] 1 1 1 2 2 2</code></pre>
<p>Repeat elements of a vector:</p>
<pre class="r"><code>rep(c(&quot;poodle&quot;,&quot;sheltie&quot;), each = 3, times = 2)</code></pre>
<pre><code>##  [1] &quot;poodle&quot;  &quot;poodle&quot;  &quot;poodle&quot;  &quot;sheltie&quot; &quot;sheltie&quot; &quot;sheltie&quot; &quot;poodle&quot; 
##  [8] &quot;poodle&quot;  &quot;poodle&quot;  &quot;sheltie&quot; &quot;sheltie&quot; &quot;sheltie&quot;</code></pre>
</div>
<div id="data-frame" class="section level1">
<h1>Data frame</h1>
<ul>
<li><p><code>data frame</code>: a collection of vectors where different columns can contain different modes of data (numeric, character, and so on). Each vector contains only 1 mode of data (<code>vector1 &lt;- c(&quot;a&quot;, 2, 3.4)</code> is automatically coerced to <code>chr</code>, but can be manually coerced to numeric or factor). The data frame columns are variables, and the rows are observations. Vectors are bound into matrix/data.frame vertically, with the direction from top to bottom. Column = vector. <code>as.matrix()</code> has default argument <code>byrow = FALSE</code>, change this to fill matrix by rows.</p></li>
<li><code>tibble::data_frame()</code> is a more modern version of data.frame (slight differences for the better) <code>as_data_frame()</code> converts to it. <code>data_frame()</code> does less than <code>data.frame()</code>:
<ul>
<li>it never changes the type of the inputs (e.g. it never converts strings to factors!),</li>
<li>it never changes the names of variables, and it never creates <code>row.names()</code>.</li>
</ul></li>
</ul>
<p><strong>Tibbles</strong> have a print method that shows only the first 10 rows, and all the columns that fit on screen. This makes it much easier to work with large data. <!-- In addition to its name, each column reports its type.  --> <!-- Tibbles clearly delineate `[` and `[[`: `[` always returns another tibble, `[[` always returns a vector.  --> <!-- Some older functions don't work with tibbles because they expect `df[, 1]` to return a vector, not a data frame.  --> <!-- If you encounter one of these functions, use `as.data.frame()` to coerce a tibble back to a data frame: --></p>
<div class="figure">
<img src="http://articles.concreteinteractive.com/wp-content/uploads/2015/03/irises.png" alt="Iris dataset contains sepal and petal measurements of three iris species." />
<p class="caption">Iris dataset contains sepal and petal measurements of three iris species.</p>
</div>
<pre class="r"><code>library(dplyr) # tbl_df 
tbl_df(iris)</code></pre>
<pre><code>## # A tibble: 150 x 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;  &lt;fctr&gt;
##  1          5.1         3.5          1.4         0.2  setosa
##  2          4.9         3.0          1.4         0.2  setosa
##  3          4.7         3.2          1.3         0.2  setosa
##  4          4.6         3.1          1.5         0.2  setosa
##  5          5.0         3.6          1.4         0.2  setosa
##  6          5.4         3.9          1.7         0.4  setosa
##  7          4.6         3.4          1.4         0.3  setosa
##  8          5.0         3.4          1.5         0.2  setosa
##  9          4.4         2.9          1.4         0.2  setosa
## 10          4.9         3.1          1.5         0.1  setosa
## # ... with 140 more rows</code></pre>
<pre class="r"><code>class(as.data.frame(tbl_df(iris)))</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<pre class="r"><code>library(tibble)
height &lt;- c(187, 190, 156)
name &lt;- c(&quot;Jim&quot;, &quot;Joe&quot;, &quot;Jill&quot;)
my_tab &lt;- data_frame(name, height) # object names are used as column names
my_tab</code></pre>
<pre><code>## # A tibble: 3 x 2
##    name height
##   &lt;chr&gt;  &lt;dbl&gt;
## 1   Jim    187
## 2   Joe    190
## 3  Jill    156</code></pre>
<pre class="r"><code>summary(my_tab) # Prints a summary of data</code></pre>
<pre><code>##      name               height     
##  Length:3           Min.   :156.0  
##  Class :character   1st Qu.:171.5  
##  Mode  :character   Median :187.0  
##                     Mean   :177.7  
##                     3rd Qu.:188.5  
##                     Max.   :190.0</code></pre>
<pre class="r"><code>names(my_tab) # Prints column names</code></pre>
<pre><code>## [1] &quot;name&quot;   &quot;height&quot;</code></pre>
<pre class="r"><code>nrow(my_tab) # number of rows</code></pre>
<pre><code>## [1] 3</code></pre>
<pre class="r"><code>ncol(my_tab)</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code>dim(my_tab)</code></pre>
<pre><code>## [1] 3 2</code></pre>
<div id="indexing-data.frames" class="section level2">
<h2>Indexing data.frames</h2>
<!-- Data frames can be indexed in several modes. When [ and [[ are used with a single vector index (x[i] or x[[i]]), they index the data frame as if it were a list. -->
<p>We use R <code>mtcars</code> dataset to illustrate indexing of a data.frame:</p>
<pre class="r"><code>class(mtcars)</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<pre class="r"><code>dim(mtcars) # what&#39;s the size of the data.frame</code></pre>
<pre><code>## [1] 32 11</code></pre>
<pre class="r"><code>mtc &lt;- mtcars[sample(1:nrow(mtcars), 6), ] # select a manageable subset
mtc</code></pre>
<pre><code>##                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
## Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
## Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
## Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
## Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
## Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4</code></pre>
<p>Here we select columns:</p>
<pre class="r"><code>mtc[,2] # selects 2nd column and returns vector</code></pre>
<pre><code>## [1] 4 8 4 8 8 8</code></pre>
<pre class="r"><code>mtc[3] # selects 3nd column and returns data.frame</code></pre>
<pre><code>##                      disp
## Fiat 128             78.7
## Ford Pantera L      351.0
## Toyota Corona       120.1
## Chrysler Imperial   440.0
## Hornet Sportabout   360.0
## Lincoln Continental 460.0</code></pre>
<pre class="r"><code>mtc[, &quot;hp&quot;] # selects column named &quot;hp&quot;</code></pre>
<pre><code>## [1]  66 264  97 230 175 215</code></pre>
<pre class="r"><code>mtc$cyl # selects column named &quot;cyl&quot;</code></pre>
<pre><code>## [1] 4 8 4 8 8 8</code></pre>
<pre class="r"><code>df &lt;- data.frame(M = c(2, 3, 6, 3, 34), N = c(34, 3, 8, 3, 3), L = c(TRUE, FALSE, TRUE, FALSE, TRUE))
df</code></pre>
<pre><code>##    M  N     L
## 1  2 34  TRUE
## 2  3  3 FALSE
## 3  6  8  TRUE
## 4  3  3 FALSE
## 5 34  3  TRUE</code></pre>
<pre class="r"><code>df[df$M == 34,] # selects rows from A that have value == 34</code></pre>
<pre><code>##    M N    L
## 5 34 3 TRUE</code></pre>
<pre class="r"><code>df[1:2, &quot;N&quot;] # selects rows 1 through 2 from column &quot;A&quot;</code></pre>
<pre><code>## [1] 34  3</code></pre>
<pre class="r"><code>rownames(df) &lt;- letters[1:5] # letters vector gives us lower case letters
df[rownames(df) == &quot;c&quot;,] # selects row named &quot;c&quot;</code></pre>
<pre><code>##   M N    L
## c 6 8 TRUE</code></pre>
<pre class="r"><code>df[-(2:4),] # drops rows 2 to 4 (incl)</code></pre>
<pre><code>##    M  N    L
## a  2 34 TRUE
## e 34  3 TRUE</code></pre>
<pre class="r"><code>df[, -2] # drops col 2, outputs vector! </code></pre>
<pre><code>##    M     L
## a  2  TRUE
## b  3 FALSE
## c  6  TRUE
## d  3 FALSE
## e 34  TRUE</code></pre>
<pre class="r"><code>df[df$M == 6,] # selects all rows that contain 6 in column named M</code></pre>
<pre><code>##   M N    L
## c 6 8 TRUE</code></pre>
<pre class="r"><code>df[df$M != 6,] # selects all rows that do not contain 6 in column named M</code></pre>
<pre><code>##    M  N     L
## a  2 34  TRUE
## b  3  3 FALSE
## d  3  3 FALSE
## e 34  3  TRUE</code></pre>
<pre class="r"><code>df[df$L==T,] # selects all rows where L is TRUE (T)</code></pre>
<pre><code>##    M  N    L
## a  2 34 TRUE
## c  6  8 TRUE
## e 34  3 TRUE</code></pre>
<p>What if we have duplicated rows or elements in our data frame or vector (and we want to get rid of them)?</p>
<pre class="r"><code>?duplicated #  determines which elements of a vector or data frame are duplicates of elements with smaller subscripts</code></pre>
<pre class="r"><code>df[!duplicated(df),] # removes second one of the duplicated rows from df, we have to use ! to negate logical evaluation</code></pre>
<pre><code>##    M  N     L
## a  2 34  TRUE
## b  3  3 FALSE
## c  6  8  TRUE
## e 34  3  TRUE</code></pre>
<pre class="r"><code>df[df$M &gt; median(df$N) &amp; df$M &lt; 25,] # selects rows where df$M value is &gt; median df$N AND df$M value &lt; 25</code></pre>
<pre><code>##   M N    L
## c 6 8 TRUE</code></pre>
<pre class="r"><code>df[df$M &gt; median(df$N) | df$M == 34,] # selects rows where df$M value is &gt; median df$N OR df$M value == 34</code></pre>
<pre><code>##    M N    L
## c  6 8 TRUE
## e 34 3 TRUE</code></pre>
<pre class="r"><code>sum(df$M[df$L==T]) # sums column df$M at rows where column &#39;L&#39; is TRUE (T)</code></pre>
<pre><code>## [1] 42</code></pre>
<p>A vector can be extracted by <code>$</code> and worked on:</p>
<pre class="r"><code>Mean.height &lt;- mean(my_tab$height)
Mean.height # Prints the answer</code></pre>
<pre><code>## [1] 177.6667</code></pre>
<p>New vectors can be bound into a data.frame:</p>
<pre class="r"><code>my_tab$weight &lt;- c(87, 96, 69) # Now there are 3 columns in my_tab
my_tab</code></pre>
<pre><code>## # A tibble: 3 x 3
##    name height weight
##   &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1   Jim    187     87
## 2   Joe    190     96
## 3  Jill    156     69</code></pre>
<pre class="r"><code>my_tab$experiment &lt;- factor(&quot;A&quot;) # the 4th col contains a factor with a single level &quot;A&quot;
levels(my_tab$experiment) # prints the unique levels in a factor vector</code></pre>
<pre><code>## [1] &quot;A&quot;</code></pre>
</div>
</div>
<div id="matrix" class="section level1">
<h1>Matrix</h1>
<p>Matrix: a collection of data elements, which are all numeric, character, or logical.</p>
<p>Why use matrix? The choice between matrix and data.frame comes up only if you have data of the same type.</p>
<ul>
<li><p>The answer depends on what you are going to do with the data in data.frame/matrix. If it is going to be passed to other functions then the expected type of the arguments of these functions determine the choice.</p></li>
<li><p>Matrices are more memory efficient:</p></li>
</ul>
<pre class="r"><code>m &lt;- matrix(1:4, 2, 2)
d &lt;- as.data.frame(m)
object.size(m)</code></pre>
<pre><code>## 216 bytes</code></pre>
<pre class="r"><code>object.size(d)</code></pre>
<pre><code>## 792 bytes</code></pre>
<ul>
<li>Matrices are a necessity if you plan to do any linear algebra-type of operations.</li>
<li>Data frames are more convenient if you frequently refer to its columns by name (via the <code>$</code> operator).</li>
<li>Data frames are also better for reporting tabular data as you can apply formatting to each column separately.</li>
</ul>
<pre class="r"><code>n &lt;- matrix(rnorm(30), ncol = 5) 
dim(n)</code></pre>
<pre><code>## [1] 6 5</code></pre>
<pre class="r"><code>n</code></pre>
<pre><code>##            [,1]       [,2]        [,3]       [,4]       [,5]
## [1,]  1.2915528  0.8321487  1.36106329 -0.2596357 -0.4083326
## [2,]  0.7170573 -0.5133217 -1.74289917  0.1468603 -0.1248493
## [3,] -2.4748254 -1.1996785  2.27626521  0.5212165  0.5171830
## [4,]  1.5035547 -2.1463541 -0.08352278 -1.3099626  1.3512791
## [5,] -1.8992912  0.2580687 -0.69198707  1.3053204 -0.3501478
## [6,] -1.1916429  0.7178047  1.15545814  1.4651412  1.1710221</code></pre>
<pre class="r"><code>exam # we created previously data.frame exam</code></pre>
<pre><code>##     name passed
## 1 Marina   TRUE
## 2  Allar  FALSE
## 3   Siim  FALSE
## 4   Mart  FALSE
## 5 Mailis   TRUE
## 6   Eiki   TRUE
## 7  Urmas   TRUE</code></pre>
<pre class="r"><code>class(exam)</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<pre class="r"><code>m &lt;- as.matrix(exam) # coerce data.frame with n,m dimension to a matrix with n,m dimension 
m</code></pre>
<pre><code>##      name     passed 
## [1,] &quot;Marina&quot; &quot; TRUE&quot;
## [2,] &quot;Allar&quot;  &quot;FALSE&quot;
## [3,] &quot;Siim&quot;   &quot;FALSE&quot;
## [4,] &quot;Mart&quot;   &quot;FALSE&quot;
## [5,] &quot;Mailis&quot; &quot; TRUE&quot;
## [6,] &quot;Eiki&quot;   &quot; TRUE&quot;
## [7,] &quot;Urmas&quot;  &quot; TRUE&quot;</code></pre>
<pre class="r"><code>t(m) # transposes a matrix</code></pre>
<pre><code>##        [,1]     [,2]    [,3]    [,4]    [,5]     [,6]    [,7]   
## name   &quot;Marina&quot; &quot;Allar&quot; &quot;Siim&quot;  &quot;Mart&quot;  &quot;Mailis&quot; &quot;Eiki&quot;  &quot;Urmas&quot;
## passed &quot; TRUE&quot;  &quot;FALSE&quot; &quot;FALSE&quot; &quot;FALSE&quot; &quot; TRUE&quot;  &quot; TRUE&quot; &quot; TRUE&quot;</code></pre>
<!-- Transpose a data frame with 1st column as factor -->
<!-- ```{r} -->
<!-- n <- exam$name -->
<!-- df <- as.data.frame(t(exam[,-1])) -->
<!-- colnames(df) <- n -->
<!-- df -->
<!-- ``` -->
<!-- ### Indexing matrices -->
<!-- Matrices are vectors with a dimension attribute and so all the vector forms of indexing can be used with a single index.  -->
<!-- ```{r} -->
<!-- m <- matrix(1:12, nrow = 3, dimnames = list(c("a","b","d"), LETTERS[1:4])) -->
<!-- m -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[1,]                 # the first row of matrix m -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[1, , drop = FALSE]  # is a 1-row matrix -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[, c(TRUE, FALSE, FALSE, TRUE)] # logical indexing -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[cbind(c(1,2,1), 3:1)] # matrix numeric index -->
<!-- ``` -->
<!-- ```{r} -->
<!-- ci <- cbind(c("a", "b", "a"), c("A", "C", "B")) -->
<!-- m[ci]                 # matrix character index -->
<!-- ``` -->
<!-- ```{r} -->
<!-- m[,-1]           # delete the first column of m -->
<!-- ``` -->
</div>
<div id="list" class="section level1">
<h1>List</h1>
<p>A list is an ordered collection of objects. Basically, in R you can shove any data structure into list. E.g. list may contain a combination of vectors, matrices, data frames, and even other lists, (poodles?). You can specify elements of the list by:</p>
<pre class="r"><code>mylist[[2]]</code></pre>
<pre><code>## [1] 53 51 25 67 66 41 62 42</code></pre>
<pre class="r"><code>mylist[[&quot;ages&quot;]]</code></pre>
<pre><code>## [1] 53 51 25 67 66 41 62 42</code></pre>
<pre class="r"><code>mylist$ages</code></pre>
<pre><code>## [1] 53 51 25 67 66 41 62 42</code></pre>
<p>As you can see all these above expressions give identical result</p>
<pre class="r"><code>all.equal(mylist[[2]], mylist[[&quot;ages&quot;]], mylist$ages)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<div id="indexing-lists" class="section level2">
<h2>Indexing lists</h2>
<p>Indexing by <code>[</code> is similar to atomic vectors and selects a list of the specified element(s). Both <code>[[</code> and <code>$</code> select a single element of the list (e.g. a single vector or data frame).</p>
<pre class="r"><code>mylist # here we go back to our mylist object</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## $ages
## [1] 53 51 25 67 66 41 62 42
## 
## $namez
## [1] &quot;Marina&quot; &quot;Allar&quot;  &quot;Siim&quot;   &quot;Mart&quot;   &quot;Mailis&quot; &quot;Eiki&quot;   &quot;Urmas&quot;</code></pre>
<pre class="r"><code>mylist[[1]]               # the first element of list mylist</code></pre>
<pre><code>## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>mylist[c(1, 3)]           # a list containing elements 1 and 3 of mylist</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## $namez
## [1] &quot;Marina&quot; &quot;Allar&quot;  &quot;Siim&quot;   &quot;Mart&quot;   &quot;Mailis&quot; &quot;Eiki&quot;   &quot;Urmas&quot;</code></pre>
<pre class="r"><code>mylist$ages               # the element of mylist named ages</code></pre>
<pre><code>## [1] 53 51 25 67 66 41 62 42</code></pre>
<p>Difference between using <code>[</code> and <code>[[</code> for subsetting a list: Square brackets <code>[</code> return subset of list as list:</p>
<pre class="r"><code>mylist[1]</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>class(mylist[1]) # returns list with one object</code></pre>
<pre><code>## [1] &quot;list&quot;</code></pre>
<pre class="r"><code>mylist[c(1,2)]</code></pre>
<pre><code>## $passed
## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE
## 
## $ages
## [1] 53 51 25 67 66 41 62 42</code></pre>
<pre class="r"><code>class(mylist[c(1,2)]) # returns list with two objects</code></pre>
<pre><code>## [1] &quot;list&quot;</code></pre>
<p>Double square brackets <code>[[</code> return single list object/value:</p>
<pre class="r"><code>mylist[[1]] # returns list object </code></pre>
<pre><code>## [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>class(mylist[[1]]) # logical vector in this case</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<p><strong>Warning</strong>: if you use double square brackets <code>[[</code> instead of <code>[</code> with index vector e.g. c(3,2) we get 2nd element from 3rd list object:</p>
<pre class="r"><code>mylist[[c(3,2)]]</code></pre>
<pre><code>## [1] &quot;Allar&quot;</code></pre>
<p>Be careful, if you won’t get <code>Error in ... : subscript out of bounds</code>, your script proceeds with this value and returns error in some of the next lines or returns wrong result.</p>
<!-- ### Recursive indexing into lists -->
<!-- ```{r} -->
<!-- z <- list(a = list(x = 9, y = "chello"), b = 1:5) # we create list named 'a' inside list 'z' -->
<!-- z -->
<!-- ``` -->
<!-- ```{r} -->
<!-- unlist(z) # look what happens if we simplify this list into vector... -->
<!-- ``` -->
<!-- ```{r} -->
<!-- z$a$x # what's a$x in list z -->
<!-- ``` -->
<!-- ```{r} -->
<!-- z[[c(1, 2)]] # we get second element of 1st element of list z -->
<!-- ``` -->
<!-- ```{r} -->
<!-- z[[c("a", "x")]] <- "piano" # here we replace z$a$x with "piano" -->
<!-- z -->
<!-- ``` -->
<p>Query names of list objects:</p>
<pre class="r"><code>names(mylist)</code></pre>
<pre><code>## [1] &quot;passed&quot; &quot;ages&quot;   &quot;namez&quot;</code></pre>
<p>Set/change names of list objects:</p>
<pre class="r"><code>names(mylist) &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)
names(mylist)</code></pre>
<pre><code>## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre>
<p>New name for nth list object:</p>
<pre class="r"><code>names(mylist)[2] &lt;- c(&quot;poodles&quot;)
names(mylist)</code></pre>
<pre><code>## [1] &quot;a&quot;       &quot;poodles&quot; &quot;c&quot;</code></pre>
</div>
<div id="output-from-statistical-tests" class="section level2">
<h2>Output from statistical tests</h2>
<p>Output of statistical tests in R is usually a list. Here we perform t test to compare two vectors a and b.</p>
<pre class="r"><code>a &lt;- rnorm(10) # random normal vector with mean 0
b &lt;- rnorm(10,2) # random normal vector with mean 2
t.result &lt;- t.test(a, b) # t test
str(t.result) # str() displays the internal structure of an R object</code></pre>
<pre><code>## List of 9
##  $ statistic  : Named num -3.8
##   ..- attr(*, &quot;names&quot;)= chr &quot;t&quot;
##  $ parameter  : Named num 12.1
##   ..- attr(*, &quot;names&quot;)= chr &quot;df&quot;
##  $ p.value    : num 0.0025
##  $ conf.int   : atomic [1:2] -2.375 -0.645
##   ..- attr(*, &quot;conf.level&quot;)= num 0.95
##  $ estimate   : Named num [1:2] 0.49 2
##   ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;mean of x&quot; &quot;mean of y&quot;
##  $ null.value : Named num 0
##   ..- attr(*, &quot;names&quot;)= chr &quot;difference in means&quot;
##  $ alternative: chr &quot;two.sided&quot;
##  $ method     : chr &quot;Welch Two Sample t-test&quot;
##  $ data.name  : chr &quot;a and b&quot;
##  - attr(*, &quot;class&quot;)= chr &quot;htest&quot;</code></pre>
<pre class="r"><code>t.result$conf.int # extracts an element from the list</code></pre>
<pre><code>## [1] -2.3754307 -0.6449174
## attr(,&quot;conf.level&quot;)
## [1] 0.95</code></pre>
<pre class="r"><code>t.result$p.value # p.value</code></pre>
<pre><code>## [1] 0.00250286</code></pre>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
